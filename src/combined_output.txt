===== START: C:\ai\LLM-Alchemy\src\app\globals.css ===== 
@import "tailwindcss";
@import "../styles/animations.css";

@theme {
  /* Custom Colors */
  --color-primary: #8b5cf6;
  --color-primary-hover: #7c3aed;
  --color-primary-light: #a78bfa;
  --color-primary-dark: #6d28d9;
  
  --color-secondary: #3b82f6;
  --color-secondary-hover: #2563eb;
  --color-secondary-light: #60a5fa;
  --color-secondary-dark: #1d4ed8;
  
  --color-danger: #ef4444;
  --color-danger-hover: #dc2626;
  --color-danger-light: #f87171;
  
  --color-success: #10b981;
  --color-success-hover: #059669;
  --color-success-light: #34d399;
  
  --color-warning: #f59e0b;
  --color-warning-hover: #d97706;
  --color-warning-light: #fbbf24;
  
  --color-science: #3b82f6;
  --color-science-hover: #2563eb;
  
  --color-creative: #8b5cf6;
  --color-creative-hover: #7c3aed;
  
  --color-surface-primary: #111827;
  --color-surface-secondary: #1f2937;
  --color-surface-tertiary: #374151;
}

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* Design System Utility Classes */
@layer components {
  /* Button System */
  .btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors inline-flex items-center gap-2 justify-center;
  }
  
  .btn-sm {
    @apply px-3 py-1 text-sm;
  }
  
  .btn-lg {
    @apply px-6 py-3 text-lg;
  }
  
  /* Button Variants */
  .btn-primary {
    background-color: var(--color-primary);
    color: white;
  }
  
  .btn-primary:hover {
    background-color: var(--color-primary-hover);
  }
  
  .btn-secondary {
    background-color: var(--color-secondary);
    color: white;
  }
  
  .btn-secondary:hover {
    background-color: var(--color-secondary-hover);
  }
  
  .btn-surface {
    background-color: var(--color-surface-tertiary);
    color: white;
  }
  
  .btn-surface:hover {
    @apply bg-gray-600;
  }
  
  .btn-danger {
    background-color: var(--color-danger);
    color: white;
  }
  
  .btn-danger:hover {
    background-color: var(--color-danger-hover);
  }
  
  .btn-success {
    background-color: var(--color-success);
    color: white;
  }
  
  .btn-success:hover {
    background-color: var(--color-success-hover);
  }
  
  .btn-ghost {
    @apply bg-transparent hover:bg-gray-700 text-gray-300 hover:text-white;
  }
  
  .btn-science {
    background-color: var(--color-science);
    color: white;
  }
  
  .btn-science:hover {
    background-color: var(--color-science-hover);
  }
  
  .btn-creative {
    background-color: var(--color-creative);
    color: white;
  }
  
  .btn-creative:hover {
    background-color: var(--color-creative-hover);
  }
  
  /* Button States */
  .btn:disabled {
    @apply opacity-50 cursor-not-allowed;
  }
  
  .btn-loading {
    @apply opacity-75 cursor-wait;
  }
  
  /* Cards & Surfaces */
  .card {
    background-color: var(--color-surface-secondary);
    @apply rounded-lg border border-gray-700;
  }
  
  .card-elevated {
    background-color: var(--color-surface-secondary);
    @apply rounded-lg border border-gray-700 shadow-lg;
  }
  
  .modal-backdrop {
    @apply fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4;
  }
  
  .modal-content {
    background-color: var(--color-surface-secondary);
    @apply rounded-xl p-6 w-full max-w-md border border-gray-600;
  }
  
  /* Typography */
  .text-heading {
    @apply text-xl font-bold text-white;
  }
  
  .text-subheading {
    @apply text-lg font-semibold text-white;
  }
  
  .text-body {
    @apply text-base text-gray-300;
  }
  
  .text-caption {
    @apply text-sm text-gray-400;
  }
  
  .text-muted {
    @apply text-gray-500;
  }
  
  /* Form Elements */
  .input {
    background-color: var(--color-surface-tertiary);
    @apply w-full px-3 py-2 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none;
  }
  
  .input:focus {
    border-color: var(--color-primary);
  }
  
  .input-sm {
    @apply px-2 py-1 text-sm;
  }
  
  /* Game Elements */
  .game-mode-toggle {
    background-color: var(--color-surface-tertiary);
    @apply relative inline-flex h-8 w-32 cursor-pointer items-center rounded-full transition-colors hover:bg-gray-600;
  }
  
  .game-mode-slider {
    @apply absolute left-1 h-6 w-14 rounded-full transition-transform;
  }
  
  .game-mode-text {
    @apply absolute text-xs font-medium z-10;
  }
  
  /* Element Cards */
  .element-card {
    @apply flex flex-col items-center justify-center rounded-lg cursor-move hover:scale-110 transition-transform;
  }
  
  .element-card-sm {
    @apply w-12 h-12;
  }
  
  .element-card-md {
    @apply w-14 h-14;
  }
  
  .element-card-lg {
    @apply w-16 h-16;
  }
  
  .element-emoji {
    @apply text-lg sm:text-xl pointer-events-none;
  }
  
  .element-name {
    @apply text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight pointer-events-none;
  }
  
  /* Progress Bars */
  .progress-bar {
    @apply w-full bg-gray-600/50 rounded-full h-1.5;
  }
  
  .progress-fill {
    @apply h-1.5 rounded-full transition-all duration-300;
  }
  
  /* Status Indicators */
  .status-online {
    @apply bg-green-600/20 text-green-400 border border-green-600/50;
  }
  
  .status-warning {
    background-color: color-mix(in srgb, var(--color-warning) 20%, transparent);
    color: var(--color-warning);
    border-color: color-mix(in srgb, var(--color-warning) 50%, transparent);
    @apply border;
  }
  
  .status-error {
    background-color: color-mix(in srgb, var(--color-danger) 20%, transparent);
    color: var(--color-danger);
    border-color: color-mix(in srgb, var(--color-danger) 50%, transparent);
    @apply border;
  }
  
  /* Hover Effects */
  .hover-glow:hover {
    box-shadow: 0 0 20px color-mix(in srgb, var(--color-primary) 30%, transparent);
  }
  
  .hover-glow-blue:hover {
    box-shadow: 0 0 20px color-mix(in srgb, var(--color-secondary) 30%, transparent);
  }
  
  /* Loading States */
  .loading-spinner {
    border-color: var(--color-primary);
    @apply animate-spin rounded-full border-4 border-t-transparent;
  }
  
  /* Element Dimming */
  .element-dimmed {
    opacity: 0.3;
  }
  
  /* Responsive Text */
  .text-responsive-xs {
    @apply text-xs sm:text-sm;
  }
  
  .text-responsive-sm {
    @apply text-sm sm:text-base;
  }
  
  .text-responsive-lg {
    @apply text-lg sm:text-xl;
  }
}

/* Custom Scrollbar for Mobile */
@layer utilities {
  .scrollbar-mobile {
    scrollbar-width: thin;
    scrollbar-color: #4b5563 #1f2937;
  }
  
  .scrollbar-mobile::-webkit-scrollbar {
    width: 6px;
  }
  
  .scrollbar-mobile::-webkit-scrollbar-track {
    background: #1f2937;
  }
  
  .scrollbar-mobile::-webkit-scrollbar-thumb {
    background: #4b5563;
    border-radius: 3px;
  }
  
  .scrollbar-mobile::-webkit-scrollbar-thumb:hover {
    background: #6b7280;
  }
}

/* Specific background colors that need custom colors */
.bg-surface-primary {
  background-color: var(--color-surface-primary);
}

.bg-surface-secondary {
  background-color: var(--color-surface-secondary);
}

.bg-surface-tertiary {
  background-color: var(--color-surface-tertiary);
}

.text-warning {
  color: var(--color-warning);
}
 
===== END: C:\ai\LLM-Alchemy\src\app\globals.css ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\layout.tsx ===== 
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { SupabaseProvider } from "@/components/auth/SupabaseProvider";

const geist = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "LLM Alchemy - AI Element Combination Game",
  description: "Discover new elements by combining existing ones using the power of AI. Choose between Science mode for realistic combinations or Creative mode for imaginative results!",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        {/* Preconnect to Turnstile for faster loading */}
        <link rel="preconnect" href="https://challenges.cloudflare.com" />
        <link rel="dns-prefetch" href="https://challenges.cloudflare.com" />
        <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit" async defer></script>
      </head>
      <body
        className={`${geist.variable} ${geistMono.variable} antialiased`}
      >
        <SupabaseProvider>
          {children}
        </SupabaseProvider>
      </body>
    </html>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\layout.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\page.tsx ===== 
'use client'

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import { Sparkles, ArrowRight, X } from 'lucide-react';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import {
  createClient,
  getGameProgress,
  resetGameState,
  getLlmModelPreference,
  updateLlmModelPreference,
  getChallengePreference,
  updateChallengePreference
} from '@/lib/supabase';
import { getStaticOpenMoji } from '@/lib/openmoji-service';
import dynamic from 'next/dynamic';

const AuthModal = dynamic(() => import('@/components/auth/AuthModal'), { ssr: false });
import { 
  checkAndHandleUpgradeCallback
} from '@/lib/auth-utils';
import { GAME_CONFIG } from '@/lib/game-config';

interface GameProgress {
  science: { elements: number, endElements: number, achievements: number, lastPlayed?: string } | null;
  creative: { elements: number, endElements: number, achievements: number, lastPlayed?: string } | null;
  lastMode: 'science' | 'creative';
}

export default function Home() {
  const { user, dbUser, dailyCount, loading } = useSupabase();
  const router = useRouter();
  const [progress, setProgress] = useState<GameProgress | null>(null);
  const [showResetModal, setShowResetModal] = useState(false);
  const [resetAchievements, setResetAchievements] = useState(false);
  const [selectedMode, setSelectedMode] = useState<'science' | 'creative'>('science');
  const [showApiKeyModal, setShowApiKeyModal] = useState(false);
  const [todaysChallenges, setTodaysChallenges] = useState<{id: string, challenge_type: string, title: string, reward_tokens: number, isCompleted: boolean, completionDetails: { element_discovered: string }}[]>([]);
  const [userApiKey, setUserApiKey] = useState<string>('');
  const [selectedModel, setSelectedModel] = useState<'flash' | 'pro'>('flash');
  const [tempApiKey, setTempApiKey] = useState<string>('');
  const [tempSelectedModel, setTempSelectedModel] = useState<'flash' | 'pro'>('flash');
  const [tempShowChallenges, setTempShowChallenges] = useState<boolean>(true);
  const [isValidatingKey, setIsValidatingKey] = useState<boolean>(false);
  const [toast, setToast] = useState<string>('');
  
  // Authentication state
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [authModalMode, setAuthModalMode] = useState<'login' | 'register'>('login');
  const [showUpgradeBenefits, setShowUpgradeBenefits] = useState(false);
  
  // Payment state
  const [isCreatingPayment, setIsCreatingPayment] = useState(false);
  const [showPaymentSection, setShowPaymentSection] = useState(false);
  
  // Challenge preferences - note: we show "Disable challenges" in UI but store as show_challenges in DB
  const [showChallenges, setShowChallenges] = useState(true);
  
  // Completed challenges modal
  const [showCompletedChallenges, setShowCompletedChallenges] = useState(false);
  const [completedChallenges, setCompletedChallenges] = useState<{
    id: string;
    element_discovered: string;
    game_mode: string;
    completed_at: string;
    challenges: {
      challenge_type: string;
      title: string;
      target_element: string;
      target_category: string;
      reward_tokens: number;
    } | null;
    tokens_awarded: number;
  }[]>([]);
  const [loadingCompleted, setLoadingCompleted] = useState(false);

  // Show toast function
  const showToast = (message: string) => {
    setToast(message);
    setTimeout(() => setToast(''), 3000);
  };

  // API key validation function
  const validateApiKey = async (apiKey: string): Promise<boolean> => {
    if (!apiKey.trim()) return false;
    
    setIsValidatingKey(true);
    try {
      const response = await fetch('/api/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          prompt: 'Test validation. Respond with just: {"result": "test", "emoji": "‚úÖ", "color": "#00FF00", "rarity": "common", "reasoning": "validation test", "tags": []}',
          gameMode: 'science',
          apiKey: apiKey,
          useProModel: false
        })
      });

      if (response.ok) {
        const result = await response.json();
        return !result.error;
      }
      return false;
    } catch (error) {
      console.error('API key validation error:', error);
      return false;
    } finally {
      setIsValidatingKey(false);
    }
  };

  // Load API key from localStorage and preferences from Supabase on mount
  useEffect(() => {
    const savedApiKey = localStorage.getItem('llm-alchemy-api-key');
    
    if (savedApiKey) {
      setUserApiKey(savedApiKey);
      // For API key users, load model preference from localStorage
      const savedModel = localStorage.getItem('llm-alchemy-model') as 'flash' | 'pro';
      if (savedModel && (savedModel === 'flash' || savedModel === 'pro')) {
        setSelectedModel(savedModel);
      }
    }
  }, []);

  // Load model preference and challenge preference from Supabase
  useEffect(() => {
    const loadPreferences = async () => {
      if (user) {
        const supabase = createClient();
        
        // Load model preference for non-API-key users
        if (!userApiKey) {
          const modelPreference = await getLlmModelPreference(supabase, user.id);
          setSelectedModel(modelPreference);
        }
        
        // Load challenge preference for all users
        const challengePreference = await getChallengePreference(supabase, user.id);
        setShowChallenges(challengePreference);
      }
    };

    loadPreferences();
  }, [user, userApiKey]);

  // Check for upgrade callback on mount
  useEffect(() => {
    const handleUpgradeCallback = async () => {
      const wasUpgraded = await checkAndHandleUpgradeCallback();
      if (wasUpgraded) {
        showToast('Account upgraded! Your progress has been saved.');
      }
    };
    
    handleUpgradeCallback();
  }, []);

  // Authentication handlers
  const handleAuthSuccess = () => {
    setShowAuthModal(false);
    showToast('Welcome! You can now purchase tokens and subscriptions.');
  };


  const handleShowAuth = (mode: 'login' | 'register' = 'login', showBenefits = false) => {
    setAuthModalMode(mode);
    setShowUpgradeBenefits(showBenefits);
    setShowAuthModal(true);
  };

  const handleLogout = async () => {
    try {
      const supabase = createClient();
      await supabase.auth.signOut();
      
      // Clear all local storage related to the app
      localStorage.removeItem('llm-alchemy-api-key');
      localStorage.removeItem('llm-alchemy-model');
      
      // Clear any other potential auth state
      window.location.reload();
      
      showToast('Logged out successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
      showToast('Error logging out: ' + errorMessage);
    }
  };

  // Payment handlers
  const handleStripePayment = async (productId: string) => {
    if (isAnonymous) {
      // Show auth modal first for anonymous users
      handleShowAuth('register', true);
      return;
    }

    setIsCreatingPayment(true);
    try {
      const response = await fetch('/api/stripe/checkout', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ productId }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || 'Payment creation failed');
      }

      // Redirect to Stripe Checkout
      if (result.url) {
        window.location.href = result.url;
      } else {
        throw new Error('No checkout URL received');
      }

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
      showToast(errorMessage || 'Payment failed');
    } finally {
      setIsCreatingPayment(false);
    }
  };

  // Check auth states
  const hasSession = !!user;
  const isRegistered = hasSession && !dbUser?.is_anonymous;
  const isAnonymous = hasSession && (dbUser?.is_anonymous || false);
  const isLoggedOut = !hasSession;

  // Save API key to localStorage when it changes
  useEffect(() => {
    if (userApiKey) {
      localStorage.setItem('llm-alchemy-api-key', userApiKey);
      localStorage.setItem('llm-alchemy-model', selectedModel);
    } else {
      localStorage.removeItem('llm-alchemy-api-key');
      localStorage.removeItem('llm-alchemy-model');
    }
  }, [userApiKey, selectedModel]);

  // Load game progress when user is available
  useEffect(() => {
    const loadProgress = async () => {
      if (user) {
        const supabase = createClient();
        const gameProgress = await getGameProgress(supabase, user.id);
        setProgress(gameProgress);
      }
    };

    loadProgress();
  }, [user]);

  // Load challenges for registered users
  useEffect(() => {
    const loadChallenges = async () => {
      if (isRegistered) {
        try {
          const response = await fetch('/api/challenges/current');
          if (response.ok) {
            const data = await response.json();
            setTodaysChallenges(data.challenges || []);
          }
        } catch (error) {
          console.error('Error loading challenges:', error);
        }
      } else {
        setTodaysChallenges([]);
      }
    };

    loadChallenges();
  }, [isRegistered]);

  // Refresh progress when page becomes visible (returning from game)
  useEffect(() => {
    const handleVisibilityChange = async () => {
      if (!document.hidden && user) {
        const supabase = createClient();
        const gameProgress = await getGameProgress(supabase, user.id);
        setProgress(gameProgress);
      }
    };

    const handleFocus = async () => {
      if (user) {
        const supabase = createClient();
        const gameProgress = await getGameProgress(supabase, user.id);
        setProgress(gameProgress);
      }
    };

    // Listen for page visibility changes and window focus
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleFocus);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
    };
  }, [user]);

  // Only show progress if there are more than the starting elements (5 base elements)
  const hasAnyProgress = progress && (
    (progress.science && progress.science.elements > 5) || 
    (progress.creative && progress.creative.elements > 5)
  );

  const handleContinueGame = () => {
    if (hasAnyProgress && progress) {
      // Go to game with last played mode
      router.push(`/game?mode=${progress.lastMode}`);
    } else {
      // No progress, start new game in science mode
      router.push('/game?mode=science');
    }
  };

  const handleResetMode = (gameMode: 'science' | 'creative') => {
    setSelectedMode(gameMode);
    setShowResetModal(true);
  };

  const confirmReset = async () => {
    if (user) {
      const supabase = createClient();
      await resetGameState(supabase, user.id, selectedMode, resetAchievements);
      setShowResetModal(false);
      setResetAchievements(false);
      // Refresh progress display
      const gameProgress = await getGameProgress(supabase, user.id);
      setProgress(gameProgress);
    }
  };

  // Load completed challenges function
  const loadCompletedChallenges = async () => {
    if (!isRegistered) return;
    
    setLoadingCompleted(true);
    try {
      const response = await fetch('/api/challenges/completed');
      if (response.ok) {
        const data = await response.json();
        setCompletedChallenges(data.completedChallenges || []);
      } else {
        showToast('Failed to load completed challenges');
      }
    } catch (error) {
      console.error('Error loading completed challenges:', error);
      showToast('Error loading completed challenges');
    } finally {
      setLoadingCompleted(false);
    }
  };

  const handleViewAllChallenges = async () => {
    if (!isRegistered) {
      showToast('Please register to view challenges');
      return;
    }
    
    await loadCompletedChallenges();
    setShowCompletedChallenges(true);
  };

  if (loading) {
    return (
      <main className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        <div className="text-xl">Loading...</div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-surface-primary text-white flex flex-col items-center justify-center p-4">
      <div className="max-w-lg w-full text-center">
        <div className="flex items-center justify-center gap-3 mb-8">
          <Sparkles className="text-warning" size={48} />
          <h1 className="text-5xl font-bold">LLM Alchemy</h1>
        </div>
        
        <p className="text-body mb-8">
          Combine elements to discover new ones using AI.
        </p>

        {/* Progress Display */}
        {hasAnyProgress && (
          <div className="bg-gray-800/50 rounded-lg p-6 mb-6 text-left">
            <h3 className="text-lg font-semibold mb-4 text-center">Your Progress</h3>
            
            <div className="space-y-3">
              {progress?.science && (
                <div className="flex justify-between items-center py-2 px-3 bg-blue-600/20 rounded">
                  <div className="flex items-center gap-2">
                    <span className="font-medium flex items-center gap-1">
                      <img src={getStaticOpenMoji('üß™')} alt="Science" className="w-4 h-4 hidden sm:inline" />
                      Science
                    </span>
                    <span className="text-xs text-gray-400">|</span>
                    <span className="text-sm text-gray-300">
                      {progress.science.elements} elements
                      {progress.science.endElements > 0 && `, ${progress.science.endElements} end`}
                    </span>
                  </div>
                  <button
                    onClick={() => handleResetMode('science')}
                    className="text-red-400 hover:text-red-300 transition-colors text-lg"
                    title="Reset Science Mode"
                  >
                    <img src={getStaticOpenMoji('‚ùå')} alt="Reset" className="w-4 h-4" />
                  </button>
                </div>
              )}
              
              {progress?.creative && (
                <div className="flex justify-between items-center py-2 px-3 bg-purple-600/20 rounded">
                  <div className="flex items-center gap-2">
                    <span className="font-medium flex items-center gap-1">
                      <img src={getStaticOpenMoji('üé®')} alt="Creative" className="w-4 h-4 hidden sm:inline" />
                      Creative
                    </span>
                    <span className="text-xs text-gray-400">|</span>
                    <span className="text-sm text-gray-300">
                      {progress.creative.elements} elements
                    </span>
                  </div>
                  <button
                    onClick={() => handleResetMode('creative')}
                    className="text-red-400 hover:text-red-300 transition-colors text-lg"
                    title="Reset Creative Mode"
                  >
                    <img src={getStaticOpenMoji('‚ùå')} alt="Reset" className="w-4 h-4" />
                  </button>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Single Action Button */}
        <div className="space-y-4">
          <button 
            onClick={handleContinueGame}
            className="flex items-center justify-center gap-2 max-w-md mx-auto bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-bold py-4 px-8 rounded-lg transition-all transform hover:scale-105"
          >
            {hasAnyProgress ? 'Continue Game' : 'New Game'}
            <ArrowRight size={20} />
          </button>
          
          <div className="text-sm text-gray-400 font-medium">
            {userApiKey ? (
              "Unlimited combinations"
            ) : dbUser?.subscription_status === 'premium' || (dbUser?.token_balance && dbUser.token_balance > 0) ? (
              `${dbUser.token_balance || 0} tokens remaining`
            ) : (
              `${Math.max(0, GAME_CONFIG.DAILY_FREE_COMBINATIONS - (dailyCount || 0))} combinations left today`
            )}
          </div>
          
          {/* Authentication / Account Status */}
          <div className="flex justify-center">
            {(isLoggedOut || isAnonymous) ? (
              <div className="space-y-3 flex flex-col items-center">
                <button
                  onClick={() => handleShowAuth('register')}
                  className="btn btn-surface btn-sm"
                >
                  <span>üë§</span>
                  <span>Register / Sign in</span>
                </button>
                <button
                  onClick={() => {
                    setTempApiKey(userApiKey);
                    setTempSelectedModel(selectedModel);
                    setTempShowChallenges(showChallenges);
                    setShowApiKeyModal(true);
                  }}
                  className="btn btn-surface btn-sm"
                >
                  <span>‚öôÔ∏è</span>
                  <span>LLM Options</span>
                </button>
              </div>
            ) : (
              <div className="space-y-3">
                <div className="flex items-center justify-center gap-3">
                  <div className="flex items-center gap-2 px-4 py-2 bg-green-600/20 rounded-lg text-green-400 text-sm">
                    <span>‚úì</span>
                    <span>Signed in as {dbUser?.display_name || dbUser?.email || user?.email || 'User'}</span>
                  </div>
                  <button
                    onClick={handleLogout}
                    className="btn btn-sm status-error"
                  >
                    <span>üö™</span>
                    <span>Logout</span>
                  </button>
                </div>
                <div className="flex justify-center">
                  <button
                    onClick={() => {
                      setTempApiKey(userApiKey);
                      setTempSelectedModel(selectedModel);
                      setTempShowChallenges(showChallenges);
                      setShowApiKeyModal(true);
                    }}
                    className="btn btn-surface btn-sm"
                  >
                    <span>‚öôÔ∏è</span>
                    <span>LLM Options</span>
                  </button>
                </div>
              </div>
            )}
          </div>
          
          {/* Upgrade button for registered freemium users */}
          {isRegistered && dbUser?.subscription_status === 'free' && (
            <div className="flex justify-center mt-4">
              <button
                onClick={() => setShowPaymentSection(!showPaymentSection)}
                className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 rounded-lg transition-colors text-sm text-white font-medium"
              >
                <span>‚≠ê</span>
                <span>{showPaymentSection ? 'Hide Options' : 'Upgrade'}</span>
              </button>
            </div>
          )}
          
          {/* Payment Buttons for Authenticated Users */}
          {!isAnonymous && dbUser && showPaymentSection && (
            <div className="mt-6 p-4 bg-gray-800/50 rounded-lg">
              <h3 className="text-lg font-semibold mb-4 text-center">Get More Tokens</h3>
              <div className="grid grid-cols-2 gap-3 mb-4">
                <button
                  onClick={() => handleStripePayment('tokens_100')}
                  disabled={isCreatingPayment}
                  className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-medium py-3 px-4 rounded-lg transition-all text-sm"
                >
                  {isCreatingPayment ? 'Processing...' : '100 tokens - ‚Ç¨0.40'}
                </button>
                <button
                  onClick={() => handleStripePayment('tokens_500')}
                  disabled={isCreatingPayment}
                  className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-medium py-3 px-4 rounded-lg transition-all text-sm"
                >
                  {isCreatingPayment ? 'Processing...' : '500 tokens - ‚Ç¨1.80'}
                </button>
                <button
                  onClick={() => handleStripePayment('tokens_1000')}
                  disabled={isCreatingPayment}
                  className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-medium py-3 px-4 rounded-lg transition-all text-sm"
                >
                  {isCreatingPayment ? 'Processing...' : '1000 tokens - ‚Ç¨3.50'}
                </button>
                <button
                  onClick={() => handleStripePayment('subscription_monthly')}
                  disabled={isCreatingPayment}
                  className="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white font-medium py-3 px-4 rounded-lg transition-all text-sm"
                >
                  {isCreatingPayment ? 'Processing...' : 'Monthly - ‚Ç¨5.99'}
                </button>
              </div>
              <div className="text-xs text-gray-400 text-center">
                Current balance: {dbUser.token_balance || 0} tokens
              </div>
            </div>
          )}

          
          {userApiKey && (
            <div className="text-xs text-green-400 mt-2">
              ‚úì Using your OpenRouter API key ‚Ä¢ Unlimited combinations
            </div>
          )}
        </div>

        {/* Challenges Preview - Moved to Bottom */}
        {isRegistered && showChallenges && todaysChallenges.length > 0 && (
          <div className="bg-gray-800/50 rounded-lg p-4 mt-6 text-left">
            <h3 className="text-sm font-semibold mb-3 text-center">Today&apos;s Challenges</h3>
            <div className="space-y-2">
              {todaysChallenges.slice(0, 3).map(challenge => (
                <div key={challenge.id} className="flex items-center justify-between text-xs">
                  <div className="flex items-center gap-2">
                    <span>{challenge.challenge_type === 'daily' ? 'üåü' : 'üèÜ'}</span>
                    <span className={`${challenge.isCompleted ? 'line-through text-green-400' : 'text-gray-300'}`}>
                      {challenge.title}
                    </span>
                    {challenge.isCompleted && challenge.completionDetails?.element_discovered && (
                      <span className="text-green-400 text-xs">
                        ‚úì {challenge.completionDetails.element_discovered}
                      </span>
                    )}
                  </div>
                  <span className={`${challenge.isCompleted ? 'text-green-400' : 'text-warning'}`}>
                    {challenge.isCompleted ? '‚úì' : `+${challenge.reward_tokens}`}
                  </span>
                </div>
              ))}
            </div>
            <div className="mt-3 text-center">
              <button
                onClick={handleViewAllChallenges}
                className="text-xs text-blue-400 hover:text-blue-300 underline"
              >
                View all challenges ‚Üí
              </button>
            </div>
          </div>
        )}
      </div>

      {/* LLM Options Modal */}
      {showApiKeyModal && (
        <div 
          className="modal-backdrop"
          onClick={(e) => {
            if (e.target === e.currentTarget) {
              setShowApiKeyModal(false);
            }
          }}
        >
          <div className="modal-content max-w-md">
            <div className="flex justify-between items-center mb-6">
              <h3 className="text-heading">LLM Options</h3>
              <button
                onClick={() => setShowApiKeyModal(false)}
                className="btn-ghost p-2 rounded-full"
              >
                <X size={20} />
              </button>
            </div>
            
            <div className="space-y-6">
              {/* Section 1: API Key Input */}
              <div>
                <div className="flex items-center gap-1 mb-2">
                  <label className="text-sm font-medium">
                    <a 
                      href="https://openrouter.ai/settings/keys" 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="text-blue-400 hover:text-blue-300 underline"
                    >
                      OpenRouter
                    </a>
                    {" "}API Key
                  </label>
                </div>
                <input
                  type="password"
                  value={tempApiKey}
                  onChange={(e) => setTempApiKey(e.target.value)}
                  placeholder="sk-or..."
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-purple-500"
                />
                <p className="text-xs text-gray-400 mt-1">
                  Use your own API key to play without limits (localStorage)
                </p>
              </div>
              
              {/* Separator */}
              <div className="border-t border-gray-600"></div>
              
              {/* Section 2: Model Selection Toggle */}
              <div>
                <label className="block text-sm font-medium mb-3">
                  LLM Selection
                </label>
                
                <div className="relative">
                  <button
                    onClick={() => {
                      // Check if user can toggle
                      const canToggle = userApiKey || 
                                      dbUser?.subscription_status === 'premium' || 
                                      (dbUser?.token_balance && dbUser.token_balance > 0);
                      
                      if (canToggle) {
                        setTempSelectedModel(tempSelectedModel === 'flash' ? 'pro' : 'flash');
                      } else {
                        showToast('Upgrade to toggle between Speed and Reasoning modes');
                      }
                    }}
                    className={`
                      w-full h-12 rounded-lg border-2 relative overflow-hidden transition-all
                      ${(userApiKey || dbUser?.subscription_status === 'premium' || (dbUser?.token_balance && dbUser.token_balance > 0))
                        ? 'border-purple-500 bg-gray-700 hover:bg-gray-600 cursor-pointer'
                        : 'border-gray-600 bg-gray-700/50 cursor-not-allowed opacity-50'
                      }
                    `}
                  >
                    <div className={`
                      absolute top-1 h-10 w-1/2 bg-purple-600 rounded-md transition-transform duration-200 ease-in-out
                      ${tempSelectedModel === 'pro' ? 'translate-x-full' : 'translate-x-0'}
                    `}></div>
                    
                    <div className="relative z-10 flex h-full">
                      <div className={`
                        flex-1 flex items-center justify-center font-medium transition-colors
                        ${tempSelectedModel === 'flash' ? 'text-white' : 'text-gray-300'}
                      `}>
                        Speed
                      </div>
                      <div className={`
                        flex-1 flex items-center justify-center font-medium transition-colors
                        ${tempSelectedModel === 'pro' ? 'text-white' : 'text-gray-300'}
                      `}>
                        Reasoning
                      </div>
                    </div>
                  </button>
                  
                  {!(userApiKey || dbUser?.subscription_status === 'premium' || (dbUser?.token_balance && dbUser.token_balance > 0)) && (
                    <p className="text-xs text-gray-500 mt-2">
                      Upgrade to unlock reasoning mode
                    </p>
                  )}
                </div>
              </div>
              
              {/* Separator */}
              <div className="border-t border-gray-600"></div>
              
              {/* Section 3: Challenge Toggle */}
              <div>
                <label className="block text-sm font-medium mb-3">
                  Gameplay Options
                </label>
                <label className={`flex items-center gap-3 ${isAnonymous ? 'cursor-not-allowed' : 'cursor-pointer'}`}>
                  <input
                    type="checkbox"
                    checked={isAnonymous ? true : !tempShowChallenges}
                    onChange={(e) => !isAnonymous && setTempShowChallenges(!e.target.checked)}
                    disabled={isAnonymous}
                    className={`w-4 h-4 text-purple-600 bg-gray-700 border-gray-600 rounded focus:ring-purple-500 focus:ring-2 ${isAnonymous ? 'opacity-50 cursor-not-allowed' : ''}`}
                  />
                  <span className={`text-sm ${isAnonymous ? 'text-gray-500' : 'text-gray-300'}`}>
                    Disable challenges
                  </span>
                </label>
                <p className="text-xs text-gray-400 mt-2">
                  {isAnonymous 
                    ? 'Challenges are only available for registered users'
                    : "When enabled, you won't receive challenge rewards or notifications"
                  }
                </p>
              </div>
              
              <div className="flex gap-3 justify-end mt-6">
                <button
                  onClick={() => {
                    setShowApiKeyModal(false);
                    setTempApiKey(userApiKey);
                    setTempSelectedModel(selectedModel);
                  }}
                  className="btn btn-surface"
                >
                  Cancel
                </button>
                <button
                  onClick={async () => {
                    // Validate API key if provided
                    if (tempApiKey.trim()) {
                      const isValid = await validateApiKey(tempApiKey);
                      if (!isValid) {
                        showToast('Invalid API key. Please check your OpenRouter API key and try again.');
                        return;
                      }
                    }
                    
                    // Save API key to localStorage
                    if (tempApiKey.trim()) {
                      setUserApiKey(tempApiKey);
                    } else {
                      setUserApiKey('');
                    }
                    
                    // Save model preference to Supabase
                    if (user && tempSelectedModel !== selectedModel) {
                      const supabase = createClient();
                      const success = await updateLlmModelPreference(supabase, user.id, tempSelectedModel);
                      if (success) {
                        setSelectedModel(tempSelectedModel);
                      }
                    }
                    
                    // Save challenge preference to Supabase (only for registered users)
                    if (user && !isAnonymous && tempShowChallenges !== showChallenges) {
                      const supabase = createClient();
                      const success = await updateChallengePreference(supabase, user.id, tempShowChallenges);
                      if (success) {
                        setShowChallenges(tempShowChallenges);
                      }
                    }
                    
                    setShowApiKeyModal(false);
                  }}
                  disabled={isValidatingKey}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    isValidatingKey 
                      ? 'bg-gray-600 cursor-not-allowed' 
                      : 'bg-purple-600 hover:bg-purple-500'
                  }`}
                >
                  {isValidatingKey ? 'Validating...' : 'Save'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Reset Mode Confirmation Modal */}
      {showResetModal && (
        <div className="modal-backdrop">
          <div className="modal-content max-w-sm">
            <h3 className="text-heading mb-3">Reset Progress?</h3>
            <p className="text-body mb-4">
              Reset discovered elements in {selectedMode} mode?
            </p>
            
            <div className="mb-6">
              <label className="flex items-center gap-2 text-caption">
                <input 
                  type="checkbox"
                  checked={resetAchievements}
                  onChange={(e) => setResetAchievements(e.target.checked)}
                  className="rounded"
                />
                Reset achievements
              </label>
            </div>
            
            <div className="flex gap-3 justify-end">
              <button
                onClick={() => {
                  setShowResetModal(false);
                  setResetAchievements(false);
                }}
                className="btn btn-surface"
              >
                Cancel
              </button>
              <button
                onClick={confirmReset}
                className="btn btn-danger"
              >
                Reset
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Completed Challenges Modal */}
      {showCompletedChallenges && (
        <div 
          className="modal-backdrop"
          onClick={(e) => {
            if (e.target === e.currentTarget) {
              setShowCompletedChallenges(false);
            }
          }}
        >
          <div className="modal-content max-w-2xl max-h-[80vh]">
            <div className="flex justify-between items-center mb-6">
              <h3 className="text-heading">Completed Challenges</h3>
              <button
                onClick={() => setShowCompletedChallenges(false)}
                className="btn-ghost p-2 rounded-full"
              >
                <X size={20} />
              </button>
            </div>
            
            {loadingCompleted ? (
              <div className="flex items-center justify-center py-8">
                <div className="text-center">
                  <div className="animate-spin rounded-full h-8 w-8 border-4 border-purple-500 border-t-transparent mx-auto mb-2"></div>
                  <div className="text-sm text-gray-400">Loading challenges...</div>
                </div>
              </div>
            ) : completedChallenges.length === 0 ? (
              <div className="text-center py-8">
                <div className="text-gray-400 text-lg mb-2">üéØ</div>
                <div className="text-gray-400">No completed challenges yet</div>
                <div className="text-gray-500 text-sm mt-1">Complete challenges in-game to see them here</div>
              </div>
            ) : (
              <div className="space-y-4 overflow-y-auto max-h-96">
                {completedChallenges.map((completion) => (
                  <div key={completion.id} className="bg-gray-700/50 rounded-lg p-4 border border-gray-600">
                    <div className="flex items-start justify-between mb-2">
                      <div className="flex items-center gap-3">
                        <span className="text-2xl">
                          {completion.challenges?.challenge_type === 'daily' ? 'üåü' : 'üèÜ'}
                        </span>
                        <div>
                          <div className="font-medium text-white">
                            {completion.challenges?.title || 'Challenge'}
                          </div>
                          <div className="text-sm text-gray-400">
                            {completion.challenges?.challenge_type === 'daily' ? 'Daily Challenge' : 'Weekly Challenge'}
                          </div>
                        </div>
                      </div>
                      <div className="text-right">
                        <div className="text-green-400 font-medium">
                          +{completion.tokens_awarded || completion.challenges?.reward_tokens || 0} tokens
                        </div>
                        <div className="text-xs text-gray-400">
                          {new Date(completion.completed_at).toLocaleDateString()}
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex items-center gap-2 text-sm">
                      <span className="text-gray-400">Discovered:</span>
                      <span className="text-blue-400 font-medium">{completion.element_discovered}</span>
                      {completion.game_mode && (
                        <>
                          <span className="text-gray-500">‚Ä¢</span>
                          <span className={`text-xs px-2 py-1 rounded ${
                            completion.game_mode === 'science' 
                              ? 'bg-blue-600/20 text-blue-400' 
                              : 'bg-purple-600/20 text-purple-400'
                          }`}>
                            {completion.game_mode}
                          </span>
                        </>
                      )}
                    </div>
                    
                    {completion.challenges?.target_element && (
                      <div className="text-xs text-gray-500 mt-1">
                        Target: {completion.challenges.target_element}
                      </div>
                    )}
                    
                    {completion.challenges?.target_category && (
                      <div className="text-xs text-gray-500 mt-1">
                        Category: {completion.challenges.target_category}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
            
            <div className="flex justify-center mt-6">
              <button
                onClick={() => setShowCompletedChallenges(false)}
                className="btn btn-surface"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}

      {/* AuthModal */}
      <AuthModal
        isOpen={showAuthModal}
        onClose={() => setShowAuthModal(false)}
        onSuccess={handleAuthSuccess}
        initialMode={authModalMode}
        showUpgradeBenefits={showUpgradeBenefits}
      />

      {/* Toast */}
      {toast && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 px-4 py-2 rounded-lg z-50">
          {toast}
        </div>
      )}
    </main>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\challenges\complete\route.ts ===== 
// Mark a challenge as completed for the current user
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';
import { elementMatchesCategory } from '@/lib/challenge-elements';

export const dynamic = 'force-dynamic';

// Element type from game state
interface SavedElement {
  id: string;
  name: string;
  emoji: string;
  color: string;
  unlockOrder: number;
  rarity?: string;
  reasoning?: string;
  tags?: string[];
  isEndElement?: boolean;
}

export async function POST(request: Request) {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check if user is anonymous - only registered users can complete challenges
    const { data: dbUser } = await supabase.from('users').select('is_anonymous').eq('id', user.id).single();
    if (dbUser?.is_anonymous) {
      return NextResponse.json({ 
        error: 'Anonymous users cannot complete challenges' 
      }, { status: 403 });
    }

    // Get request body
    const body = await request.json();
    const { challengeId, elementDiscovered, gameMode } = body;
    
    if (!challengeId || !elementDiscovered) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }
    
    // Verify the challenge exists and is active
    const { data: challenge, error: challengeError } = await supabase
      .from('challenges')
      .select('*')
      .eq('id', challengeId)
      .single();
    
    if (challengeError || !challenge) {
      return NextResponse.json({ error: 'Challenge not found' }, { status: 404 });
    }
    
    // Check if challenge is still active
    const now = new Date();
    const startDate = new Date(challenge.start_date);
    const endDate = new Date(challenge.end_date);
    
    if (now < startDate || now > endDate) {
      return NextResponse.json({ error: 'Challenge is not active' }, { status: 400 });
    }
    
    // Check if user already completed this challenge
    const { data: existingCompletion } = await supabase
      .from('challenge_completions')
      .select('id')
      .eq('user_id', user.id)
      .eq('challenge_id', challengeId)
      .single();
    
    if (existingCompletion) {
      return NextResponse.json({ error: 'Challenge already completed' }, { status: 400 });
    }
    
    // Validate that the discovered element meets the challenge criteria
    let challengeMet = false;
    
    if (challenge.challenge_type === 'daily' && challenge.target_category) {
      // For daily challenges, get the user's game state to verify they discovered the element
      const { data: gameState, error: gameStateError } = await supabase
        .from('game_states')
        .select('elements')
        .eq('user_id', user.id)
        .eq('game_mode', gameMode || 'science')
        .single();
      
      if (!gameStateError && gameState && gameState.elements) {
        // Find the discovered element in the user's game state
        const discoveredElement = (gameState.elements as SavedElement[]).find((el: SavedElement) => 
          el.name.toLowerCase() === elementDiscovered.toLowerCase()
        );
        
        if (discoveredElement && discoveredElement.tags) {
          // Use server-side tags from the user's saved game state
          const serverTags = Array.isArray(discoveredElement.tags) ? discoveredElement.tags : [];
          challengeMet = elementMatchesCategory(serverTags, challenge.target_category);
        }
      }
    } else if (challenge.challenge_type === 'weekly' && challenge.target_element) {
      // For weekly challenges, get the user's game state to verify they discovered the element
      const { data: gameState, error: gameStateError } = await supabase
        .from('game_states')
        .select('elements')
        .eq('user_id', user.id)
        .eq('game_mode', gameMode || 'science')
        .single();
      
      if (!gameStateError && gameState && gameState.elements) {
        // Check if the user has discovered the target element
        const discoveredElement = (gameState.elements as SavedElement[]).find((el: SavedElement) => 
          el.name.toLowerCase() === challenge.target_element.toLowerCase()
        );
        
        if (discoveredElement) {
          challengeMet = elementDiscovered.toLowerCase() === challenge.target_element.toLowerCase();
        }
      }
    }
    
    if (!challengeMet) {
      return NextResponse.json({ 
        error: 'Element does not meet challenge criteria',
        challengeType: challenge.challenge_type,
        targetCategory: challenge.target_category,
        targetElement: challenge.target_element
      }, { status: 400 });
    }
    
    // Insert completion record
    const { data: completion, error: completionError } = await supabase
      .from('challenge_completions')
      .insert({
        user_id: user.id,
        challenge_id: challengeId,
        element_discovered: elementDiscovered,
        game_mode: gameMode || 'science',
        completed_at: now.toISOString()
      })
      .select()
      .single();
    
    if (completionError) {
      console.error('Error inserting completion:', completionError);
      return NextResponse.json({ error: 'Failed to mark challenge as completed' }, { status: 500 });
    }
    
    // Award tokens to user if the challenge has a reward
    if (challenge.reward_tokens > 0) {
      const { data: newBalance, error: tokenError } = await supabase
        .rpc('increment_user_tokens', {
          p_user_id: user.id,
          p_amount: challenge.reward_tokens
        });
      
      if (!tokenError) {
        // Return the new token balance so the frontend can update
        return NextResponse.json({ 
          success: true,
          completion,
          tokensAwarded: challenge.reward_tokens,
          newTokenBalance: newBalance
        });
      } else {
        console.error('Error awarding tokens:', tokenError);
        // Still return success for completion, just warn about tokens
        return NextResponse.json({ 
          success: true,
          completion,
          tokensAwarded: 0,
          warning: 'Challenge completed but tokens could not be awarded'
        });
      }
    }
    
    return NextResponse.json({ 
      success: true,
      completion,
      tokensAwarded: 0
    });
    
  } catch (error) {
    console.error('Error in challenges/complete:', error);
    return NextResponse.json(
      { error: 'Failed to complete challenge' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\challenges\complete\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\challenges\completed\route.ts ===== 
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';
export const maxDuration = 30;

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Get the current user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch all completed challenges for the user
    const { data: completedChallenges, error } = await supabase
      .from('challenge_completions')
      .select(`
        id,
        challenge_id,
        element_discovered,
        game_mode,
        completed_at,
        challenges (
          challenge_type,
          title,
          target_element,
          target_category,
          reward_tokens,
          start_date,
          end_date
        )
      `)
      .eq('user_id', user.id)
      .order('completed_at', { ascending: false });

    if (error) {
      console.error('Error fetching completed challenges:', error);
      return NextResponse.json({ error: 'Failed to fetch completed challenges' }, { status: 500 });
    }

    return NextResponse.json({ 
      completedChallenges: completedChallenges || []
    });
    
  } catch (error) {
    console.error('Error in completed challenges API:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\challenges\completed\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\challenges\current\route.ts ===== 
// Get current active challenges with user completion status
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check if user is anonymous - only registered users can access challenges
    const { data: dbUser } = await supabase.from('users').select('is_anonymous').eq('id', user.id).single();
    if (dbUser?.is_anonymous) {
      return NextResponse.json({ 
        challenges: [],
        message: 'Register to access challenges' 
      }, { status: 403 });
    }

    const now = new Date();
    
    // Get active challenges
    const { data: challenges, error: challengesError } = await supabase
      .from('challenges')
      .select('*')
      .lte('start_date', now.toISOString())
      .gte('end_date', now.toISOString())
      .order('challenge_type', { ascending: true })
      .order('start_date', { ascending: false });
    
    if (challengesError) {
      console.error('Error fetching challenges:', challengesError);
      return NextResponse.json({ error: 'Failed to fetch challenges' }, { status: 500 });
    }
    
    // Get user's completions for active challenges
    const challengeIds = challenges?.map(c => c.id) || [];
    const { data: completions } = await supabase
      .from('challenge_completions')
      .select('*')
      .eq('user_id', user.id)
      .in('challenge_id', challengeIds);
    
    // Merge completion status with challenges
    const challengesWithStatus = challenges?.map(challenge => ({
      ...challenge,
      isCompleted: completions?.some(c => c.challenge_id === challenge.id) || false,
      completionDetails: completions?.find(c => c.challenge_id === challenge.id) || null
    })) || [];
    
    return NextResponse.json({ 
      challenges: challengesWithStatus,
      userId: user.id
    });
    
  } catch (error) {
    console.error('Error in challenges/current:', error);
    return NextResponse.json(
      { error: 'Failed to fetch challenges' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\challenges\current\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\challenges\generate\route.ts ===== 
// Challenge generation endpoint - called by Vercel Cron daily at midnight Copenhagen time
import { createServiceRoleClient } from '@/lib/supabase/server';
import { getRandomDailyCategories, getRandomWeeklyElement } from '@/lib/challenge-elements';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';
export const maxDuration = 30;

export async function GET(request: Request) {
  try {
    // Check for debug trigger
    const { searchParams } = new URL(request.url);
    const debugSecret = searchParams.get('secret');
    const isDebugRequest = debugSecret === 'my-llm-alchemy-cron-secret-2025-xyz789';
    
    // Verify cron secret to prevent unauthorized calls (skip if debug request)
    if (!isDebugRequest) {
      const authHeader = request.headers.get('authorization');
      const cronSecret = process.env.CRON_SECRET;
      
      // In development, allow calls without secret
      if (process.env.NODE_ENV === 'production' && cronSecret && authHeader !== `Bearer ${cronSecret}`) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
    }

    const supabase = await createServiceRoleClient();
    const now = new Date();
    
    // Get Copenhagen timezone midnight using proper timezone handling
    const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
    const today = new Date(copenhagenNow.getFullYear(), copenhagenNow.getMonth(), copenhagenNow.getDate());
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // DELETE ALL active daily challenges (not just ones starting today)
    await supabase
      .from('challenges')
      .delete()
      .eq('challenge_type', 'daily')
      .gte('end_date', today.toISOString()); // Delete all daily challenges that haven't ended yet
    
    // Generate exactly 2 new daily challenges
    const scienceCategories = getRandomDailyCategories('science', 1);
    const creativeCategories = getRandomDailyCategories('creative', 1);
    const allCategories = [...scienceCategories, ...creativeCategories];
    
    for (const category of allCategories) {
      const gameMode = scienceCategories.includes(category) ? 'science' : 'creative';
      const { data, error } = await supabase.from('challenges').insert({
        challenge_type: 'daily',
        title: category.title,
        target_category: category.category,
        game_mode: gameMode,
        reward_tokens: 5,
        start_date: today.toISOString(),
        end_date: tomorrow.toISOString()
      }).select();
      
      if (error) {
        console.error('Failed to insert daily challenge:', error);
        throw new Error(`Failed to insert daily challenge: ${error.message}`);
      }
      
      console.log('Successfully inserted daily challenge:', data);
    }
    
    console.log(`Deleted all active daily challenges and generated ${allCategories.length} new ones`);
    
    // Generate weekly challenge on Mondays (or every day for manual testing)
    const dayOfWeek = today.getUTCDay();
    if (dayOfWeek === 1 || isDebugRequest) { // Monday or manual debug request
      const weekEnd = new Date(today);
      weekEnd.setDate(weekEnd.getDate() + 7);
      
      // DELETE ALL active weekly challenges (not just check if one exists)
      await supabase
        .from('challenges')
        .delete()
        .eq('challenge_type', 'weekly')
        .gte('end_date', today.toISOString()); // Delete all weekly challenges that haven't ended yet
      
      // Get recent weekly challenges to avoid repeats
      const fourWeeksAgo = new Date(today);
      fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
      
      const { data: recentChallenges } = await supabase
        .from('challenges')
        .select('target_element')
        .eq('challenge_type', 'weekly')
        .gte('start_date', fourWeeksAgo.toISOString())
        .not('target_element', 'is', null);
      
      const recentElements = recentChallenges?.map(c => c.target_element).filter(Boolean) || [];
      // Randomly choose game mode for weekly challenge
      const gameMode = Math.random() < 0.5 ? 'science' : 'creative';
      const weeklyElement = getRandomWeeklyElement(gameMode, recentElements);
      
      const { data: weeklyData, error: weeklyError } = await supabase.from('challenges').insert({
        challenge_type: 'weekly',
        title: `Discover ${weeklyElement}`,
        target_element: weeklyElement,
        game_mode: gameMode,
        reward_tokens: 25,
        start_date: today.toISOString(),
        end_date: weekEnd.toISOString()
      }).select();
      
      if (weeklyError) {
        console.error('Failed to insert weekly challenge:', weeklyError);
        throw new Error(`Failed to insert weekly challenge: ${weeklyError.message}`);
      }
      
      console.log('Successfully inserted weekly challenge:', weeklyData);
      console.log(`Deleted all active weekly challenges and generated new one: ${weeklyElement}`);
    }
    
    // Mark expired challenges as inactive (optional, for future use)
    // We use end_date for active challenges, but this could be useful for cleanup
    
    return NextResponse.json({ 
      success: true, 
      message: 'Challenges generated successfully',
      timestamp: now.toISOString()
    });
    
  } catch (error) {
    console.error('Error generating challenges:', error);
    return NextResponse.json(
      { error: 'Failed to generate challenges' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\challenges\generate\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\generate\route.ts ===== 
import { NextRequest, NextResponse } from 'next/server';

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_URL = 'https://openrouter.ai/api/v1/chat/completions';

export async function POST(req: NextRequest) {
  try {
    const { prompt, apiKey, useProModel } = await req.json();

    // Use custom API key if provided, otherwise use server's key
    const activeApiKey = apiKey || OPENROUTER_API_KEY;

    if (!activeApiKey) {
      console.error('No API key available');
      return NextResponse.json(
        { error: 'No API key configured' },
        { status: 500 }
      );
    }

    // Model selection logic:
    // - If custom API key: user can choose between Flash and Pro
    // - If no custom key: Flash for freemium, Pro for paying (with tokens)
    let model;
    let userType;
    let reason;
    
    if (apiKey) {
      // User has their own API key, use their preference
      model = useProModel ? 'google/gemini-2.5-pro' : 'google/gemini-2.5-flash';
      userType = 'API Key User';
      reason = `User preference (${useProModel ? 'Pro' : 'Flash'} selected)`;
    } else {
      // Server's API key: Flash for freemium, Pro for paying users
      model = useProModel ? 'google/gemini-2.5-pro' : 'google/gemini-2.5-flash';
      userType = useProModel ? 'Token User' : 'Freemium User';
      reason = useProModel ? 'Has tokens (Pro model)' : 'Daily limit user (Flash model)';
    }
    
    // Log model selection for debugging
    console.log(`[LLM-Alchemy API] User Type: ${userType} | Model: ${model} | Reason: ${reason}`);

    // Use standard text format for both models
    const messageContent = prompt;

    // Adjust max_tokens based on model - Pro needs more tokens due to reasoning mode
    const maxTokens = model.includes('gemini-2.5-pro') ? 1500 : 500;
    
    // Build request body with reasoning control for Pro model
    const requestBody: {
      model: string;
      messages: { role: string; content: string }[];
      temperature: number;
      max_tokens: number;
      top_p: number;
      reasoning?: { effort: string };
    } = {
      model,
      messages: [
        {
          role: 'user',
          content: messageContent
        }
      ],
      temperature: 0.7,
      max_tokens: maxTokens,
      top_p: 0.9,
    };

    // Add reasoning control for Pro model to reduce costs
    if (model.includes('gemini-2.5-pro')) {
      requestBody.reasoning = {
        effort: 'low' // Uses ~20% of max_tokens for reasoning instead of default 80%
      };
    }

    const response = await fetch(OPENROUTER_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${activeApiKey}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
        'X-Title': 'LLM Alchemy Game',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error:', response.status, errorText);
      return NextResponse.json(
        { error: `OpenRouter API error: ${response.status}` },
        { status: response.status }
      );
    }

    const data = await response.json();
    
    // Enhanced debugging for model comparison
    console.log(`[LLM-Alchemy API] Model used: ${model}`);
    console.log(`[LLM-Alchemy API] OpenRouter response:`, {
      model: data.model,
      usage: data.usage,
      hasChoices: !!data.choices,
      choicesLength: data.choices?.length
    });
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      console.error('Invalid response structure:', data);
      return NextResponse.json(
        { error: 'Invalid response from OpenRouter' },
        { status: 500 }
      );
    }

    const content = data.choices[0].message.content;
    const reasoning = data.choices[0].message.reasoning;
    
    // Log the raw content and reasoning for debugging differences between models
    console.log(`[LLM-Alchemy API] Raw response content for ${model}:`, content);
    if (reasoning) {
      console.log(`[LLM-Alchemy API] Reasoning tokens for ${model}:`, reasoning.substring(0, 200) + '...');
      console.log(`[LLM-Alchemy API] Reasoning length: ${reasoning.length} characters`);
    }
    
    // Parse the JSON response from the LLM
    let parsedResult;
    try {
      // Extract JSON from the response if it's wrapped in code blocks or other text
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        console.log(`[LLM-Alchemy API] Extracted JSON for ${model}:`, jsonMatch[0]);
        parsedResult = JSON.parse(jsonMatch[0]);
      } else {
        console.log(`[LLM-Alchemy API] Parsing content directly for ${model}`);
        parsedResult = JSON.parse(content);
      }
    } catch (parseError) {
      console.error(`[LLM-Alchemy API] Failed to parse ${model} response:`, content);
      console.error('Parse error:', parseError);
      
      // Fallback to null result
      return NextResponse.json({
        result: null,
        emoji: '‚ùå',
        color: '#808080',
        rarity: 'common',
        reasoning: 'Failed to parse response',
        tags: [],
        isEndElement: false
      });
    }

    // Handle the new multi-outcome format from the LLM
    if (parsedResult.outcomes !== undefined) {
      // New format: {"outcomes": [...]} or {"outcomes": null, "reasoning": "..."}
      if (parsedResult.outcomes === null) {
        // No valid combination found
        return NextResponse.json({
          outcomes: null,
          reasoning: parsedResult.reasoning || 'No reaction'
        });
      } else if (Array.isArray(parsedResult.outcomes)) {
        // Valid outcomes found - validate each outcome
        const validatedOutcomes = parsedResult.outcomes.map((outcome: {
          result: string;
          emoji: string;
          color: string;
          rarity: string;
          reasoning: string;
          tags: string[];
          isEndElement: boolean;
        }) => ({
          result: outcome.result || 'Unknown',
          emoji: outcome.emoji || '‚ú®',
          color: outcome.color || '#808080',
          rarity: outcome.rarity || 'common',
          reasoning: outcome.reasoning || '',
          tags: Array.isArray(outcome.tags) ? outcome.tags : [],
          isEndElement: outcome.isEndElement || false
        }));
        
        return NextResponse.json({
          outcomes: validatedOutcomes
        });
      }
    }
    
    // Fallback for old format or malformed response
    const validatedEmoji = parsedResult.emoji || '‚ú®';
    const validatedResult = {
      result: parsedResult.result || null,
      emoji: validatedEmoji,
      color: parsedResult.color || '#808080',
      rarity: parsedResult.rarity || 'common',
      reasoning: parsedResult.reasoning || '',
      tags: Array.isArray(parsedResult.tags) ? parsedResult.tags : [],
      isEndElement: parsedResult.isEndElement || false
    };

    return NextResponse.json(validatedResult);

  } catch (error) {
    console.error('Generation error:', error);
    
    // Check if it's a network error
    if (error instanceof TypeError && error.message.includes('fetch')) {
      return NextResponse.json(
        { error: 'Network error: Unable to connect to OpenRouter' },
        { status: 503 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to generate combination' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\generate\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\stripe\checkout\route.ts ===== 
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createServerSupabaseClient } from '@/lib/supabase/server';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-06-30.basil',
});

// Define our products
const PRODUCTS = {
  tokens_100: {
    name: '100 Tokens',
    amount: 40, // ‚Ç¨0.40 in cents
    tokens: 100,
    description: 'Perfect for casual players',
  },
  tokens_500: {
    name: '500 Tokens',
    amount: 180, // ‚Ç¨1.80 in cents
    tokens: 500,
    description: 'Great value for regular players',
  },
  tokens_1000: {
    name: '1000 Tokens',
    amount: 350, // ‚Ç¨3.50 in cents
    tokens: 1000,
    description: 'For dedicated alchemists',
  },
  subscription_monthly: {
    name: 'Monthly Subscription',
    amount: 599, // ‚Ç¨5.99 in cents
    tokens: 0,
    description: 'Unlimited combinations',
  },
};

export async function POST(req: NextRequest) {
  try {
    const { productId } = await req.json();

    if (!productId || !PRODUCTS[productId as keyof typeof PRODUCTS]) {
      return NextResponse.json(
        { error: 'Invalid product ID' },
        { status: 400 }
      );
    }

    // Get user from Supabase
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    // Get user database record
    const { data: dbUser, error: dbError } = await supabase
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single();

    if (dbError || !dbUser) {
      return NextResponse.json(
        { error: 'User not found in database' },
        { status: 404 }
      );
    }

    // Check if user is anonymous (shouldn't be able to make payments)
    if (dbUser.is_anonymous) {
      return NextResponse.json(
        { error: 'Anonymous users cannot make payments. Please create an account first.' },
        { status: 403 }
      );
    }

    const product = PRODUCTS[productId as keyof typeof PRODUCTS];
    const isSubscription = productId === 'subscription_monthly';

    // Create Stripe checkout session
    const sessionConfig: Stripe.Checkout.SessionCreateParams = {
      payment_method_types: ['card', 'mobilepay'], // Include MobilePay for Danish users
      line_items: [
        {
          price_data: {
            currency: 'eur',
            product_data: {
              name: product.name,
              description: product.description,
            },
            unit_amount: product.amount,
            ...(isSubscription && {
              recurring: {
                interval: 'month',
              },
            }),
          },
          quantity: 1,
        },
      ],
      mode: isSubscription ? 'subscription' : 'payment',
      success_url: `${process.env.NEXT_PUBLIC_APP_URL}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/`,
      metadata: {
        userId: user.id,
        productId: productId,
        type: isSubscription ? 'subscription' : 'tokens',
        tokens: product.tokens.toString(),
      },
      customer_email: dbUser.email || undefined,
    };

    const session = await stripe.checkout.sessions.create(sessionConfig);

    // Create payment record in database
    const paymentType = isSubscription ? 'subscription' : 'tokens';
    const { error: paymentError } = await supabase
      .rpc('create_stripe_payment', {
        p_user_id: user.id,
        p_stripe_session_id: session.id,
        p_amount: product.amount / 100, // Convert cents to euros
        p_currency: 'EUR',
        p_type: paymentType,
        p_tokens_granted: product.tokens
      });

    if (paymentError) {
      console.error('Error creating payment record:', paymentError);
      return NextResponse.json(
        { error: 'Failed to create payment record' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      sessionId: session.id,
      url: session.url,
      amount: product.amount / 100,
      description: product.description,
    });

  } catch (error) {
    console.error('Stripe checkout error:', error);
    
    if (error instanceof Error) {
      return NextResponse.json(
        { error: `Checkout creation failed: ${error.message}` },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\stripe\checkout\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\stripe\webhook\route.ts ===== 
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { createServerSupabaseClient } from '@/lib/supabase/server';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-06-30.basil',
});

const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(req: NextRequest) {
  try {
    const body = await req.text();
    const signature = req.headers.get('stripe-signature');

    if (!signature) {
      console.error('No Stripe signature found');
      return NextResponse.json(
        { error: 'No signature found' },
        { status: 400 }
      );
    }

    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(body, signature, endpointSecret);
    } catch (err) {
      console.error('Webhook signature verification failed:', err);
      return NextResponse.json(
        { error: 'Webhook signature verification failed' },
        { status: 400 }
      );
    }

    console.log(`[Stripe Webhook] Processing event: ${event.type}`);

    // Handle the event
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
        break;
      
      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;
      
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
      
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
      
      default:
        console.log(`[Stripe Webhook] Unhandled event type: ${event.type}`);
    }

    return NextResponse.json({ received: true });

  } catch (error) {
    console.error('Stripe webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  try {
    console.log(`[Webhook] Checkout session completed: ${session.id}`);
    
    const supabase = await createServerSupabaseClient();
    
    // Determine payment status
    const paymentStatus = session.payment_status === 'paid' ? 'paid' : 'pending';
    
    // Update payment record
    const { data: updateResult, error: updateError } = await supabase
      .rpc('update_stripe_payment_status', {
        p_stripe_session_id: session.id,
        p_stripe_payment_id: session.payment_intent as string,
        p_status: paymentStatus,
        p_stripe_customer_id: session.customer as string,
        p_webhook_data: {
          event_type: 'checkout.session.completed',
          session_id: session.id,
          payment_status: session.payment_status,
          amount_total: session.amount_total,
          currency: session.currency,
          customer: session.customer,
          metadata: session.metadata,
          timestamp: new Date().toISOString(),
        },
      });

    if (updateError) {
      console.error('Error updating payment status:', updateError);
      return;
    }

    if (!updateResult) {
      console.error(`Payment record not found for session: ${session.id}`);
      return;
    }

    console.log(`[Webhook] Successfully processed checkout session: ${session.id}`);
    
  } catch (error) {
    console.error('Error handling checkout session completed:', error);
  }
}

async function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {
  try {
    console.log(`[Webhook] Invoice payment succeeded: ${invoice.id}`);
    
    // This handles recurring subscription payments
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((invoice as any).subscription && invoice.metadata?.userId) {
      const supabase = await createServerSupabaseClient();
      
      // Update subscription status and extend subscription period
      const { error: updateError } = await supabase
        .from('users')
        .update({
          subscription_status: 'premium',
          subscription_ends_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
        })
        .eq('id', invoice.metadata.userId);

      if (updateError) {
        console.error('Error updating subscription status:', updateError);
      } else {
        console.log(`[Webhook] Extended subscription for user: ${invoice.metadata.userId}`);
      }
    }
    
  } catch (error) {
    console.error('Error handling invoice payment succeeded:', error);
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  try {
    console.log(`[Webhook] Subscription updated: ${subscription.id}`);
    
    const supabase = await createServerSupabaseClient();
    
    // Update subscription record
    const { error: updateError } = await supabase
      .from('subscriptions')
      .update({
        status: subscription.status,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        next_payment_date: (subscription as any).current_period_end ? new Date((subscription as any).current_period_end * 1000) : null,
        updated_at: new Date().toISOString(),
      })
      .eq('stripe_subscription_id', subscription.id);

    if (updateError) {
      console.error('Error updating subscription:', updateError);
    }
    
  } catch (error) {
    console.error('Error handling subscription updated:', error);
  }
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  try {
    console.log(`[Webhook] Subscription deleted: ${subscription.id}`);
    
    const supabase = await createServerSupabaseClient();
    
    // Update subscription record
    const { error: updateError } = await supabase
      .from('subscriptions')
      .update({
        status: 'canceled',
        canceled_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq('stripe_subscription_id', subscription.id);

    if (updateError) {
      console.error('Error updating canceled subscription:', updateError);
    }
    
    // Also update user's subscription status
    const { error: userUpdateError } = await supabase
      .from('users')
      .update({
        subscription_status: 'free',
        subscription_ends_at: null,
      })
      .eq('id', subscription.metadata?.userId);

    if (userUpdateError) {
      console.error('Error updating user subscription status:', userUpdateError);
    }
    
  } catch (error) {
    console.error('Error handling subscription deleted:', error);
  }
}

// Handle GET requests (for webhook verification)
export async function GET() {
  return NextResponse.json({ 
    message: 'Stripe webhook endpoint is active',
    timestamp: new Date().toISOString() 
  });
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\stripe\webhook\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\api\verify-turnstile\route.ts ===== 
import { NextRequest, NextResponse } from 'next/server';

const TURNSTILE_SECRET_KEY = process.env.TURNSTILE_SECRET_KEY;
const VERIFY_ENDPOINT = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { token } = body;

    if (!token) {
      return NextResponse.json(
        { success: false, error: 'Token is required' },
        { status: 400 }
      );
    }

    if (!TURNSTILE_SECRET_KEY) {
      console.error('TURNSTILE_SECRET_KEY not configured');
      // Fail open - if secret key not configured, allow the request
      // This prevents blocking users if Turnstile is misconfigured
      return NextResponse.json({ success: true, failOpen: true });
    }

    // Verify the token with Cloudflare
    const formData = new FormData();
    formData.append('secret', TURNSTILE_SECRET_KEY);
    formData.append('response', token);
    
    // Optional: Add the user's IP address for additional security
    const remoteIp = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown';
    formData.append('remoteip', remoteIp);

    const result = await fetch(VERIFY_ENDPOINT, {
      method: 'POST',
      body: formData,
    });

    const outcome = await result.json();

    if (!outcome.success) {
      console.warn('Turnstile verification failed:', outcome['error-codes']);
      return NextResponse.json(
        { 
          success: false, 
          error: 'Verification failed',
          errorCodes: outcome['error-codes'] 
        },
        { status: 400 }
      );
    }

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Turnstile verification error:', error);
    // Fail open on errors to prevent blocking legitimate users
    return NextResponse.json({ 
      success: true, 
      failOpen: true,
      error: 'Verification service unavailable' 
    });
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\app\api\verify-turnstile\route.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\auth\callback\page.tsx ===== 
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/browser';

export default function AuthCallback() {
  const [status, setStatus] = useState('Processing...');
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const handleAuthCallback = async () => {
      try {
        setStatus('Completing authentication...');
        
        // Handle both email and OAuth callbacks
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        const error = urlParams.get('error');
        
        if (error) {
          console.error('OAuth error:', error);
          setStatus('Authentication failed. Redirecting...');
          setTimeout(() => router.push('/'), 3000);
          return;
        }
        
        // Exchange code for session (works for both email and OAuth)
        if (code) {
          const { error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);
          if (exchangeError) {
            // For OAuth, this might be expected - continue to session check
            console.warn('Code exchange warning (may be normal for OAuth):', exchangeError);
          }
        }
        
        // Get the current session
        const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
        
        if (sessionError) {
          console.error('Session error:', sessionError);
          setStatus('Authentication failed. Redirecting...');
          setTimeout(() => router.push('/'), 3000);
          return;
        }

        if (sessionData.session) {
          // User successfully authenticated
          setStatus('Authentication successful! Setting up your account...');
          
          const user = sessionData.session.user;
          const anonymousUserId = localStorage.getItem('anonymous_user_id');
          
          // Create or update user record with all necessary fields
          const userRecord = {
            id: user.id,
            email: user.email,
            display_name: user.user_metadata?.display_name || 
                         user.user_metadata?.full_name || 
                         user.email?.split('@')[0],
            avatar_url: user.user_metadata?.avatar_url,
            google_id: user.app_metadata?.provider === 'google' ? 
                      user.user_metadata?.sub : null,
            is_anonymous: false,
            email_verified: user.email_confirmed_at !== null,
            upgraded_from_anonymous: !!anonymousUserId,
            anonymous_data_migrated: false, // Will update after migration
            updated_at: new Date().toISOString()
          };

          try {
            const { error: userError } = await supabase
              .from('users')
              .upsert(userRecord, {
                onConflict: 'id'
              });

            if (userError) {
              console.error('User record error:', userError);
              // Continue anyway - this is non-critical for auth flow
            } else {
              console.log('‚úÖ User record created/updated successfully');
            }
          } catch (dbError) {
            console.error('Database error (non-critical):', dbError);
          }

          // Migrate anonymous user data if exists
          if (anonymousUserId && anonymousUserId !== user.id) {
            try {
              setStatus('Migrating your game progress...');
              
              // Transfer game states
              await supabase
                .from('game_states')
                .update({ user_id: user.id })
                .eq('user_id', anonymousUserId);

              // Transfer user sessions
              await supabase
                .from('user_sessions')
                .update({ user_id: user.id })
                .eq('user_id', anonymousUserId);

              // Transfer discovered elements
              await supabase
                .from('discovered_elements')
                .update({ user_id: user.id })
                .eq('user_id', anonymousUserId);

              // Mark migration complete
              await supabase
                .from('users')
                .update({ anonymous_data_migrated: true })
                .eq('id', user.id);

              // Clean up anonymous user record
              await supabase
                .from('users')
                .delete()
                .eq('id', anonymousUserId);

              // Remove from localStorage
              localStorage.removeItem('anonymous_user_id');
              
              console.log('‚úÖ Anonymous user data migrated successfully');
            } catch (migrationError) {
              console.error('Migration error (non-critical):', migrationError);
              // Still mark as attempted
              try {
                await supabase
                  .from('users')
                  .update({ anonymous_data_migrated: true })
                  .eq('id', user.id);
              } catch (updateError) {
                console.error('Failed to mark migration status:', updateError);
              }
            }
          }

          // Redirect to home page
          setStatus('Redirecting to game...');
          setTimeout(() => router.push('/'), 1000);
        } else {
          setStatus('No session found. Redirecting...');
          setTimeout(() => router.push('/'), 3000);
        }
      } catch (error) {
        console.error('Callback processing error:', error);
        setStatus('An error occurred. Redirecting...');
        setTimeout(() => router.push('/'), 3000);
      }
    };

    handleAuthCallback();
  }, [router, supabase]);

  return (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center">
      <div className="bg-gray-800 rounded-xl p-8 text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mx-auto mb-4"></div>
        <h2 className="text-xl font-bold text-white mb-2">Authentication</h2>
        <p className="text-gray-400">{status}</p>
      </div>
    </div>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\auth\callback\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\game\page.tsx ===== 
'use client';

import { useSupabase } from '@/components/auth/SupabaseProvider';
import { useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Dynamic import to avoid SSR issues with browser-only APIs
const LLMAlchemyWrapper = dynamic(() => import('@/components/game/LLMAlchemy/LLMAlchemyWrapper'), {
  ssr: false,
  loading: () => (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center">
      <div className="text-white text-xl">Loading game...</div>
    </div>
  )
});

export default function GamePage() {
  const { user, loading, signInAnonymously } = useSupabase();
  const [gameReady, setGameReady] = useState(false);
  const [initializing, setInitializing] = useState(false);

  useEffect(() => {
    const initializeGameUser = async () => {
      if (loading) return;

      if (!user) {
        // No user session - create anonymous user for the game
        setInitializing(true);
        try {
          await signInAnonymously();
          setGameReady(true);
        } catch (error) {
          console.error('Failed to create anonymous user for game:', error);
          // Still allow game to load, but without save functionality
          setGameReady(true);
        } finally {
          setInitializing(false);
        }
      } else {
        // User already exists
        setGameReady(true);
      }
    };

    initializeGameUser();
  }, [user, loading, signInAnonymously]);

  if (loading || initializing || !gameReady) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white text-xl">
          {initializing ? 'Setting up your game session...' : 'Loading game...'}
        </div>
      </div>
    );
  }

  return <LLMAlchemyWrapper />;
}
 
===== END: C:\ai\LLM-Alchemy\src\app\game\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\payment\success\page.tsx ===== 
'use client';

import { useEffect, useState, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Sparkles, CheckCircle, ArrowRight, Home } from 'lucide-react';

// Force dynamic rendering to avoid static generation issues
export const dynamic = 'force-dynamic';

function PaymentSuccessContent() {
  const [status, setStatus] = useState('Processing payment...');
  const router = useRouter();
  const searchParams = useSearchParams();

  useEffect(() => {
    const checkPaymentStatus = async () => {
      try {
        // Get session ID from URL parameters
        const sessionId = searchParams.get('session_id');
        
        if (!sessionId) {
          setStatus('No session ID found');
          return;
        }

        // Since we're redirected here from Stripe, we can assume success
        // The webhook will handle the actual payment processing
        setStatus('Payment successful!');

        // Redirect to home after 5 seconds
        setTimeout(() => {
          router.push('/');
        }, 5000);

      } catch (error) {
        console.error('Error checking payment status:', error);
        setStatus('Error verifying payment');
      }
    };

    checkPaymentStatus();
  }, [searchParams, router]);

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4">
      <div className="max-w-md w-full text-center">
        <div className="flex items-center justify-center gap-3 mb-8">
          <Sparkles className="text-yellow-400" size={48} />
          <h1 className="text-3xl font-bold">LLM Alchemy</h1>
        </div>

        <div className="bg-gray-800 rounded-xl p-8 mb-6">
          {status === 'Payment successful!' ? (
            <>
              <div className="flex justify-center mb-4">
                <CheckCircle className="text-green-400" size={64} />
              </div>
              <h2 className="text-2xl font-bold text-green-400 mb-4">
                Payment Successful!
              </h2>
              <p className="text-gray-300 mb-6">
                Thank you for your purchase. Your tokens have been added to your account 
                and your subscription has been activated.
              </p>
              <div className="space-y-4">
                <button
                  onClick={() => router.push('/game')}
                  className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-medium py-3 px-6 rounded-lg transition-all"
                >
                  <span>Start Playing</span>
                  <ArrowRight size={20} />
                </button>
                <button
                  onClick={() => router.push('/')}
                  className="w-full flex items-center justify-center gap-2 bg-gray-700 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-lg transition-all"
                >
                  <Home size={20} />
                  <span>Go Home</span>
                </button>
              </div>
            </>
          ) : (
            <>
              <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mx-auto mb-4"></div>
              <h2 className="text-xl font-bold mb-2">Processing Payment</h2>
              <p className="text-gray-400">{status}</p>
            </>
          )}
        </div>

        <div className="text-sm text-gray-400">
          <p>You will be redirected to the home page in a few seconds.</p>
          <p className="mt-2">
            If you have any issues, please contact support at{' '}
            <a href="mailto:support@llmalchemy.com" className="text-purple-400 hover:text-purple-300">
              support@llmalchemy.com
            </a>
          </p>
        </div>
      </div>
    </div>
  );
}

export default function PaymentSuccess() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4">
        <div className="max-w-md w-full text-center">
          <div className="flex items-center justify-center gap-3 mb-8">
            <Sparkles className="text-yellow-400" size={48} />
            <h1 className="text-3xl font-bold">LLM Alchemy</h1>
          </div>
          <div className="bg-gray-800 rounded-xl p-8 mb-6">
            <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mx-auto mb-4"></div>
            <h2 className="text-xl font-bold mb-2">Loading Payment Status</h2>
            <p className="text-gray-400">Please wait...</p>
          </div>
        </div>
      </div>
    }>
      <PaymentSuccessContent />
    </Suspense>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\payment\success\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\test-captcha\page.tsx ===== 
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { ArrowLeft, Shield, CheckCircle, XCircle, RefreshCw } from 'lucide-react';
import Link from 'next/link';
import { initTurnstile, executeTurnstile, isTurnstileReady, getTurnstileToken } from '@/lib/turnstile';

// Force dynamic rendering to avoid static generation issues
export const dynamic = 'force-dynamic';

export default function TestCaptchaPage() {
  const [testResults, setTestResults] = useState<{
    automated?: { success: boolean; message: string; token?: string };
    explicitExecute?: { success: boolean; message: string; token?: string };
    serverVerify?: { success: boolean; message: string };
  }>({});
  const [isLoading, setIsLoading] = useState<string | null>(null);
  const [turnstileLoaded, setTurnstileLoaded] = useState(false);
  
  const explicitWidgetRef = useRef<HTMLDivElement>(null);
  const explicitResetRef = useRef<(() => void) | null>(null);

  useEffect(() => {
    // Check if Turnstile is loaded
    const checkInterval = setInterval(() => {
      if (isTurnstileReady()) {
        setTurnstileLoaded(true);
        clearInterval(checkInterval);
      }
    }, 100);

    return () => clearInterval(checkInterval);
  }, []);

  // Initialize explicit widget when component mounts
  useEffect(() => {
    if (turnstileLoaded && explicitWidgetRef.current && !explicitResetRef.current) {
      initTurnstile(explicitWidgetRef.current, (token) => {
        if (token) {
          setTestResults(prev => ({
            ...prev,
            explicitExecute: {
              success: true,
              message: 'Explicit+Execute captcha successful!',
              token: token.substring(0, 20) + '...'
            }
          }));
        } else {
          setTestResults(prev => ({
            ...prev,
            explicitExecute: {
              success: false,
              message: 'Captcha verification failed'
            }
          }));
        }
        setIsLoading(null);
      }).then((resetFn) => {
        explicitResetRef.current = resetFn;
      });
    }
  }, [turnstileLoaded]);

  const testAutomatedFlow = async () => {
    setIsLoading('automated');
    setTestResults(prev => ({ ...prev, automated: undefined }));

    try {
      const token = await getTurnstileToken();
      
      if (token) {
        setTestResults(prev => ({
          ...prev,
          automated: {
            success: true,
            message: 'Automated flow successful!',
            token: token.substring(0, 20) + '...'
          }
        }));
      } else {
        setTestResults(prev => ({
          ...prev,
          automated: {
            success: false,
            message: 'Failed to get token (timeout or error)'
          }
        }));
      }
    } catch (error) {
      setTestResults(prev => ({
        ...prev,
        automated: {
          success: false,
          message: error instanceof Error ? error.message : 'Unknown error'
        }
      }));
    } finally {
      setIsLoading(null);
    }
  };

  const testExplicitExecute = () => {
    setIsLoading('explicitExecute');
    setTestResults(prev => ({ ...prev, explicitExecute: undefined }));
    
    if (explicitWidgetRef.current) {
      executeTurnstile(explicitWidgetRef.current);
    }
  };

  const testServerVerification = async () => {
    setIsLoading('server');
    setTestResults(prev => ({ ...prev, serverVerify: undefined }));

    try {
      // First get a token
      const token = await getTurnstileToken();
      
      if (!token) {
        setTestResults(prev => ({
          ...prev,
          serverVerify: {
            success: false,
            message: 'Failed to get token for verification'
          }
        }));
        return;
      }

      // Then verify it server-side
      const response = await fetch('/api/verify-turnstile', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ token }),
      });

      const result = await response.json();

      setTestResults(prev => ({
        ...prev,
        serverVerify: {
          success: result.success,
          message: result.success 
            ? 'Server verification successful!' 
            : `Server verification failed: ${result.error}`
        }
      }));
    } catch (error) {
      setTestResults(prev => ({
        ...prev,
        serverVerify: {
          success: false,
          message: error instanceof Error ? error.message : 'Unknown error'
        }
      }));
    } finally {
      setIsLoading(null);
    }
  };

  const refreshPage = () => {
    window.location.reload();
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 to-black text-white p-8">
      <div className="max-w-4xl mx-auto">
        <Link href="/" className="inline-flex items-center gap-2 text-gray-400 hover:text-white mb-8">
          <ArrowLeft size={20} />
          Back to Game
        </Link>

        <h1 className="text-heading mb-2">Turnstile Captcha Test Page</h1>
        <p className="text-body text-gray-400 mb-8">
          Test different Turnstile captcha modes to debug mobile issues
        </p>

        {/* Turnstile Status */}
        <div className="card mb-8">
          <h2 className="text-subheading mb-4 flex items-center gap-2">
            <Shield className="w-5 h-5" />
            Turnstile Status
          </h2>
          <div className="flex items-center gap-3">
            {turnstileLoaded ? (
              <>
                <CheckCircle className="w-5 h-5 text-green-500" />
                <span className="text-green-500">Turnstile loaded and ready</span>
              </>
            ) : (
              <>
                <div className="w-5 h-5 rounded-full border-2 border-gray-600 border-t-white animate-spin" />
                <span className="text-gray-400">Loading Turnstile...</span>
              </>
            )}
          </div>
          <div className="mt-4 text-caption text-gray-500">
            Site Key: {process.env.NEXT_PUBLIC_TURNSTILE_SITE_KEY ? 'Configured ‚úì' : 'Not configured ‚úó'}
          </div>
        </div>

        {/* Test Sections */}
        <div className="space-y-6">
          {/* Automated Flow Test (for anonymous user creation) */}
          <div className="card">
            <h3 className="text-subheading mb-2">Automated Flow (Anonymous User)</h3>
            <p className="text-caption text-gray-400 mb-4">
              Tests the automated captcha flow used for anonymous user creation.
              Widget appears in bottom-right corner if interaction is needed.
            </p>
            <button
              onClick={testAutomatedFlow}
              disabled={!turnstileLoaded || isLoading === 'automated'}
              className="btn btn-primary"
            >
              {isLoading === 'automated' ? 'Testing...' : 'Test Automated Flow'}
            </button>
            {testResults.automated && (
              <div className={`mt-4 p-3 rounded-lg ${testResults.automated.success ? 'bg-green-900/50' : 'bg-red-900/50'}`}>
                <div className="flex items-center gap-2">
                  {testResults.automated.success ? (
                    <CheckCircle className="w-5 h-5 text-green-400" />
                  ) : (
                    <XCircle className="w-5 h-5 text-red-400" />
                  )}
                  <span className={testResults.automated.success ? 'text-green-400' : 'text-red-400'}>
                    {testResults.automated.message}
                  </span>
                </div>
                {testResults.automated.token && (
                  <div className="text-caption text-gray-400 mt-1">
                    Token: {testResults.automated.token}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Explicit + Execute Test (for forms) */}
          <div className="card">
            <h3 className="text-subheading mb-2">Explicit + Execute Pattern (Forms)</h3>
            <p className="text-caption text-gray-400 mb-4">
              Tests the recommended pattern for forms. Widget is rendered here, 
              executed on button click. If interaction is needed, it appears inline.
            </p>
            <div ref={explicitWidgetRef} className="mb-4"></div>
            <button
              onClick={testExplicitExecute}
              disabled={!turnstileLoaded || isLoading === 'explicitExecute'}
              className="btn btn-primary"
            >
              {isLoading === 'explicitExecute' ? 'Executing...' : 'Execute Captcha'}
            </button>
            {testResults.explicitExecute && (
              <div className={`mt-4 p-3 rounded-lg ${testResults.explicitExecute.success ? 'bg-green-900/50' : 'bg-red-900/50'}`}>
                <div className="flex items-center gap-2">
                  {testResults.explicitExecute.success ? (
                    <CheckCircle className="w-5 h-5 text-green-400" />
                  ) : (
                    <XCircle className="w-5 h-5 text-red-400" />
                  )}
                  <span className={testResults.explicitExecute.success ? 'text-green-400' : 'text-red-400'}>
                    {testResults.explicitExecute.message}
                  </span>
                </div>
                {testResults.explicitExecute.token && (
                  <div className="text-caption text-gray-400 mt-1">
                    Token: {testResults.explicitExecute.token}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Server Verification Test */}
          <div className="card">
            <h3 className="text-subheading mb-2">Server-Side Verification</h3>
            <p className="text-caption text-gray-400 mb-4">
              Tests getting a token and verifying it server-side
            </p>
            <button
              onClick={testServerVerification}
              disabled={!turnstileLoaded || isLoading === 'server'}
              className="btn btn-primary"
            >
              {isLoading === 'server' ? 'Verifying...' : 'Test Server Verification'}
            </button>
            {testResults.serverVerify && (
              <div className={`mt-4 p-3 rounded-lg ${testResults.serverVerify.success ? 'bg-green-900/50' : 'bg-red-900/50'}`}>
                <div className="flex items-center gap-2">
                  {testResults.serverVerify.success ? (
                    <CheckCircle className="w-5 h-5 text-green-400" />
                  ) : (
                    <XCircle className="w-5 h-5 text-red-400" />
                  )}
                  <span className={testResults.serverVerify.success ? 'text-green-400' : 'text-red-400'}>
                    {testResults.serverVerify.message}
                  </span>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Refresh Button */}
        <div className="mt-8 text-center">
          <button
            onClick={refreshPage}
            className="btn btn-secondary inline-flex items-center gap-2"
          >
            <RefreshCw size={16} />
            Refresh Page
          </button>
        </div>

        {/* Debug Info */}
        <div className="mt-12 card bg-gray-900/50">
          <h3 className="text-subheading mb-4">Debug Information</h3>
          <div className="space-y-2 text-caption font-mono">
            <div>User Agent: {typeof window !== 'undefined' ? window.navigator.userAgent : 'N/A'}</div>
            <div>Screen: {typeof window !== 'undefined' ? `${window.screen.width}x${window.screen.height}` : 'N/A'}</div>
            <div>Viewport: {typeof window !== 'undefined' ? `${window.innerWidth}x${window.innerHeight}` : 'N/A'}</div>
          </div>
        </div>
      </div>
    </div>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\test-captcha\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\app\test-openmoji\page.tsx ===== 
'use client';

import React, { useState } from 'react';
import { resolveEmoji } from '@/lib/openmoji-service';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';

interface TestResult {
  original: {
    unicodeEmoji: string;
    name: string;
    tags: string[];
  };
  resolved: {
    hexcode: string;
    svgPath: string;
    isExtra: boolean;
  };
  debugInfo?: {
    cacheKey: string;
    searchQuery: string;
    timestamp: string;
  };
}

export default function TestOpenMojiPage() {
  const [unicodeEmoji, setUnicodeEmoji] = useState('‚òï');
  const [name, setName] = useState('Coffee Grinder');
  const [tagsText, setTagsText] = useState('coffee, grinder, mill, bean, machine');
  const [result, setResult] = useState<TestResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    
    // Parse tags from comma-separated text
    const tags = tagsText
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);
    
    try {
      console.log('[OpenMoji Debug] Testing with inputs:', { unicodeEmoji, name, tags });
      
      const resolved = resolveEmoji({
        unicodeEmoji,
        name,
        tags
      });
      
      setResult({
        original: { unicodeEmoji, name, tags },
        resolved,
        debugInfo: {
          cacheKey: `${name}|${tags.join(',')}`,
          searchQuery: `${name} ${tags.join(' ')}`.trim(),
          timestamp: new Date().toISOString()
        }
      });
      
    } catch (error) {
      console.error('Error resolving emoji:', error);
      alert('Error resolving emoji - check console for details');
    } finally {
      setIsLoading(false);
    }
  };

  const presetTests = [
    {
      emoji: '‚òï',
      name: 'Coffee Grinder',
      tags: 'coffee, grinder, mill, bean, machine'
    },
    {
      emoji: 'ü¶†',
      name: 'Microbe',
      tags: 'bacteria, microbe, germ, cell, microscopic, organism'
    },
    {
      emoji: 'üóø',
      name: 'Golem',
      tags: 'stone, rock, statue, ancient, magical, creature'
    },
    {
      emoji: 'üçï',
      name: 'Pizza',
      tags: 'pizza, food, cheese, tomato, slice, italian'
    },
    {
      emoji: 'üêâ',
      name: 'Dragon',
      tags: 'dragon, fire, wings, scales, beast, fantasy'
    }
  ];

  const loadPreset = (preset: typeof presetTests[0]) => {
    setUnicodeEmoji(preset.emoji);
    setName(preset.name);
    setTagsText(preset.tags);
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-8">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-8 text-center">
          OpenMoji Resolver Debug Tool
        </h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          {/* Input Section */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Test Inputs</h2>
            
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-2">
                  Unicode Emoji:
                </label>
                <input
                  type="text"
                  value={unicodeEmoji}
                  onChange={(e) => setUnicodeEmoji(e.target.value)}
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white"
                  placeholder="‚òï"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-2">
                  Element Name:
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white"
                  placeholder="Coffee Grinder"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-2">
                  Emoji Tags (comma-separated):
                </label>
                <textarea
                  value={tagsText}
                  onChange={(e) => setTagsText(e.target.value)}
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white h-20 resize-none"
                  placeholder="coffee, grinder, mill, bean, machine"
                />
              </div>
              
              <button
                type="submit"
                disabled={isLoading}
                className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 px-4 py-2 rounded font-medium transition-colors"
              >
                {isLoading ? 'Resolving...' : 'Test OpenMoji Resolution'}
              </button>
            </form>
            
            {/* Preset Tests */}
            <div className="mt-6">
              <h3 className="text-lg font-medium mb-3">Quick Tests:</h3>
              <div className="space-y-2">
                {presetTests.map((preset, index) => (
                  <button
                    key={index}
                    onClick={() => loadPreset(preset)}
                    className="w-full text-left bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded transition-colors"
                  >
                    <span className="text-2xl mr-3">{preset.emoji}</span>
                    <span className="font-medium">{preset.name}</span>
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* Results Section */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Results</h2>
            
            {!result ? (
              <div className="text-gray-400 text-center py-8">
                Submit a test to see results
              </div>
            ) : (
              <div className="space-y-6">
                {/* Comparison */}
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-gray-700 rounded-lg p-4 text-center">
                    <h3 className="font-medium mb-3">Original Unicode</h3>
                    <div className="text-6xl mb-2">{result.original.unicodeEmoji}</div>
                    <div className="text-sm text-gray-300">
                      Unicode: {result.original.unicodeEmoji}
                    </div>
                  </div>
                  
                  <div className="bg-gray-700 rounded-lg p-4 text-center">
                    <h3 className="font-medium mb-3">Resolved OpenMoji</h3>
                    <div className="flex justify-center mb-2">
                      <OpenMojiDisplay 
                        emoji={result.original.unicodeEmoji}
                        hexcode={result.resolved.isExtra ? result.resolved.hexcode : undefined}
                        name={result.original.name}
                        size="lg"
                        className="w-16 h-16"
                      />
                    </div>
                    <div className="text-sm text-gray-300">
                      Hexcode: {result.resolved.hexcode}
                    </div>
                  </div>
                </div>
                
                {/* Debug Information */}
                <div className="bg-gray-700 rounded-lg p-4">
                  <h3 className="font-medium mb-3">Debug Information</h3>
                  <div className="space-y-2 text-sm">
                    <div>
                      <span className="text-gray-400">Element Name:</span> 
                      <span className="ml-2">{result.original.name}</span>
                    </div>
                    <div>
                      <span className="text-gray-400">Emoji Tags:</span> 
                      <span className="ml-2">[{result.original.tags.join(', ')}]</span>
                    </div>
                    <div>
                      <span className="text-gray-400">SVG Path:</span> 
                      <span className="ml-2 font-mono">{result.resolved.svgPath}</span>
                    </div>
                    <div>
                      <span className="text-gray-400">Is PUA (Extra):</span> 
                      <span className={`ml-2 font-medium ${result.resolved.isExtra ? 'text-purple-400' : 'text-green-400'}`}>
                        {result.resolved.isExtra ? 'Yes (Private Use Area)' : 'No (Standard Unicode)'}
                      </span>
                    </div>
                    <div>
                      <span className="text-gray-400">Search Query:</span> 
                      <span className="ml-2 font-mono">&quot;{result.debugInfo?.searchQuery}&quot;</span>
                    </div>
                    <div>
                      <span className="text-gray-400">Cache Key:</span> 
                      <span className="ml-2 font-mono text-xs">{result.debugInfo?.cacheKey}</span>
                    </div>
                  </div>
                </div>
                
                {/* Console Note */}
                <div className="bg-blue-900/30 border border-blue-600/30 rounded-lg p-3">
                  <div className="text-sm text-blue-200">
                    üí° Check the browser console for detailed debug logs showing the resolution decision process.
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
        
        {/* Back to Game */}
        <div className="text-center mt-8">
          <a
            href="/game"
            className="inline-block bg-gray-700 hover:bg-gray-600 px-6 py-3 rounded-lg transition-colors"
          >
            ‚Üê Back to Game
          </a>
        </div>
      </div>
    </div>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\app\test-openmoji\page.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\auth\AuthModal.tsx ===== 
'use client';

import React, { useState, useEffect } from 'react';
import { X, Mail, Lock, User, Eye, EyeOff } from 'lucide-react';
import { createClient } from '@/lib/supabase/browser';
import { getTurnstileToken } from '@/lib/turnstile';
import { getStaticOpenMoji } from '@/lib/openmoji-service';

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess?: () => void;
  initialMode?: 'login' | 'register';
  showUpgradeBenefits?: boolean;
}

export default function AuthModal({ 
  isOpen, 
  onClose, 
  onSuccess, 
  initialMode = 'login',
  showUpgradeBenefits = false 
}: AuthModalProps) {
  const [mode, setMode] = useState<'login' | 'register' | 'forgot'>(initialMode);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [displayName, setDisplayName] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [awaitingCaptcha, setAwaitingCaptcha] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const supabase = createClient();

  // Pre-warm Turnstile widget when modal opens
  useEffect(() => {
    if (isOpen) {
      import('@/lib/turnstile').then(m => m.waitForTurnstile());
    }
  }, [isOpen]);

  // Helper function to retry Supabase auth calls on rate limit
  const trySupabase = async <T extends { error: { message?: string } | null }>(
    fn: () => Promise<T>
  ): Promise<T> => {
    const res = await fn();
    
    // Check if it's an auth response with rate limit error
    if (res.error && res.error.message?.includes('8 seconds')) {
      setError('Security cooldown - retrying in 8 seconds...');
      await new Promise(resolve => setTimeout(resolve, 8500));
      setError(''); // Clear the cooldown message
      return await fn(); // Single retry
    }
    
    return res;
  };

  const handleEmailAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setAwaitingCaptcha(true);
    setError('');
    setSuccess('');

    try {
      // Get Turnstile token first (will wait as long as needed)
      const captchaToken = await getTurnstileToken()
        .finally(() => setAwaitingCaptcha(false));

      if (mode === 'register') {
        const { error } = await trySupabase(() => 
          supabase.auth.signUp({
            email,
            password,
            options: {
              data: {
                display_name: displayName || email.split('@')[0],
              },
              ...(captchaToken && { captchaToken })
            }
          })
        );

        if (error) throw error;

        setSuccess('Please check your email for verification link!');
        setMode('login');
      } else if (mode === 'login') {
        const { error } = await trySupabase(() =>
          supabase.auth.signInWithPassword({
            email,
            password,
            ...(captchaToken && { options: { captchaToken } })
          })
        );

        if (error) throw error;

        setSuccess('Logged in successfully!');
        onSuccess?.();
        onClose();
      } else if (mode === 'forgot') {
        const { error } = await trySupabase(() =>
          supabase.auth.resetPasswordForEmail(email, {
            redirectTo: `${window.location.origin}/auth/reset-password`,
            ...(captchaToken && { captchaToken })
          })
        );

        if (error) throw error;

        setSuccess('Password reset email sent!');
        setMode('login');
      }
    } catch (error) {
      // Provide clearer error messages for common issues
      const errorMessage = error instanceof Error ? error.message : 'An error occurred';
      
      if (errorMessage.includes('captcha')) {
        setError('Security verification failed - please refresh and try again');
      } else if (errorMessage.includes('Invalid login credentials')) {
        setError('Invalid email or password');
      } else {
        setError(errorMessage);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleAuth = async () => {
    setIsLoading(true);
    setError('');

    try {
      // OAuth providers handle their own security, no captcha needed
      const { error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/auth/callback`
        }
      });

      if (error) throw error;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Google authentication failed';
      setError(errorMessage);
      setIsLoading(false);
    }
  };

  const handleMagicLink = async () => {
    if (!email) {
      setError('Please enter your email address');
      return;
    }

    setIsLoading(true);
    setAwaitingCaptcha(true);
    setError('');

    try {
      // Get Turnstile token first (will wait as long as needed)
      const captchaToken = await getTurnstileToken()
        .finally(() => setAwaitingCaptcha(false));

      const { error } = await supabase.auth.signInWithOtp({
        email,
        options: {
          emailRedirectTo: `${window.location.origin}/auth/callback`,
          ...(captchaToken && { captchaToken })
        }
      });

      if (error) throw error;

      setSuccess('Magic link sent to your email!');
      setMode('login');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send magic link';
      
      if (errorMessage.includes('captcha')) {
        setError('Security verification failed - please refresh and try again');
      } else {
        setError(errorMessage);
      }
    } finally {
      setIsLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-backdrop">
      <div className="modal-content max-w-md max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-heading">
            {mode === 'login' ? 'Sign In' : mode === 'register' ? 'Create Account' : 'Reset Password'}
          </h2>
          <button
            onClick={onClose}
            className="btn-ghost p-2 rounded-full"
          >
            <X size={20} />
          </button>
        </div>

        {/* Upgrade Benefits */}
        {showUpgradeBenefits && (
          <div className="mb-6 p-4 bg-gradient-to-r from-primary/20 to-secondary/20 rounded-lg border border-primary/30">
            <h3 className="text-subheading mb-2 flex items-center gap-2">
              <img src={getStaticOpenMoji('üöÄ')} alt="Rocket" className="w-5 h-5" />
              Upgrade Benefits
            </h3>
            <ul className="text-caption space-y-1">
              <li>‚Ä¢ Cross-device game sync</li>
              <li>‚Ä¢ Purchase tokens & subscriptions</li>
              <li>‚Ä¢ Enhanced undo functionality</li>
              <li>‚Ä¢ Priority customer support</li>
              <li>‚Ä¢ Progress never lost</li>
            </ul>
          </div>
        )}

        {/* Error/Success Messages */}
        {error && (
          <div className="mb-4 p-3 status-error rounded-lg">
            <p className="text-caption">{error}</p>
          </div>
        )}

        {success && (
          <div className="mb-4 p-3 status-online rounded-lg">
            <p className="text-caption">{success}</p>
          </div>
        )}

        {/* Google Auth Button */}
        <button
          onClick={handleGoogleAuth}
          disabled={isLoading}
          className="btn btn-surface w-full mb-4 bg-white hover:bg-gray-100 text-gray-800 flex items-center justify-center gap-2 disabled:opacity-50"
        >
          <svg className="w-5 h-5" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>

        <div className="flex items-center gap-4 mb-4">
          <div className="flex-1 h-px bg-gray-600"></div>
          <span className="text-gray-400 text-sm">or</span>
          <div className="flex-1 h-px bg-gray-600"></div>
        </div>

        {/* Email Form */}
        <form onSubmit={handleEmailAuth} className="space-y-4">
          <div>
            <label className="text-caption font-medium mb-2 block">
              Email Address
            </label>
            <div className="relative">
              <Mail className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                className="input pl-10"
                required
              />
            </div>
          </div>

          {mode === 'register' && (
            <div>
              <label className="text-caption font-medium mb-2 block">
                Display Name (Optional)
              </label>
              <div className="relative">
                <User className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                <input
                  type="text"
                  value={displayName}
                  onChange={(e) => setDisplayName(e.target.value)}
                  placeholder="How should we call you?"
                  className="input pl-10"
                />
              </div>
            </div>
          )}

          {mode !== 'forgot' && (
            <div>
              <label className="text-caption font-medium mb-2 block">
                Password
              </label>
              <div className="relative">
                <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                <input
                  type={showPassword ? 'text' : 'password'}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Enter your password"
                  className="input pl-10 pr-10"
                  required
                  minLength={6}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute right-3 top-3 text-gray-400 hover:text-gray-300"
                >
                  {showPassword ? <EyeOff size={16} /> : <Eye size={16} />}
                </button>
              </div>
            </div>
          )}

          {/* Turnstile container - widget will render here when needed */}
          <div id="turnstile-container"></div>

          <button
            type="submit"
            disabled={isLoading || awaitingCaptcha}
            className="btn btn-primary w-full"
          >
            {awaitingCaptcha ? 'Verifying security...' : 
             isLoading ? 'Loading...' : (
              mode === 'login' ? 'Sign In' : 
              mode === 'register' ? 'Create Account' : 
              'Send Reset Link'
            )}
          </button>
        </form>

        {/* Magic Link Option */}
        <div className="mt-4">
          <button
            onClick={handleMagicLink}
            disabled={isLoading || awaitingCaptcha}
            className="btn btn-ghost w-full text-primary hover:text-primary-hover"
          >
            Or send me a magic link (passwordless)
          </button>
        </div>

        {/* Mode Switching */}
        <div className="mt-6 text-center text-caption">
          {mode === 'login' ? (
            <>
              <span className="text-muted">Don&apos;t have an account? </span>
              <button
                onClick={() => setMode('register')}
                className="text-primary hover:text-primary-hover"
              >
                Create one
              </button>
              <span className="text-muted"> or </span>
              <button
                onClick={() => setMode('forgot')}
                className="text-primary hover:text-primary-hover"
              >
                Forgot password?
              </button>
            </>
          ) : mode === 'register' ? (
            <>
              <span className="text-muted">Already have an account? </span>
              <button
                onClick={() => setMode('login')}
                className="text-primary hover:text-primary-hover"
              >
                Sign in
              </button>
            </>
          ) : (
            <>
              <span className="text-muted">Remember your password? </span>
              <button
                onClick={() => setMode('login')}
                className="text-primary hover:text-primary-hover"
              >
                Sign in
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\components\auth\AuthModal.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\auth\AuthModalClient.tsx ===== 
'use client';

import AuthModal from './AuthModal';

export default AuthModal;
 
===== END: C:\ai\LLM-Alchemy\src\components\auth\AuthModalClient.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\auth\SupabaseProvider.tsx ===== 
'use client'

import { createContext, useContext, useEffect, useState, useMemo, useCallback } from 'react'
import { createClient, getOrCreateAnonymousUser, getDailyCount, getTokenBalance } from '@/lib/supabase'
import { User as AuthUser } from '@supabase/supabase-js'
import { User as DBUser } from '@/types'
import { cleanupAutomatedWidget } from '@/lib/turnstile'

interface SupabaseContextType {
  user: AuthUser | null
  dbUser: DBUser | null
  dailyCount: number
  tokenBalance: number
  loading: boolean
  signInAnonymously: () => Promise<void>
  signOut: () => Promise<void>
  refreshDailyCount: () => Promise<void>
  refreshTokenBalance: () => Promise<void>
}

const SupabaseContext = createContext<SupabaseContextType | undefined>(undefined)

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null)
  const [dbUser, setDbUser] = useState<DBUser | null>(null)
  const [dailyCount, setDailyCount] = useState<number>(0)
  const [tokenBalance, setTokenBalance] = useState<number>(0)
  const [loading, setLoading] = useState(true)
  
  // Memoize supabase client to prevent recreation on every render
  const supabase = useMemo(() => createClient(), [])

  const refreshDailyCount = useCallback(async () => {
    if (user) {
      try {
        const count = await getDailyCount(supabase, user.id)
        setDailyCount(count)
      } catch (error) {
        console.error('Error refreshing daily count:', error)
      }
    }
  }, [user, supabase])

  const refreshTokenBalance = useCallback(async () => {
    if (user) {
      try {
        const balance = await getTokenBalance(supabase, user.id)
        setTokenBalance(balance)
      } catch (error) {
        console.error('Error refreshing token balance:', error)
      }
    }
  }, [user, supabase])

  const signInAnonymously = useCallback(async () => {
    try {
      setLoading(true)
      console.log('üîÑ Attempting to create anonymous user...')
      
      const dbUser = await getOrCreateAnonymousUser(supabase)
      if (dbUser) {
        console.log('‚úÖ Anonymous user created successfully')
        setDbUser(dbUser)
        
        // Get the session to get the user ID for daily count
        const { data: { session } } = await supabase.auth.getSession()
        if (session?.user) {
          const count = await getDailyCount(supabase, session.user.id)
          setDailyCount(count)
        }
      } else {
        console.log('‚ö†Ô∏è Failed to create anonymous user - user may need to try again')
        // Don't throw error, just let user retry manually
      }
    } catch (error) {
      console.error('‚ùå Error signing in anonymously:', error)
      // Don't retry automatically to prevent loops
    } finally {
      setLoading(false)
    }
  }, [supabase])

  const signOut = useCallback(async () => {
    try {
      await supabase.auth.signOut()
      setUser(null)
      setDbUser(null)
      setDailyCount(0)
      setTokenBalance(0)
    } catch (error) {
      console.error('Error signing out:', error)
    }
  }, [supabase])

  useEffect(() => {
    let mounted = true
    let isInitializing = false
    
    const initializeAuth = async () => {
      if (isInitializing) return
      isInitializing = true
      
      try {
        // Get current session (don't create new anonymous user automatically)
        const { data: { session } } = await supabase.auth.getSession()
        
        if (!mounted) return
        
        if (session?.user) {
          // User already exists - load their data in parallel
          setUser(session.user)
          
          // Parallelize database operations for faster loading
          const [dbUserResult, dailyCountResult, tokenBalanceResult] = await Promise.allSettled([
            supabase.from('users').select('*').eq('id', session.user.id).single(),
            getDailyCount(supabase, session.user.id),
            getTokenBalance(supabase, session.user.id)
          ])
          
          if (mounted) {
            if (dbUserResult.status === 'fulfilled' && dbUserResult.value.data) {
              setDbUser(dbUserResult.value.data)
            }
            if (dailyCountResult.status === 'fulfilled') {
              setDailyCount(dailyCountResult.value)
            }
            if (tokenBalanceResult.status === 'fulfilled') {
              setTokenBalance(tokenBalanceResult.value)
            }
          }
        }
        // No else clause - don't create anonymous user automatically
      } catch (error) {
        console.error('Auth initialization error:', error)
      } finally {
        if (mounted) {
          setLoading(false)
          isInitializing = false
        }
      }
    }

    // Initialize auth
    initializeAuth()

    // Listen for auth state changes (but don't trigger during initialization)
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (!mounted || isInitializing) return
        
        // Keep 50ms delay only for deadlock prevention in auth state changes
        setTimeout(async () => {
          try {
            if (event === 'SIGNED_OUT') {
              setUser(null)
              setDbUser(null)
              setDailyCount(0)
              setTokenBalance(0)
            } else if (event === 'SIGNED_IN' && session?.user) {
              setUser(session.user)
              
              // Get or create DB user record for authenticated users
              let { data: dbUser } = await supabase
                .from('users')
                .select('*')
                .eq('id', session.user.id)
                .single()
              
              // If no user record exists, create one for authenticated users
              if (!dbUser && session.user.email) {
                const userRecord = {
                  id: session.user.id,
                  email: session.user.email,
                  display_name: session.user.user_metadata?.display_name || 
                               session.user.user_metadata?.full_name || 
                               session.user.email?.split('@')[0],
                  avatar_url: session.user.user_metadata?.avatar_url,
                  google_id: session.user.app_metadata?.provider === 'google' ? 
                            session.user.user_metadata?.sub : null,
                  is_anonymous: false,
                  email_verified: session.user.email_confirmed_at !== null,
                  subscription_status: 'free' as const,
                  updated_at: new Date().toISOString()
                }

                const { data: upsertedUser, error: upsertError } = await supabase
                  .from('users')
                  .upsert([userRecord], { onConflict: 'id' })
                  .select()
                  .single()

                if (!upsertError && upsertedUser) {
                  dbUser = upsertedUser
                  console.log('‚úÖ Created/updated user record for authenticated user:', session.user.id)
                } else {
                  console.error('Error creating/updating authenticated user record:', upsertError)
                }
              }
              
              if (mounted && dbUser) {
                setDbUser(dbUser)
                // Parallelize these database calls too
                const [dailyCountResult, tokenBalanceResult] = await Promise.allSettled([
                  getDailyCount(supabase, session.user.id),
                  getTokenBalance(supabase, session.user.id)
                ])
                
                if (mounted) {
                  if (dailyCountResult.status === 'fulfilled') {
                    setDailyCount(dailyCountResult.value)
                  }
                  if (tokenBalanceResult.status === 'fulfilled') {
                    setTokenBalance(tokenBalanceResult.value)
                  }
                }
              }
            }
          } catch (error) {
            console.error('Auth state change error:', error)
          } finally {
            if (mounted) setLoading(false)
          }
        }, 50)
      }
    )

    return () => {
      mounted = false
      subscription.unsubscribe()
      // Clean up Turnstile automated widget on unmount
      cleanupAutomatedWidget()
    }
  }, [supabase])

  const value = {
    user,
    dbUser,
    dailyCount,
    tokenBalance,
    loading,
    signInAnonymously,
    signOut,
    refreshDailyCount,
    refreshTokenBalance,
  }

  return (
    <SupabaseContext.Provider value={value}>
      {children}
    </SupabaseContext.Provider>
  )
}

export function useSupabase() {
  const context = useContext(SupabaseContext)
  if (context === undefined) {
    throw new Error('useSupabase must be used within a SupabaseProvider')
  }
  return context
}
 
===== END: C:\ai\LLM-Alchemy\src\components\auth\SupabaseProvider.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\ChallengeBar.tsx ===== 
'use client';

import { useEffect, useState } from 'react';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, getChallengePreference } from '@/lib/supabase';
import { getStaticOpenMoji } from '@/lib/openmoji-service';
import { Challenge, ChallengeBarProps } from '@/types';

export function ChallengeBar({ isAnonymous, currentGameMode }: ChallengeBarProps) {
  const { user } = useSupabase();
  const [challenges, setChallenges] = useState<Challenge[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hiddenChallenges, setHiddenChallenges] = useState<Set<string>>(new Set());
  const [showChallenges, setShowChallenges] = useState<boolean>(true);

  // Load hidden challenges from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('llm-alchemy-hidden-challenges');
    if (saved) {
      try {
        const hiddenIds = JSON.parse(saved);
        setHiddenChallenges(new Set(hiddenIds));
      } catch (error) {
        console.error('Error loading hidden challenges:', error);
      }
    }
  }, []);

  // Save hidden challenges to localStorage whenever it changes
  useEffect(() => {
    if (hiddenChallenges.size > 0) {
      localStorage.setItem('llm-alchemy-hidden-challenges', JSON.stringify([...hiddenChallenges]));
    }
  }, [hiddenChallenges]);

  // Load challenge preference for authenticated users
  useEffect(() => {
    const loadChallengePreference = async () => {
      if (user && !isAnonymous) {
        const supabase = createClient();
        const preference = await getChallengePreference(supabase, user.id);
        setShowChallenges(preference);
      }
    };

    loadChallengePreference();
  }, [user, isAnonymous]);

  useEffect(() => {
    fetchChallenges();
    // Refresh challenges every 10 minutes (for testing phase)
    const interval = setInterval(fetchChallenges, 600000); // 10 minutes
    return () => clearInterval(interval);
  }, []);

  // Auto-hide completed challenges after 3 seconds
  useEffect(() => {
    const completedIds = challenges
      .filter(c => c.isCompleted)
      .map(c => c.id);

    if (completedIds.length > 0) {
      const timer = setTimeout(() => {
        setHiddenChallenges(prev => {
          const newSet = new Set(prev);
          completedIds.forEach(id => newSet.add(id));
          return newSet;
        });
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [challenges]);

  const fetchChallenges = async () => {
    try {
      const response = await fetch('/api/challenges/current');
      
      // Handle 403 (anonymous users) gracefully - this is expected behavior
      if (response.status === 403) {
        setChallenges([]);
        setError(null);
        return;
      }
      
      if (!response.ok) throw new Error('Failed to fetch challenges');
      
      const data = await response.json();
      setChallenges(data.challenges || []);
      setError(null);
    } catch (err) {
      console.error('Error fetching challenges:', err);
      setError('Failed to load challenges');
    } finally {
      setLoading(false);
    }
  };

  const hideChallenge = (challengeId: string) => {
    setHiddenChallenges(prev => new Set([...prev, challengeId]));
  };

  // Don't show anything for anonymous users - challenges are for registered users only
  if (isAnonymous) {
    return null;
  }

  // Don't show challenges if user has disabled them
  if (!showChallenges) return null;

  if (loading) return null;
  if (error) return null;
  if (challenges.length === 0) return null;

  // Filter challenges by game mode and hidden status
  const filterChallengesByMode = (challenge: Challenge) => {
    if (hiddenChallenges.has(challenge.id)) return false;
    
    // If no currentGameMode provided, show all challenges (main menu case)
    if (!currentGameMode) return true;
    
    // Show "any" mode challenges or challenges matching current game mode
    return challenge.game_mode === 'any' || challenge.game_mode === currentGameMode;
  };

  const dailyChallenges = challenges.filter(c => c.challenge_type === 'daily' && filterChallengesByMode(c));
  const weeklyChallenges = challenges.filter(c => c.challenge_type === 'weekly' && filterChallengesByMode(c));

  return (
    <div className="challenge-bar-container mb-4 relative z-50">
      <div className="flex flex-wrap gap-3">
        {/* Daily Challenges */}
        {dailyChallenges.map((challenge) => (
          <div
            key={challenge.id}
            className="challenge-item transition-all duration-300 flex-1 min-w-0 max-w-md"
          >
            <div className="flex items-center justify-between p-3 rounded-lg bg-surface-secondary border border-primary/20">
              <div className="flex items-center gap-3 flex-1">
                <img src={getStaticOpenMoji('üåü')} alt="Star" className="w-8 h-8" />
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-muted uppercase tracking-wider">Daily Quest</span>
                    {challenge.game_mode && (
                      <span className={`text-xs px-2 py-0.5 rounded ${
                        challenge.game_mode === 'science' ? 'bg-blue-500/20 text-blue-300' :
                        challenge.game_mode === 'creative' ? 'bg-purple-500/20 text-purple-300' :
                        'bg-gray-500/20 text-gray-300'
                      }`}>
                        {challenge.game_mode === 'science' ? <><img src={getStaticOpenMoji('üî¨')} alt="Science" className="inline w-3 h-3" /> Science</> :
                         challenge.game_mode === 'creative' ? <><img src={getStaticOpenMoji('üé®')} alt="Creative" className="inline w-3 h-3" /> Creative</> :
                         <><img src={getStaticOpenMoji('üåü')} alt="Star" className="inline w-3 h-3" /> Any Mode</>}
                      </span>
                    )}
                    {challenge.isCompleted && (
                      <span className="text-xs text-success">‚úì Completed</span>
                    )}
                  </div>
                  <p className="text-body font-medium">{challenge.title}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className="text-right">
                  <div className="flex items-center gap-1">
                    <span className="text-sm text-warning">+{challenge.reward_tokens}</span>
                    <span className="text-xs text-muted">tokens</span>
                  </div>
                  {challenge.isCompleted && challenge.completionDetails && (
                    <p className="text-xs text-muted mt-1">
                      Found: {challenge.completionDetails.element_discovered}
                    </p>
                  )}
                </div>
                <button
                  onClick={() => hideChallenge(challenge.id)}
                  className="text-gray-400 hover:text-gray-300 transition-colors p-1"
                  title="Hide challenge"
                >
                  ‚úï
                </button>
              </div>
            </div>
          </div>
        ))}

        {/* Weekly Challenge */}
        {weeklyChallenges.map((challenge) => (
          <div
            key={challenge.id}
            className="challenge-item transition-all duration-300"
          >
            <div className="flex items-center justify-between p-3 rounded-lg bg-surface-secondary border border-warning/30">
              <div className="flex items-center gap-3 flex-1">
                <img src={getStaticOpenMoji('üèÜ')} alt="Trophy" className="w-8 h-8" />
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-muted uppercase tracking-wider">Weekly Challenge</span>
                    {challenge.game_mode && (
                      <span className={`text-xs px-2 py-0.5 rounded ${
                        challenge.game_mode === 'science' ? 'bg-blue-500/20 text-blue-300' :
                        challenge.game_mode === 'creative' ? 'bg-purple-500/20 text-purple-300' :
                        'bg-gray-500/20 text-gray-300'
                      }`}>
                        {challenge.game_mode === 'science' ? <><img src={getStaticOpenMoji('üî¨')} alt="Science" className="inline w-3 h-3" /> Science</> :
                         challenge.game_mode === 'creative' ? <><img src={getStaticOpenMoji('üé®')} alt="Creative" className="inline w-3 h-3" /> Creative</> :
                         <><img src={getStaticOpenMoji('üåü')} alt="Star" className="inline w-3 h-3" /> Any Mode</>}
                      </span>
                    )}
                    {challenge.isCompleted && (
                      <span className="text-xs text-success">‚úì Completed</span>
                    )}
                  </div>
                  <p className="text-body font-medium">{challenge.title}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className="text-right">
                  <div className="flex items-center gap-1">
                    <span className="text-sm text-warning">+{challenge.reward_tokens}</span>
                    <span className="text-xs text-muted">tokens</span>
                  </div>
                  {challenge.isCompleted && challenge.completionDetails && (
                    <p className="text-xs text-muted mt-1">
                      Mode: {challenge.completionDetails.game_mode}
                    </p>
                  )}
                </div>
                <button
                  onClick={() => hideChallenge(challenge.id)}
                  className="text-gray-400 hover:text-gray-300 transition-colors p-1"
                  title="Hide challenge"
                >
                  ‚úï
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\ChallengeBar.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\OpenMojiDisplay.tsx ===== 
import React, { memo, useState } from 'react';
import { unicodeToHexSequence } from '@/lib/openmoji-service';

interface OpenMojiDisplayProps {
  emoji: string;           // Unicode emoji
  hexcode?: string;        // Pre-resolved hexcode (for PUA emojis)
  name: string;           // Alt text
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

/**
 * Displays an OpenMoji SVG
 * Memoized to prevent unnecessary re-renders
 * UPDATED: Uses React state for fallback instead of insertAdjacentHTML
 */
export const OpenMojiDisplay = memo<OpenMojiDisplayProps>(({ 
  emoji, 
  hexcode,
  name,
  size = 'md',
  className = '' 
}) => {
  const [fallbackToUnicode, setFallbackToUnicode] = useState(false);
  
  const sizeClasses = {
    sm: 'w-6 h-6',     // 24px - for UI elements
    md: 'w-8 h-8',     // 32px - default game size
    lg: 'w-12 h-12'    // 48px - for showcases
  };
  
  // Use provided hexcode or convert from Unicode
  const finalHexcode = hexcode || unicodeToHexSequence(emoji);
  
  // If fallback is triggered, render Unicode emoji
  if (fallbackToUnicode) {
    return (
      <span className={`${sizeClasses[size]} flex items-center justify-center text-2xl ${className}`}>
        {emoji}
      </span>
    );
  }
  
  return (
    <img 
      src={`/openmoji/${finalHexcode}.svg`}
      alt={name}
      className={`${sizeClasses[size]} ${className} select-none`}
      loading="lazy"
      draggable={false}
      onError={() => {
        console.warn(`Failed to load OpenMoji SVG: ${finalHexcode}`);
        setFallbackToUnicode(true);
      }}
    />
  );
});

OpenMojiDisplay.displayName = 'OpenMojiDisplay';
 
===== END: C:\ai\LLM-Alchemy\src\components\game\OpenMojiDisplay.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyRefactored.tsx ===== 
'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Sparkles, GripHorizontal, User, ArrowLeft } from 'lucide-react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, saveGameState, loadGameState, addTokens, getLlmModelPreference } from '@/lib/supabase';
import { Achievement } from '@/types';
import { GAME_CONFIG } from '@/lib/game-config';
import { ChallengeBar } from '@/components/game/ChallengeBar';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { isTouchDevice } from '@/lib/ui-utils';

// Import our new state management
import { useGameMode, useElements, useMixingArea, useCombinations, useAchievements, useGameUndo, useGameStats, useGamePersistence, useElementInteractionState } from './contexts/GameStateProvider';
import { Element } from '@/types/game.types';
import { MixingElement } from './hooks/useGameState';
import { useElementMixing } from './hooks/useElementMixing';
import { useGameAudio } from './hooks/useGameAudio';
import { useGameAnimations } from './hooks/useGameAnimations';
import { UnlockModal, AchievementsModal, ReasoningPopup, ElementListView } from './components';
import * as GameLogic from '@/lib/game-logic';

// UI-only interfaces (not moved to state management)
interface FloatingEmoji {
  id: number;
  emoji: string;
  x: number;
  y: number;
  directionX: number;
  directionY: number;
  speed: number;
  opacity: number;
  maxOpacity: number;
  lifespan: number;
  age: number;
}

interface ReasoningPopup {
  element: Element;
  x: number;
  y: number;
  fromHover: boolean;
}

interface ShowUnlockElement extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

// Type for window.webkitAudioContext
interface WindowWithWebkit extends Window {
  webkitAudioContext?: typeof AudioContext;
}

const LLMAlchemyRefactored = () => {
  const { user, dbUser, dailyCount, tokenBalance, refreshTokenBalance } = useSupabase();
  const router = useRouter();
  const searchParams = useSearchParams();
  
  // Get state and actions from context
  const { gameMode, setGameMode } = useGameMode();
  const { elements, endElements, setElements, setEndElements } = useElements();
  const { mixingArea, setMixingArea, addToMixingArea, updateMixingElement } = useMixingArea();
  const { combinations, failedCombinations, setCombinations, setFailedCombinations } = useCombinations();
  const { achievements } = useAchievements();
  const { lastCombination, undoAvailable, setLastCombination, setUndoAvailable } = useGameUndo();
  const { isStateRestored, setStateRestored } = useGameStats();
  const { loadSavedState, resetGameState } = useGamePersistence();
  
  // Initialize our custom hooks
  const { playSound } = useGameAudio();
  const { 
    shakeElement, 
    popElement, 
    isPlayingLoadAnimation, 
    animatedElements,
    triggerShake,
    triggerPop,
    animateRemoval,
    playElementLoadAnimation,
    isElementRemoving
  } = useGameAnimations();

  // UI-only state (ephemeral - doesn't need to be in global state)
  const [sortMode, setSortMode] = useState<string>('unlock');
  const [showUnlock, setShowUnlock] = useState<ShowUnlockElement | null>(null);
  const [showAchievements, setShowAchievements] = useState<boolean>(false);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [unlockAnimationStartTime, setUnlockAnimationStartTime] = useState<number | null>(null);
  // Use centralized UI interaction state
  const {
    hoveredElement,
    isMixing,
    isDragging,
    touchDragging,
    touchOffset,
    dimmedElements,
    isUndoing,
    setHoveredElement,
    setIsMixing,
    setIsDragging,
    setTouchDragging,
    setTouchOffset,
    setDimmedElements,
    clearDimmedElements,
    setIsUndoing,
  } = useElementInteractionState();
  const [listHeight, setListHeight] = useState<number>(192);
  const [isDraggingDivider, setIsDraggingDivider] = useState<boolean>(false);
  const [touchStartTime, setTouchStartTime] = useState<number | null>(null);
  const [touchStartPos, setTouchStartPos] = useState<{ x: number; y: number } | null>(null);
  const [toast, setToast] = useState<string>('');
  const [dragStartY, setDragStartY] = useState<number>(0);
  const [dragStartHeight, setDragStartHeight] = useState<number>(0);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [floatingEmojis, setFloatingEmojis] = useState<FloatingEmoji[]>([]);
  const [reasoningPopup, setReasoningPopup] = useState<ReasoningPopup | null>(null);
  const [userApiKey, setUserApiKey] = useState<string>('');
  const [selectedModel, setSelectedModel] = useState<'flash' | 'pro'>('flash');
  
  
  // Refs
  const draggedElement = useRef<MixingElement | null>(null);
  const dropZoneRef = useRef<HTMLDivElement | null>(null);
  const audioContext = useRef<AudioContext | null>(null);
  const floatingEmojiId = useRef<number>(0);
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Load API key from localStorage on mount
  useEffect(() => {
    const savedApiKey = localStorage.getItem('llm-alchemy-api-key');
    
    if (savedApiKey) {
      setUserApiKey(savedApiKey);
      const savedModel = localStorage.getItem('llm-alchemy-model') as 'flash' | 'pro';
      if (savedModel && (savedModel === 'flash' || savedModel === 'pro')) {
        setSelectedModel(savedModel);
      }
    }
  }, []);
  
  
  // Load model preference from Supabase for non-API-key users
  useEffect(() => {
    const loadModelPreference = async () => {
      if (user && !userApiKey) {
        const supabase = createClient();
        const modelPreference = await getLlmModelPreference(supabase, user.id);
        setSelectedModel(modelPreference);
      }
    };

    loadModelPreference();
  }, [user, userApiKey]);

  // Handle URL mode parameter and game state loading
  useEffect(() => {
    const mode = searchParams.get('mode');
    if (mode && (mode === 'science' || mode === 'creative')) {
      setGameMode(mode as 'science' | 'creative');
    }
  }, [searchParams, setGameMode]);

  // Load game state when user and game mode are available
  useEffect(() => {
    const loadSavedStateEffect = async () => {
      if (user && gameMode) {
        console.log(`[REFACTORED_GAME_STATE_DEBUG] üîÑ Loading saved state for user ${user.id} in ${gameMode} mode...`);
        setStateRestored(false);
        
        try {
          const supabase = createClient();
          const savedState = await loadGameState(supabase, user.id, gameMode);
          
          if (savedState) {
            console.log(`[REFACTORED_GAME_STATE_DEBUG] ‚úÖ Found saved state - loading into context`);
            
            // Load into context state
            loadSavedState({
              elements: savedState.elements || [],
              endElements: savedState.end_elements || [],
              combinations: savedState.combinations || {},
              achievements: savedState.achievements || [],
              failedCombinations: savedState.failed_combinations || [],
            });
            
            // Trigger load animation if needed
            if (savedState.elements && savedState.elements.length > 5) {
              playElementLoadAnimation(savedState.elements);
            }
          } else {
            console.log(`[REFACTORED_GAME_STATE_DEBUG] üì≠ No saved state found for ${gameMode} mode - starting fresh`);
          }
        } catch (error) {
          console.error('[REFACTORED_GAME_STATE_DEBUG] ‚ùå Error loading game state:', error);
        } finally {
          setStateRestored(true);
        }
      }
    };

    loadSavedStateEffect();
  }, [user, gameMode, loadSavedState, setStateRestored, playElementLoadAnimation]);

  // Auto-save game state when state changes
  useEffect(() => {
    if (!isStateRestored) return;

    const saveState = async () => {
      if (user && gameMode && (elements.length > 5 || endElements.length > 0 || Object.keys(combinations).length > 0)) {
        console.log(`[REFACTORED_GAME_STATE_DEBUG] üíæ Auto-saving state...`);
        
        try {
          const supabase = createClient();
          await saveGameState(supabase, user.id, {
            game_mode: gameMode,
            elements: elements,
            end_elements: endElements,
            combinations: combinations,
            achievements: achievements,
            failed_combinations: failedCombinations
          });
          console.log(`[REFACTORED_GAME_STATE_DEBUG] ‚úÖ Auto-save completed successfully`);
        } catch (error) {
          console.error('[REFACTORED_GAME_STATE_DEBUG] ‚ùå Auto-save failed:', error);
        }
      }
    };

    const timeoutId = setTimeout(saveState, 2000);
    return () => clearTimeout(timeoutId);
  }, [user, gameMode, elements, endElements, combinations, achievements, failedCombinations, isStateRestored]);

  // Initialize Web Audio API
  useEffect(() => {
    audioContext.current = new (window.AudioContext || (window as WindowWithWebkit).webkitAudioContext!)();
  }, []);

  // Helper functions using game logic
  const showToast = (message: string) => {
    setToast(message);
    setTimeout(() => setToast(''), 3000);
  };

  const showReasoningPopup = (element: Element, event: React.MouseEvent | React.TouchEvent) => {
    if (!element.reasoning) return;
    
    const rect = event.currentTarget.getBoundingClientRect();
    setReasoningPopup({
      element,
      x: rect.left + rect.width / 2,
      y: rect.top - 10,
      fromHover: event.type === 'mouseenter'
    });
  };

  // Initialize our custom hooks
  const { mixElements } = useElementMixing({
    userApiKey,
    selectedModel,
    onShowToast: showToast,
    onPlaySound: (type: string) => {
      // Map string types to our SoundType enum
      const soundMap: Record<string, Parameters<typeof playSound>[0]> = {
        'plop': 'plop',
        'pop': 'pop', 
        'reward': 'reward',
        'end-element': 'end-element',
        'press': 'press',
        'click': 'click',
        'reverse-pop': 'reverse-pop'
      };
      const soundType = soundMap[type] || 'pop';
      playSound(soundType);
    },
    onShowUnlock: (element: ShowUnlockElement | null) => setShowUnlock(element),
    onSetShakeElement: (elementId: string | null) => {
      if (elementId) triggerShake(elementId);
    },
    onSetPopElement: (elementId: string | null) => {
      if (elementId) triggerPop(elementId);
    },
    onSetUnlockAnimationStartTime: setUnlockAnimationStartTime,
    onSetIsMixing: setIsMixing,
    dropZoneRef
  });

  // Touch event handlers with performance throttling
  const handleTouchMove = useCallback((e: TouchEvent) => {
    if (!touchDragging) return;
    
    e.preventDefault();
    
    // Throttle position updates using requestAnimationFrame
    requestAnimationFrame(() => {
      if (!touchDragging) return; // Check again in case drag ended
      
      const touch = e.touches[0];
      const draggedEl = document.getElementById('touch-drag-element');
      if (draggedEl) {
        draggedEl.style.left = `${touch.clientX - touchOffset.x}px`;
        draggedEl.style.top = `${touch.clientY - touchOffset.y}px`;
      }
      
      // Check if hovering over a mixing area element
      const hoverTarget = document.elementFromPoint(touch.clientX, touch.clientY);
      if (hoverTarget) {
        const mixingEl = mixingArea.find(el => {
          const elNode = document.getElementById(`mixing-${el.id}-${el.index}`);
          return elNode && (elNode === hoverTarget || elNode.contains(hoverTarget));
        });
        
        if (mixingEl && mixingEl.index !== touchDragging.mixIndex) {
          setHoveredElement(mixingEl.index);
        } else {
          setHoveredElement(null);
        }
      }
    });
  }, [touchDragging, touchOffset, mixingArea]);


  const handleTouchEnd = useCallback(async (e: TouchEvent | React.TouchEvent<HTMLDivElement>) => {
    if (!touchDragging) return;
    
    const touch = e.changedTouches[0];
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - (touchStartTime || 0);
    
    // Calculate movement distance
    const moveDistance = touchStartPos ? Math.sqrt(
      Math.pow(touch.clientX - touchStartPos!.x, 2) + 
      Math.pow(touch.clientY - touchStartPos!.y, 2)
    ) : 0;
    
    // If it was a quick tap with minimal movement, show reasoning popup
    if (touchDuration < 300 && moveDistance < 10 && touchDragging.reasoning) {
      const syntheticEvent = {
        currentTarget: {
          getBoundingClientRect: () => ({
            left: touchStartPos!.x - 32,
            top: touchStartPos!.y - 32,
            width: 64,
            height: 64
          })
        }
      };
      
      setTouchDragging(null);
      setTouchOffset({ x: 0, y: 0 });
      setTouchStartTime(null);
      setTouchStartPos(null);
      setDimmedElements(new Set()); // Fix: Clear dimming for quick taps
      
      setTimeout(() => {
        showReasoningPopup(touchDragging, syntheticEvent as React.TouchEvent);
      }, 50);
      
      return;
    }
    
    // Handle as normal drag operation
    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (dropZoneRef.current && dropZoneRef.current.contains(dropTarget)) {
      const rect = dropZoneRef.current.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      // Check if dropped on another element
      const targetElement = mixingArea.find(el => {
        const elRect = document.getElementById(`mixing-${el.id}-${el.index}`)?.getBoundingClientRect();
        if (!elRect) return false;
        return touch.clientX >= elRect.left && touch.clientX <= elRect.right &&
               touch.clientY >= elRect.top && touch.clientY <= elRect.bottom;
      });
      
      if (targetElement && targetElement.index !== touchDragging.mixIndex) {
        // Mix the elements using our hook
        await mixElements(touchDragging, targetElement);
      } else if (!targetElement) {
        playSound('plop');
        if ('vibrate' in navigator) {
          navigator.vibrate(5);
        }
        const offset = GameLogic.getElementSize() / 2;
        if (touchDragging.fromMixingArea) {
          const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current, touchDragging.mixIndex);
          updateMixingElement(touchDragging.mixIndex!, { x: newPos.x, y: newPos.y });
        } else {
          const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current);
          const newElement = {
            ...touchDragging,
            x: newPos.x,
            y: newPos.y,
            index: Date.now(),
            energized: false
          };
          addToMixingArea(newElement);
        }
      }
    }
    
    setTouchDragging(null);
    setTouchOffset({ x: 0, y: 0 });
    setHoveredElement(null);
    setTouchStartTime(null);
    setTouchStartPos(null);
    setDimmedElements(new Set());
  }, [touchDragging, touchStartTime, touchStartPos, mixingArea, mixElements, playSound, updateMixingElement, addToMixingArea, showReasoningPopup]);

  const handleDividerTouchEnd = useCallback(() => {
    setIsDraggingDivider(false);
  }, []);

  const handleDividerTouchMove = useCallback((e: TouchEvent) => {
    if (!isDraggingDivider) return;
    
    const touch = e.touches[0];
    const newHeight = touch.clientY - 100;
    setListHeight(Math.max(100, Math.min(400, newHeight)));
  }, [isDraggingDivider]);

  // Mode switching logic - reset to base elements when switching modes
  useEffect(() => {
    const isCurrentlyCreative = gameMode === 'creative';
    const isCurrentlyScience = gameMode === 'science';
    
    // Only reset if we're actually switching modes (not on initial load with saved state)
    const isModeSwitching = (isCurrentlyCreative && elements.find(e => e.name === 'Energy')) ||
                           (isCurrentlyScience && elements.find(e => e.name === 'Life'));
    
    if (isModeSwitching) {
      resetGameState(gameMode);
      // Clear UI state
      setFloatingEmojis([]);
      setShowUnlock(null);
      setReasoningPopup(null);
      // Clear animations handled by useGameAnimations hook
    }
  }, [gameMode, elements, resetGameState]);

  // Global touch handlers and drag cleanup
  useEffect(() => {
    const handleGlobalTouchMove = (e: TouchEvent) => {
      handleTouchMove(e);
      handleDividerTouchMove(e);
    };
    
    const handleGlobalTouchEnd = (e: TouchEvent) => {
      handleTouchEnd(e);
      handleDividerTouchEnd();
    };
    
    // Global cleanup for cancelled drags
    const handleGlobalMouseUp = () => {
      if (isDragging) {
        // Clean up drag state if mouse is released anywhere
        draggedElement.current = null;
        setIsDragging(false);
        setHoveredElement(null);
        clearDimmedElements();
      }
    };
    
    const handleGlobalDragEnd = () => {
      // Ensure cleanup happens on any drag end
      draggedElement.current = null;
      setIsDragging(false);
      setHoveredElement(null);
      clearDimmedElements();
    };
    
    if (touchDragging || isDraggingDivider) {
      document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
      document.addEventListener('touchend', handleGlobalTouchEnd);
      
      return () => {
        document.removeEventListener('touchmove', handleGlobalTouchMove);
        document.removeEventListener('touchend', handleGlobalTouchEnd);
      };
    }
    
    if (isDragging) {
      document.addEventListener('mouseup', handleGlobalMouseUp);
      document.addEventListener('dragend', handleGlobalDragEnd);
      
      return () => {
        document.removeEventListener('mouseup', handleGlobalMouseUp);
        document.removeEventListener('dragend', handleGlobalDragEnd);
      };
    }
  }, [touchDragging, isDraggingDivider, isDragging, handleTouchMove, handleDividerTouchMove, handleTouchEnd, handleDividerTouchEnd]);

  // Cleanup effects
  useEffect(() => {
    const timeoutRef = hoverTimeoutRef.current;
    return () => {
      if (timeoutRef) {
        clearTimeout(timeoutRef);
      }
    };
  }, [elements, floatingEmojis.length]);


  // Handle reasoning popup dismissal
  useEffect(() => {
    if (isDraggingDivider) {
      const handleDividerDrag = (e: MouseEvent) => {
        const deltaY = e.clientY - dragStartY;
        const newHeight = dragStartHeight + deltaY;
        setListHeight(Math.max(100, Math.min(400, newHeight)));
      };

      const handleDividerMouseUp = () => {
        setIsDraggingDivider(false);
      };

      document.addEventListener('mousemove', handleDividerDrag);
      document.addEventListener('mouseup', handleDividerMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleDividerDrag);
        document.removeEventListener('mouseup', handleDividerMouseUp);
      };
    }
  }, [isDraggingDivider, dragStartY, dragStartHeight]);

  // Floating emoji management
  useEffect(() => {
    if (elements.length < 5) return;

    const createFloatingEmoji = () => {
      const randomElement = elements[Math.floor(Math.random() * elements.length)];
      return {
        id: floatingEmojiId.current++,
        emoji: randomElement.emoji,
        x: Math.random() * 100,
        y: Math.random() * 100,
        directionX: (Math.random() - 0.5) * 2,
        directionY: (Math.random() - 0.5) * 2,
        speed: 0.3 + Math.random() * 0.4,
        opacity: 0,
        maxOpacity: 0.005 + Math.random() * 0.005,
        lifespan: 8000 + Math.random() * 6000,
        age: 0
      };
    };

    if (floatingEmojis.length === 0) {
      const initialCount = 1 + Math.floor(Math.random() * 3);
      setFloatingEmojis(Array.from({ length: initialCount }, createFloatingEmoji));
    }

    const animationLoop = setInterval(() => {
      setFloatingEmojis(prevEmojis => {
        let newEmojis = prevEmojis.map(emoji => {
          const newAge = emoji.age + 100;
          const lifeProgress = newAge / emoji.lifespan;
          
          let newOpacity;
          if (lifeProgress < 0.2) {
            newOpacity = (lifeProgress / 0.2) * emoji.maxOpacity;
          } else if (lifeProgress < 0.8) {
            newOpacity = emoji.maxOpacity;
          } else {
            newOpacity = emoji.maxOpacity * ((1 - lifeProgress) / 0.2);
          }

          return {
            ...emoji,
            x: emoji.x + emoji.directionX * emoji.speed,
            y: emoji.y + emoji.directionY * emoji.speed,
            opacity: Math.max(0, newOpacity),
            age: newAge
          };
        });

        newEmojis = newEmojis.filter(emoji => emoji.age < emoji.lifespan);
        
        while (newEmojis.length < 1 || (newEmojis.length < 3 && Math.random() < 0.3)) {
          newEmojis.push(createFloatingEmoji());
        }

        return newEmojis;
      });
    }, 100);

    return () => clearInterval(animationLoop);
  }, [elements, floatingEmojis.length]);

  // Handle reasoning popup dismissal
  useEffect(() => {
    const handleGlobalClick = (e: MouseEvent) => {
      if (reasoningPopup && !reasoningPopup.fromHover) {
        const popup = document.querySelector('.reasoning-popup');
        if (!popup || !popup.contains(e.target as Node)) {
          hideReasoningPopup();
        }
      }
    };

    const handleEscapeKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && reasoningPopup) {
        hideReasoningPopup();
      }
    };

    if (reasoningPopup) {
      document.addEventListener('click', handleGlobalClick);
      document.addEventListener('keydown', handleEscapeKey);
      return () => {
        document.removeEventListener('click', handleGlobalClick);
        document.removeEventListener('keydown', handleEscapeKey);
      };
    }
  }, [reasoningPopup]);


  const hideReasoningPopup = () => {
    setReasoningPopup(null);
  };


  const handleElementClick = (element: Element, event: React.MouseEvent) => {
    if (element.reasoning) {
      event.preventDefault();
      event.stopPropagation();
      showReasoningPopup(element, event);
    }
  };

  const handleElementMouseEnter = (element: Element, event: React.MouseEvent) => {
    // Simply show the reasoning popup - no 500ms delay needed here since child handles it
    showReasoningPopup(element, event);
  };

  const handleElementMouseLeave = () => {
    // Hide popup if it was from hover
    if (reasoningPopup && reasoningPopup.fromHover) {
      hideReasoningPopup();
    }
  };

  const handleBackToHome = () => {
    router.push('/');
  };

  const handleGameModeToggle = () => {
    if (!isMixing) {
      const newMode = gameMode === 'science' ? 'creative' : 'science';
      playSound('click');
      
      setMixingArea([]);
      
      const url = new URL(window.location.href);
      url.searchParams.set('mode', newMode);
      window.history.replaceState({}, '', url);
      
      setGameMode(newMode);
    }
  };

  const handleClear = () => {
    playSound('click');
    animateRemoval(mixingArea, () => {
      setMixingArea([]);
    });
  };

  const sortedElements = GameLogic.sortElements(elements, sortMode as 'unlock' | 'alpha', searchTerm);

  const regularElementCount = elements.length;
  const endElementCount = endElements.length;

  // Touch handlers for dividers
  const handleDividerTouchStart = (e: React.TouchEvent) => {
    e.preventDefault();
    setIsDraggingDivider(true);
  };


  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col relative overflow-hidden select-none" style={{ touchAction: touchDragging || isDraggingDivider ? 'none' : 'auto' }}>
      <div className="absolute inset-0 bg-gradient-to-br from-purple-900/20 via-gray-900 to-blue-900/20"></div>
      
      {/* Floating Background Emojis */}
      {floatingEmojis.map(emoji => (
        <div
          key={emoji.id}
          className="absolute text-4xl pointer-events-none transition-opacity duration-200"
          style={{
            left: `${emoji.x}%`,
            top: `${emoji.y}%`,
            opacity: emoji.opacity,
            transform: 'translate(-50%, -50%)'
          }}
        >
          {emoji.emoji}
        </div>
      ))}
      
      {/* Header */}
      <div className="relative z-10 bg-gray-800/80 backdrop-blur-sm p-4 shadow-lg">
        <div className="flex justify-between items-start mb-3">
          <div className="flex items-center gap-3">
            <h1 className="text-2xl font-bold flex items-center gap-2">
              <Sparkles className="text-yellow-400 hidden sm:block" />
              LLM Alchemy
            </h1>
          </div>
          <div className="text-lg font-semibold flex flex-col items-end gap-1">
            <span>Elements: {regularElementCount}</span>
            {gameMode === 'science' && endElementCount > 0 && (
              <span className="text-gray-300 text-base">Ends: {endElementCount}</span>
            )}
          </div>
        </div>
        
        <div className="flex justify-between items-center mb-3">
          <button
            onClick={handleBackToHome}
            className="flex items-center gap-2 px-3 py-1 hover:bg-gray-700 rounded transition-colors text-gray-400 hover:text-white"
            title="Back to Menu"
          >
            <ArrowLeft size={16} />
            <span className="text-sm">Back</span>
          </button>
          
          <div className="text-sm text-gray-400 flex items-center gap-2">
            {/* Undo Button */}
            {undoAvailable && !isUndoing && (
              <button
                onClick={async () => {
                  if (lastCombination) {
                    setIsUndoing(true);
                    playSound('reverse-pop');
                    
                    // Remove the created element
                    if (lastCombination.createdElement.isEndElement) {
                      const newEndElements = endElements.filter(e => e.id !== lastCombination.createdElement.element.id);
                      setEndElements(newEndElements);
                    } else {
                      const newElements = elements.filter(e => e.id !== lastCombination.createdElement.element.id);
                      setElements(newElements);
                    }
                    
                    // Restore the mixing area
                    setMixingArea(lastCombination.mixingAreaState);
                    
                    // Remove from combinations
                    const newCombinations = { ...combinations };
                    delete newCombinations[lastCombination.combinationKey];
                    setCombinations(newCombinations);
                    
                    // Remove from failed combinations if it was there
                    const newFailedCombinations = failedCombinations.filter(key => key !== lastCombination.combinationKey);
                    setFailedCombinations(newFailedCombinations);
                    
                    // Clear undo state
                    setLastCombination(null);
                    setUndoAvailable(false);
                    
                    showToast('Undid last combination');
                    
                    setTimeout(() => {
                      setIsUndoing(false);
                    }, 300);
                  }
                }}
                className="px-2 py-1 bg-orange-600 hover:bg-orange-500 rounded text-white font-medium transition-colors text-xs"
                title="Undo last combination"
              >
                ‚Ü∂ Undo
              </button>
            )}
            
            {userApiKey ? (
              <span className="text-green-400">Using your API key</span>
            ) : tokenBalance > 0 ? (
              <span className="text-yellow-400">Tokens: {tokenBalance}</span>
            ) : dailyCount >= GAME_CONFIG.DAILY_FREE_COMBINATIONS ? (
              <button
                onClick={async () => {
                  if (user) {
                    const supabase = createClient();
                    await addTokens(supabase, user.id, 10);
                    await refreshTokenBalance();
                    showToast('+10 tokens added!');
                  }
                }}
                className="px-3 py-1 bg-purple-600 hover:bg-purple-500 rounded text-white font-medium transition-colors"
              >
                Get more
              </button>
            ) : (
              <>
                <User size={14} />
                <span>{dailyCount}/{GAME_CONFIG.DAILY_FREE_COMBINATIONS} today</span>
              </>
            )}
          </div>
        </div>
        
        <div className="flex justify-between items-center gap-3">
          <div className="flex gap-2 text-sm items-center">
            <input
              type="text"
              placeholder="Filter..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-20 sm:w-20 px-2 py-1 text-sm bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400 focus:outline-none focus:border-purple-500"
            />
            <button
              onClick={() => setShowAchievements(true)}
              className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition-all flex items-center gap-1"
            >
              <span>üèÜ</span>
              <span className="hidden sm:inline text-sm">Achievements</span>
            </button>
            <select
              value={sortMode}
              onChange={(e) => setSortMode(e.target.value)}
              className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm focus:outline-none focus:border-purple-500"
            >
              <option value="unlock">By Discovery</option>
              <option value="alpha">Alphabetical</option>
            </select>
          </div>
          
          {/* Game Mode Toggle */}
          <button
            onClick={handleGameModeToggle}
            disabled={isMixing}
            className={`relative inline-flex h-8 w-32 cursor-pointer items-center rounded-full bg-gray-700 transition-colors hover:bg-gray-600 ${
              isMixing ? 'opacity-50 cursor-not-allowed' : ''
            }`}
          >
            <div className={`absolute left-1 h-6 w-14 rounded-full transition-transform ${
              gameMode === 'creative' ? 'bg-purple-600 translate-x-16' : 'bg-blue-500'
            }`}></div>
            <span className={`absolute left-3 text-xs font-medium z-10 ${
              gameMode === 'science' ? 'text-white' : 'text-gray-400'
            }`}>Science</span>
            <span className={`absolute right-3 text-xs font-medium z-10 ${
              gameMode === 'creative' ? 'text-white' : 'text-gray-400'
            }`}>Creative</span>
          </button>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col relative z-10 min-h-0">
        {/* Element List */}
        <div 
          className="bg-gray-800/30 backdrop-blur-sm"
          style={{ height: `${listHeight}px` }}
        >
          <ElementListView
            elements={sortedElements}
            searchTerm={searchTerm}
            sortMode={sortMode}
            shakeElement={shakeElement}
            popElement={popElement}
            hoveredElement={null}
            isDragging={isDragging}
            dimmedElements={dimmedElements}
            isPlayingLoadAnimation={isPlayingLoadAnimation}
            animatedElements={animatedElements}
            onElementDragStart={(e, element) => {
              draggedElement.current = {
                ...element,
                x: 0,
                y: 0,
                index: 0,
                energized: false
              };
              setIsDragging(true);
              
              // Calculate and set dimmed elements for visual feedback
              const previouslyMixed = new Set<string>();
              Object.keys(combinations).forEach(comboKey => {
                const parts = comboKey.split('+');
                if (parts.includes(element.name)) {
                  parts.forEach(part => {
                    if (part !== element.name && part !== 'Energy') {
                      previouslyMixed.add(part);
                    }
                  });
                }
              });
              
              // Also check failed combinations
              failedCombinations.forEach(failedCombo => {
                const parts = failedCombo.split('+');
                if (parts.includes(element.name)) {
                  parts.forEach(part => {
                    if (part !== element.name && part !== 'Energy') {
                      previouslyMixed.add(part);
                    }
                  });
                }
              });
              
              setDimmedElements(previouslyMixed);
              
              e.dataTransfer.effectAllowed = 'copy';
              e.dataTransfer.setData('text/plain', element.name);
            }}
            onElementDragEnd={() => {
              setIsDragging(false);
              setHoveredElement(null);
              clearDimmedElements(); // Clear dimming
            }}
            onElementTouchStart={(e, element) => {
              const touch = e.touches[0];
              const rect = e.currentTarget.getBoundingClientRect();
              setTouchStartTime(Date.now());
              setTouchStartPos({ x: touch.clientX, y: touch.clientY });
              setTouchOffset({
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              });
              
              setTimeout(() => {
                if (touchStartTime && Date.now() - touchStartTime > 150) {
                  setTouchDragging({
                    ...element,
                    x: 0,
                    y: 0,
                    index: 0,
                    energized: false,
                    fromMixingArea: false,
                    mixIndex: undefined
                  });
                  
                  const otherElements = new Set(sortedElements.filter(el => el.id !== element.id).map(el => el.id));
                  setDimmedElements(otherElements);
                  
                  if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                  }
                }
              }, 150);
            }}
            onElementClick={handleElementClick}
            onElementMouseEnter={handleElementMouseEnter}
            onElementMouseLeave={handleElementMouseLeave}
          />
        </div>

        {/* Divider */}
        <div 
          className="h-1 bg-gray-600 cursor-row-resize hover:bg-gray-500 transition-colors flex items-center justify-center relative"
          onMouseDown={(e) => {
            setIsDraggingDivider(true);
            setDragStartY(e.clientY);
            setDragStartHeight(listHeight);
          }}
          onTouchStart={handleDividerTouchStart}
        >
          <GripHorizontal size={16} className="text-gray-400" />
        </div>

        {/* Mixing Area - Direct implementation without overflow hidden */}
        <div 
          ref={dropZoneRef}
          className="flex-1 bg-gray-800/30 backdrop-blur-sm relative"
          style={{ minHeight: '200px', touchAction: 'none' }}
          onDragOver={(e) => {
            e.preventDefault();
            if (draggedElement.current?.fromMixingArea) {
              e.dataTransfer.dropEffect = 'move';
            } else {
              e.dataTransfer.dropEffect = 'copy';
            }
          }}
          onDrop={async (e) => {
            e.preventDefault();
            if (!draggedElement.current || isMixing) return;

            const rect = dropZoneRef.current!.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const targetElement = mixingArea.find(el => {
              const elRect = document.getElementById(`mixing-${el.id}-${el.index}`)?.getBoundingClientRect();
              if (!elRect) return false;
              return e.clientX >= elRect.left && e.clientX <= elRect.right &&
                     e.clientY >= elRect.top && e.clientY <= elRect.bottom;
            });

            if (targetElement && targetElement.index !== draggedElement.current.mixIndex) {
              await mixElements(draggedElement.current, targetElement);
            } else if (!targetElement) {
              playSound('plop');
              const offset = GameLogic.getElementSize() / 2;
              if (draggedElement.current.fromMixingArea) {
                const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current!, draggedElement.current.mixIndex);
                updateMixingElement(draggedElement.current.mixIndex!, { x: newPos.x, y: newPos.y });
              } else {
                const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current!);
                const newElement: MixingElement = {
                  ...draggedElement.current,
                  x: newPos.x,
                  y: newPos.y,
                  index: Date.now(),
                  energized: false
                };
                addToMixingArea(newElement);
              }
            }
            
            draggedElement.current = null;
            setIsDragging(false);
            setHoveredElement(null);
            clearDimmedElements(); // Fix: Clear dimming on drop
          }}
          onTouchEnd={handleTouchEnd}
        >
          {mixingArea.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center">
              <p className="text-gray-500 text-center px-4">
                Drag elements here to mix them!
              </p>
            </div>
          )}
          
          {/* Clear Button */}
          {mixingArea.length > 0 && (
            <button
              onClick={handleClear}
              disabled={isMixing}
              className="absolute top-2 right-2 px-3 py-1 bg-red-600 hover:bg-red-500 disabled:bg-gray-600 disabled:cursor-not-allowed rounded text-white text-sm font-medium transition-colors z-10"
              title="Clear mixing area"
            >
              Clear
            </button>
          )}
          
          {mixingArea.map((element) => (
            <div
              key={`${element.id}-${element.index}`}
              id={`mixing-${element.id}-${element.index}`}
              draggable={!isTouchDevice && !isMixing}
              onDragStart={(e) => {
                draggedElement.current = {
                  ...element,
                  fromMixingArea: true,
                  mixIndex: element.index
                };
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', element.name);
                setIsDragging(true);
                playSound('press');
              }}
              onDragEnd={() => {
                setIsDragging(false);
                setHoveredElement(null);
                setDimmedElements(new Set());
              }}
              onTouchStart={(e) => {
                const touch = e.touches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                setTouchStartTime(Date.now());
                setTouchStartPos({ x: touch.clientX, y: touch.clientY });
                setTouchOffset({
                  x: touch.clientX - rect.left,
                  y: touch.clientY - rect.top
                });
                
                setTimeout(() => {
                  if (touchStartTime && Date.now() - touchStartTime > 100) {
                    setTouchDragging({
                      ...element,
                      fromMixingArea: true,
                      mixIndex: element.index
                    });
                    
                    if ('vibrate' in navigator) {
                      navigator.vibrate(10);
                    }
                  }
                }, 100);
              }}
              onMouseEnter={() => {
                if (isDragging) setHoveredElement(element.index);
              }}
              onMouseLeave={() => setHoveredElement(null)}
              onContextMenu={(e) => e.preventDefault()}
              onDragOver={(e) => {
                e.preventDefault();
                if (isDragging) {
                  setHoveredElement(element.index);
                  // Preserve the dropEffect from parent
                  if (draggedElement.current?.fromMixingArea) {
                    e.dataTransfer.dropEffect = 'move';
                  } else {
                    e.dataTransfer.dropEffect = 'copy';
                  }
                }
              }}
              onDragEnter={() => {
                if (isDragging) setHoveredElement(element.index);
              }}
              onDragLeave={() => setHoveredElement(null)}
              className={`absolute flex flex-col items-center justify-center rounded-lg cursor-move ${
                element.energized ? 'animate-shake' : ''
              } ${
                hoveredElement === element.index && !element.energized ? 'animate-continuous-pulse' : ''
              } ${
                touchDragging?.mixIndex === element.index && touchDragging?.fromMixingArea ? 'opacity-30' : ''
              } ${
                dimmedElements.has(element.name) ? 'element-dimmed' : ''
              } ${
                isElementRemoving(element.id, element.index) ? 'animate-pulse opacity-0' : ''
              }`}
              style={{ 
                left: element.x, 
                top: element.y,
                width: `${GameLogic.getElementSize()}px`,
                height: `${GameLogic.getElementSize()}px`,
                backgroundColor: element.color,
                color: GameLogic.getContrastColor(element.color),
                pointerEvents: isMixing ? 'none' : 'auto',
                touchAction: 'none',
                WebkitTouchCallout: 'none',
                WebkitUserSelect: 'none',
                transition: 'none',
                boxShadow: element.energized ? '0 0 20px rgba(250, 204, 21, 0.5), 0 0 0 2px #facc15' :
                          hoveredElement === element.index ? `0 0 0 2px ${GameLogic.getRarityHoverColor(element.rarity)}` : ''
              }}
            >
              <OpenMojiDisplay 
                emoji={element.emoji} 
                hexcode={element.openmojiHex}
                name={element.name} 
                size="md" 
                className="pointer-events-none"
              />
              <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight pointer-events-none">{element.name}</div>
            </div>
          ))}
          
          {isMixing && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/20 backdrop-blur-sm">
              <div className="bg-gray-800/90 rounded-xl p-6 flex flex-col items-center">
                <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mb-3"></div>
                <div className="text-sm">Mixing...</div>
              </div>
            </div>
          )}
        </div>

        {/* Touch Drag Element */}
        {touchDragging && (
          <div
            id="touch-drag-element"
            className="fixed pointer-events-none z-50 flex flex-col items-center justify-center text-center rounded-lg"
            style={{
              width: `${GameLogic.getElementSize()}px`,
              height: `${GameLogic.getElementSize()}px`,
              backgroundColor: touchDragging.color,
              color: GameLogic.getContrastColor(touchDragging.color),
              transform: 'scale(1.1)'
            }}
          >
            <OpenMojiDisplay 
              emoji={touchDragging.emoji} 
              hexcode={touchDragging.openmojiHex}
              name={touchDragging.name} 
              size="sm" 
            />
            <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight">
              {touchDragging.name}
            </div>
          </div>
        )}
      </div>

      {/* Challenge Bar */}
      <ChallengeBar isAnonymous={dbUser?.is_anonymous} currentGameMode={gameMode} />

      {/* Reasoning Popup */}
      <ReasoningPopup 
        reasoningPopup={reasoningPopup}
        onClose={hideReasoningPopup}
      />

      {/* Unlock Modal */}
      <UnlockModal 
        showUnlock={showUnlock}
        onClose={() => setShowUnlock(null)}
      />

      {/* Achievements Modal */}
      <AchievementsModal 
        isOpen={showAchievements}
        achievements={achievements}
        onClose={() => setShowAchievements(false)}
      />

      {/* Toast */}
      {toast && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 px-4 py-2 rounded-lg z-50">
          {toast}
        </div>
      )}
    </div>
  );
};

export default LLMAlchemyRefactored;
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyRefactored.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyWrapper.tsx ===== 
'use client';

import React from 'react';
import { GameStateProvider } from './contexts/GameStateProvider';
import LLMAlchemyRefactored from './LLMAlchemyRefactored';

interface LLMAlchemyWrapperProps {
  initialGameMode?: 'science' | 'creative';
}

const LLMAlchemyWrapper: React.FC<LLMAlchemyWrapperProps> = ({ 
  initialGameMode = 'science' 
}) => {
  console.log('[LLM_ALCHEMY_WRAPPER] üî¨ Using refactored version with new state management');
  
  return (
    <GameStateProvider initialGameMode={initialGameMode}>
      <LLMAlchemyRefactored />
    </GameStateProvider>
  );
};

export default LLMAlchemyWrapper;
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyWrapper.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\AchievementsModal.tsx ===== 
import React from 'react';
import { X } from 'lucide-react';
import { Achievement } from '@/types';

interface AchievementsModalProps {
  isOpen: boolean;
  achievements: Achievement[];
  onClose: () => void;
}

export const AchievementsModal: React.FC<AchievementsModalProps> = ({ 
  isOpen, 
  achievements, 
  onClose 
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-md mx-4 border border-gray-600 max-h-[80vh] flex flex-col">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-xl font-bold flex items-center gap-2">
            <span>üèÜ</span>
            Achievements
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white"
          >
            <X size={20} />
          </button>
        </div>
        <div className="overflow-y-auto flex-1">
          {achievements.length === 0 ? (
            <div className="text-center text-gray-400 py-8">
              <div className="text-4xl mb-2">üéØ</div>
              <p>No achievements yet!</p>
              <p className="text-sm mt-1">Keep discovering elements to unlock achievements.</p>
            </div>
          ) : (
            <div className="space-y-3">
              {achievements.map((achievement) => (
                <div
                  key={achievement.id}
                  className="bg-gray-700/50 rounded-lg p-3 border border-gray-600"
                >
                  <div className="flex items-start gap-3">
                    <span className="text-2xl">{achievement.emoji}</span>
                    <div className="flex-1">
                      <h4 className="font-semibold text-yellow-400">{achievement.name}</h4>
                      <p className="text-sm text-gray-300 mt-1">{achievement.description}</p>
                      {achievement.unlocked && (
                        <p className="text-xs text-gray-500 mt-2">
                          Unlocked: {new Date(achievement.unlocked).toLocaleDateString()}
                        </p>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\AchievementsModal.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\ElementListView.tsx ===== 
'use client';

import React from 'react';
import { Element } from '@/types/game.types';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { getContrastColor, getRarityHoverColor, getElementSizeClasses, isTouchDevice } from '@/lib/ui-utils';
import { useDelayedHover } from '../hooks/useDelayedHover';

interface ElementListViewProps {
  elements: Element[];
  searchTerm: string;
  sortMode: string;
  shakeElement: string | null;
  popElement: string | null;
  hoveredElement: string | null;
  isDragging: boolean;
  dimmedElements: Set<string>;
  isPlayingLoadAnimation: boolean;
  animatedElements: Set<string>;
  onElementDragStart: (e: React.DragEvent<HTMLDivElement>, element: Element) => void;
  onElementDragEnd: () => void;
  onElementTouchStart: (e: React.TouchEvent<HTMLDivElement>, element: Element) => void;
  onElementClick: (element: Element, event: React.MouseEvent) => void;
  onElementMouseEnter: (element: Element, event: React.MouseEvent) => void;
  onElementMouseLeave: () => void;
}

export const ElementListView: React.FC<ElementListViewProps> = ({
  elements,
  searchTerm,
  sortMode,
  shakeElement,
  popElement,
  hoveredElement,
  isDragging,
  dimmedElements,
  isPlayingLoadAnimation,
  animatedElements,
  onElementDragStart,
  onElementTouchStart,
  onElementClick,
  onElementMouseEnter,
  onElementMouseLeave
}) => {
  // Use the unified delayed hover hook
  const { handleMouseEnter, handleMouseLeave } = useDelayedHover({
    onHover: onElementMouseEnter,
    delay: 500
  });

  // Combined mouse leave handler that calls both the unified hook and parent handler
  const handleElementMouseLeave = () => {
    handleMouseLeave(); // Clear timeout from unified hook
    onElementMouseLeave(); // Call parent handler
  };

  // Sort elements based on sortMode
  const sortedElements = React.useMemo(() => {
    const filtered = elements.filter(element =>
      element.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (sortMode === 'alpha') {
      return filtered.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      // Sort by discovery order (unlockOrder ascending)
      return filtered.sort((a, b) => (a.unlockOrder || 0) - (b.unlockOrder || 0));
    }
  }, [elements, searchTerm, sortMode]);

  return (
    <div data-testid="element-list" className="flex-1 overflow-y-auto p-4 scrollbar-mobile">
      {/* Use flex-wrap layout for natural responsiveness */}
      <div className="flex flex-wrap gap-2">
        {sortedElements.map((element) => (
          <div
            key={element.id}
            data-testid={`element-${element.name}`}
            draggable={!isTouchDevice()}
            onDragStart={(e) => onElementDragStart(e, element)}
            onTouchStart={(e) => onElementTouchStart(e, element)}
            onMouseEnter={(e) => handleMouseEnter(element, e)}
            onMouseLeave={handleElementMouseLeave}
            onClick={(e) => onElementClick(element, e)}
            onContextMenu={(e) => e.preventDefault()}
            className={`
              ${getElementSizeClasses()} flex flex-col items-center justify-center rounded-lg cursor-move 
              hover:scale-110 transition-transform select-none
              ${popElement === element.id ? 'animate-element-pop-in' : ''}
              ${shakeElement === element.id ? 'animate-element-shake' : ''}
              ${isPlayingLoadAnimation && animatedElements.has(element.id) ? 'animate-element-load-delayed' : ''}
              ${dimmedElements.has(element.name) ? 'element-dimmed' : ''}
            `}
            style={{ 
              backgroundColor: element.color,
              color: getContrastColor(element.color),
              boxShadow: !isDragging && hoveredElement === element.id ? `0 0 0 2px ${getRarityHoverColor(element.rarity)}` : '',
              touchAction: 'none',
              WebkitTouchCallout: 'none',
              WebkitUserSelect: 'none',
              animationDelay: isPlayingLoadAnimation && animatedElements.has(element.id) 
                ? `${(element.unlockOrder || 0) * 25}ms` 
                : undefined
            }}
          >
            
            <OpenMojiDisplay 
              emoji={element.emoji} 
              hexcode={element.openmojiHex}
              name={element.name} 
              size="md" 
            />
            <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight">
              {element.name}
            </div>
          </div>
        ))}
      </div>

      {sortedElements.length === 0 && searchTerm && (
        <div className="text-center text-gray-400 py-8">
          <p>No elements found matching &quot;{searchTerm}&quot;</p>
          <p className="text-sm mt-2">Try a different search term</p>
        </div>
      )}

      {elements.length === 0 && (
        <div className="text-center text-gray-400 py-8">
          <p>No elements discovered yet!</p>
          <p className="text-sm mt-2">Start mixing to discover new elements</p>
        </div>
      )}
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\ElementListView.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\GameHeader.tsx ===== 
'use client';

import React from 'react';
import { Sparkles, ArrowLeft, User } from 'lucide-react';
import { GAME_CONFIG } from '@/lib/game-config';

interface GameHeaderProps {
  regularElementCount: number;
  endElementCount: number;
  gameMode: 'science' | 'creative';
  undoAvailable: boolean;
  isUndoing: boolean;
  userApiKey: string;
  tokenBalance: number;
  dailyCount: number;
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  sortMode: string;
  setSortMode: (mode: string) => void;
  isMixing: boolean;
  onBackToHome: () => void;
  onGameModeToggle: () => void;
  onShowAchievements: () => void;
  onUndo: () => Promise<void>;
  onGetMoreTokens: () => Promise<void>;
}

export const GameHeader: React.FC<GameHeaderProps> = ({
  regularElementCount,
  endElementCount,
  gameMode,
  undoAvailable,
  isUndoing,
  userApiKey,
  tokenBalance,
  dailyCount,
  searchTerm,
  setSearchTerm,
  sortMode,
  setSortMode,
  isMixing,
  onBackToHome,
  onGameModeToggle,
  onShowAchievements,
  onUndo,
  onGetMoreTokens
}) => {
  return (
    <div className="relative z-10 bg-gray-800/80 backdrop-blur-sm p-4 shadow-lg">
      <div className="flex justify-between items-start mb-3">
        <div className="flex items-center gap-3">
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Sparkles className="text-yellow-400 hidden sm:block" />
            LLM Alchemy
          </h1>
        </div>
        <div className="text-lg font-semibold flex flex-col items-end gap-1">
          <span>Elements: {regularElementCount}</span>
          {gameMode === 'science' && endElementCount > 0 && (
            <span className="text-gray-300 text-base">Ends: {endElementCount}</span>
          )}
        </div>
      </div>
      
      <div className="flex justify-between items-center mb-3">
        <button
          onClick={onBackToHome}
          className="flex items-center gap-2 px-3 py-1 hover:bg-gray-700 rounded transition-colors text-gray-400 hover:text-white"
          title="Back to Menu"
        >
          <ArrowLeft size={16} />
          <span className="text-sm">Back</span>
        </button>
        
        <div className="text-sm text-gray-400 flex items-center gap-2">
          {/* Undo Button */}
          {undoAvailable && !isUndoing && (
            <button
              onClick={onUndo}
              className="px-2 py-1 bg-orange-600 hover:bg-orange-500 rounded text-white font-medium transition-colors text-xs"
              title="Undo last combination"
            >
              ‚Ü∂ Undo
            </button>
          )}
          
          {userApiKey ? (
            <span className="text-green-400">Using your API key</span>
          ) : tokenBalance > 0 ? (
            <span className="text-yellow-400">Tokens: {tokenBalance}</span>
          ) : dailyCount >= GAME_CONFIG.DAILY_FREE_COMBINATIONS ? (
            <button
              onClick={onGetMoreTokens}
              className="px-3 py-1 bg-purple-600 hover:bg-purple-500 rounded text-white font-medium transition-colors"
            >
              Get more
            </button>
          ) : (
            <>
              <User size={14} />
              <span>{dailyCount}/{GAME_CONFIG.DAILY_FREE_COMBINATIONS} today</span>
            </>
          )}
        </div>
      </div>
      
      <div className="flex justify-between items-center gap-3">
        <div className="flex gap-2 text-sm items-center">
          <input
            type="text"
            placeholder="Filter..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-20 sm:w-20 px-2 py-1 text-sm bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400 focus:outline-none focus:border-purple-500"
          />
          <button
            onClick={onShowAchievements}
            className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition-all flex items-center gap-1"
          >
            <span>üèÜ</span>
            <span className="hidden sm:inline text-sm">Achievements</span>
          </button>
          <select
            value={sortMode}
            onChange={(e) => setSortMode(e.target.value)}
            className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm focus:outline-none focus:border-purple-500"
          >
            <option value="unlock">By Discovery</option>
            <option value="alpha">Alphabetical</option>
          </select>
        </div>
        
        {/* Game Mode Toggle */}
        <button
          onClick={onGameModeToggle}
          disabled={isMixing}
          className={`relative inline-flex h-8 w-32 cursor-pointer items-center rounded-full bg-gray-700 transition-colors hover:bg-gray-600 ${
            isMixing ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          <div className={`absolute left-1 h-6 w-14 rounded-full transition-transform ${
            gameMode === 'creative' ? 'bg-purple-600 translate-x-16' : 'bg-blue-500'
          }`}></div>
          <span className={`absolute left-3 text-xs font-medium z-10 ${
            gameMode === 'science' ? 'text-white' : 'text-gray-400'
          }`}>Science</span>
          <span className={`absolute right-3 text-xs font-medium z-10 ${
            gameMode === 'creative' ? 'text-white' : 'text-gray-400'
          }`}>Creative</span>
        </button>
      </div>
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\GameHeader.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\index.ts ===== 
export { UnlockModal } from './UnlockModal';
export { AchievementsModal } from './AchievementsModal';
export { ReasoningPopup } from './ReasoningPopup';
export { GameHeader } from './GameHeader';
export { ElementListView } from './ElementListView';
export { MixingAreaView } from './MixingAreaView';
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\index.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\MixingAreaView.tsx ===== 
'use client';

import React from 'react';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { MixingElement } from '../hooks/useGameState';
import { getContrastColor, getRarityHoverColor } from '@/lib/ui-utils';

interface MixingAreaViewProps {
  mixingArea: MixingElement[];
  isMixing: boolean;
  mixingResult: string | null;
  canUndo: boolean;
  animatingElements: Set<string>;
  hoveredElement: number | null;
  hoveredUIElement: string | null;
  isDragging: boolean;
  touchDragging: MixingElement | null;
  dimmedElements: Set<string>;
  onMixingElementMouseDown: (e: React.MouseEvent<HTMLDivElement>, element: MixingElement) => void;
  onMixingElementTouchStart: (e: React.TouchEvent<HTMLDivElement>, element: MixingElement) => void;
  onMixingElementMouseEnter: (element: MixingElement) => void;
  onMixingElementMouseLeave: () => void;
  onMixingElementDragOver: (e: React.DragEvent, element: MixingElement) => void;
  onMixingElementDragEnter: (element: MixingElement) => void;
  onMixingElementDragLeave: () => void;
  onClearMixingArea: () => void;
  onUndo: () => void;
}

export const MixingAreaView: React.FC<MixingAreaViewProps> = ({
  mixingArea,
  isMixing,
  canUndo,
  animatingElements,
  hoveredElement,
  hoveredUIElement,
  isDragging,
  touchDragging,
  dimmedElements,
  onMixingElementMouseDown,
  onMixingElementTouchStart,
  onMixingElementMouseEnter,
  onMixingElementMouseLeave,
  onMixingElementDragOver,
  onMixingElementDragEnter,
  onMixingElementDragLeave,
  onClearMixingArea,
  onUndo
}) => {
  return (
    <div className="flex-1 relative overflow-hidden">
      {/* Undo Button */}
      {canUndo && (
        <button
          onClick={onUndo}
          onMouseEnter={() => {}}
          onMouseLeave={() => {}}
          className="absolute top-4 left-4 px-3 py-2 rounded-lg transition-all z-20 flex items-center gap-1 bg-gray-700 hover:bg-gray-600 text-white cursor-pointer"
          title="Undo last action"
        >
          <span>‚Ü©Ô∏è</span>
          <span className="hidden sm:inline text-sm">Undo</span>
        </button>
      )}

      {/* Clear Button */}
      {mixingArea.length > 0 && !isMixing && (
        <button
          onClick={onClearMixingArea}
          onMouseEnter={() => {}}
          onMouseLeave={() => {}}
          className="absolute top-4 right-4 p-2 rounded-full z-20 bg-red-600 hover:bg-red-500 text-white transition-colors"
          title="Clear mixing area"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      )}

      {/* Empty state */}
      {mixingArea.length === 0 && (
        <div className="absolute inset-0 flex items-center justify-center">
          <p className="text-gray-500 text-center px-4">
            Drag elements here to mix them!
          </p>
        </div>
      )}
      
      {/* Mixing area elements */}
      {mixingArea.map((element) => (
        <div
          key={`${element.id}-${element.index}`}
          id={`mixing-${element.id}-${element.index}`}
          draggable={!isMixing}
          onDragStart={(e) => onMixingElementMouseDown(e as React.MouseEvent<HTMLDivElement>, element)}
          onTouchStart={(e) => onMixingElementTouchStart(e, element)}
          onMouseEnter={() => onMixingElementMouseEnter(element)}
          onMouseLeave={onMixingElementMouseLeave}
          onContextMenu={(e) => e.preventDefault()}
          onDragOver={(e) => onMixingElementDragOver(e, element)}
          onDragEnter={() => onMixingElementDragEnter(element)}
          onDragLeave={onMixingElementDragLeave}
          className={`absolute w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 flex flex-col items-center justify-center rounded-lg cursor-move ${
            element.energized ? 'animate-shake' : ''
          } ${
            hoveredElement === element.index && !element.energized ? 'animate-continuous-pulse' : ''
          } ${
            touchDragging?.mixIndex === element.index && touchDragging?.fromMixingArea ? 'opacity-30' : ''
          } ${
            animatingElements.has(`${element.id}-${element.index}`) ? 'animate-element-pop-out' : ''
          } ${
            dimmedElements.has(element.name) ? 'element-dimmed' : ''
          }`}
          style={{ 
            left: `${element.x}px`, 
            top: `${element.y}px`,
            backgroundColor: element.color,
            color: getContrastColor(element.color),
            pointerEvents: isMixing ? 'none' : 'auto',
            touchAction: 'none',
            WebkitTouchCallout: 'none',
            WebkitUserSelect: 'none',
            transition: 'none',
            zIndex: 10,
            boxShadow: element.energized ? '0 0 20px rgba(250, 204, 21, 0.5), 0 0 0 2px #facc15' :
                      hoveredElement === element.index ? `0 0 0 2px ${getRarityHoverColor(element.rarity)}` :
                      hoveredUIElement === `mixing-${element.index}` && !isDragging ? `0 0 0 2px ${getRarityHoverColor(element.rarity)}` : ''
          }}
        >
          <OpenMojiDisplay 
            emoji={element.emoji} 
            hexcode={element.openmojiHex}
            name={element.name} 
            size="md" 
            className="pointer-events-none"
          />
          <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight pointer-events-none">{element.name}</div>
        </div>
      ))}
      
      {/* Mixing overlay */}
      {isMixing && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/20 backdrop-blur-sm">
          <div className="bg-gray-800/90 rounded-xl p-6 flex flex-col items-center">
            <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mb-3"></div>
            <div className="text-sm">Mixing...</div>
          </div>
        </div>
      )}
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\MixingAreaView.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\ReasoningPopup.tsx ===== 
import React from 'react';
import { X, Zap } from 'lucide-react';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { Element } from '@/types/game.types';

interface ReasoningPopup {
  element: Element;
  x: number;
  y: number;
  fromHover: boolean;
}

interface ReasoningPopupProps {
  reasoningPopup: ReasoningPopup | null;
  onClose: () => void;
}

export const ReasoningPopup: React.FC<ReasoningPopupProps> = ({ 
  reasoningPopup, 
  onClose 
}) => {
  if (!reasoningPopup) return null;

  const { element } = reasoningPopup;
  const hasParents = element.parents && element.parents.length > 0;

  return (
    <div
      className="reasoning-popup fixed z-50 bg-gray-800 border border-gray-600 rounded-lg p-4 max-w-xs shadow-xl"
      style={{
        left: `${Math.min(reasoningPopup.x, window.innerWidth - 200)}px`,
        top: `${Math.max(reasoningPopup.y - 100, 10)}px`,
        transform: 'translateX(-50%)'
      }}
    >
      <div className="flex items-center gap-2 mb-2">
        <OpenMojiDisplay 
          emoji={element.emoji} 
          hexcode={element.openmojiHex}
          name={element.name} 
          size="sm" 
        />
        <h4 className="font-semibold">{element.name}</h4>
      </div>
      
      {/* Show parent elements if available */}
      {hasParents && (
        <div className="mb-3 p-2 bg-gray-700/50 rounded border-l-2 border-blue-400">
          <div className="text-xs text-gray-400 mb-1">Created from:</div>
          <div className="flex items-center gap-1 text-sm">
            {element.parents!.map((parent, index) => (
              <React.Fragment key={parent.name}>
                <span className="text-yellow-300">{parent.name}</span>
                {index < element.parents!.length - 1 && (
                  <span className="text-gray-400">+</span>
                )}
              </React.Fragment>
            ))}
            {element.energyEnhanced && (
              <>
                <span className="text-gray-400">+</span>
                <span className="text-purple-300 flex items-center gap-1">
                  <Zap size={12} />
                  Energy
                </span>
              </>
            )}
          </div>
        </div>
      )}
      
      {/* Show reasoning */}
      {element.reasoning && (
        <p className="text-sm text-gray-300">{element.reasoning}</p>
      )}
      
      <button
        onClick={onClose}
        className="absolute top-2 right-2 text-gray-400 hover:text-white"
      >
        <X size={16} />
      </button>
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\ReasoningPopup.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\UnlockModal.tsx ===== 
import React, { useEffect } from 'react';
import { Element, Achievement } from '@/types/game.types';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';

interface ShowUnlock extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

interface UnlockModalProps {
  showUnlock: ShowUnlock | null;
  onClose: () => void;
}

export const UnlockModal: React.FC<UnlockModalProps> = ({ showUnlock, onClose }) => {
  // Auto-close after 3 seconds for new discoveries, 2 seconds for already discovered
  useEffect(() => {
    if (!showUnlock) return;
    
    const timeout = setTimeout(() => {
      onClose();
    }, showUnlock.isNew ? 3000 : 2000);

    return () => clearTimeout(timeout);
  }, [showUnlock, onClose]);

  if (!showUnlock) return null;

  // Get rarity-based styling
  const getRarityStyle = (rarity: string = 'common') => {
    switch (rarity) {
      case 'uncommon':
        return {
          borderColor: '#10B981', // Green
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          glowColor: '0 0 20px rgba(16, 185, 129, 0.3)'
        };
      case 'rare':
        return {
          borderColor: '#8B5CF6', // Purple
          backgroundColor: 'rgba(139, 92, 246, 0.1)',
          glowColor: '0 0 20px rgba(139, 92, 246, 0.3)'
        };
      case 'epic':
        return {
          borderColor: '#F59E0B', // Orange/Gold
          backgroundColor: 'rgba(245, 158, 11, 0.1)',
          glowColor: '0 0 20px rgba(245, 158, 11, 0.3)'
        };
      case 'legendary':
        return {
          borderColor: '#EF4444', // Red
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          glowColor: '0 0 20px rgba(239, 68, 68, 0.3)'
        };
      default:
        return {
          borderColor: '#6B7280', // Gray
          backgroundColor: 'rgba(107, 114, 128, 0.1)',
          glowColor: '0 0 20px rgba(107, 114, 128, 0.2)'
        };
    }
  };

  const rarityStyle = getRarityStyle(showUnlock.rarity);

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-fade-in" onClick={onClose}>
      <div 
        className="bg-gray-800 rounded-lg p-6 max-w-sm mx-4 border-2 animate-element-unlock-bounce cursor-pointer"
        style={{
          borderColor: rarityStyle.borderColor,
          backgroundColor: `${rarityStyle.backgroundColor}`,
          boxShadow: rarityStyle.glowColor
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="text-center">
          <div className="text-6xl mb-4">
            <OpenMojiDisplay 
              emoji={showUnlock.emoji} 
              hexcode={showUnlock.openmojiHex}
              name={showUnlock.name} 
              size="lg" 
            />
          </div>
          <h3 className="text-xl font-bold mb-2">
            {showUnlock.isNew ? 'New Discovery!' : 'Already Discovered'}
          </h3>
          <h4 className="text-lg text-yellow-400 mb-2">{showUnlock.name}</h4>
          {showUnlock.reasoning && (
            <p className="text-sm text-gray-300 mb-4">{showUnlock.reasoning}</p>
          )}
          {showUnlock.achievement && (
            <div className="bg-yellow-500/20 border border-yellow-500/50 rounded-lg p-3 mb-4">
              <div className="flex items-center gap-2 justify-center">
                <span className="text-2xl">üèÜ</span>
                <div>
                  <h5 className="font-semibold text-yellow-400">{showUnlock.achievement.name}</h5>
                  <p className="text-xs text-gray-300">{showUnlock.achievement.description}</p>
                </div>
              </div>
            </div>
          )}
          {showUnlock.isEndElement && (
            <div className="bg-purple-500/20 border border-purple-500/50 rounded-lg p-2 mb-4">
              <span className="text-sm text-purple-300">üèÅ End Element</span>
            </div>
          )}
          
          {/* Rarity indicator */}
          {showUnlock.rarity && showUnlock.rarity !== 'common' && (
            <div className="mt-4">
              <span 
                className="px-2 py-1 rounded-full text-xs font-bold uppercase tracking-wide"
                style={{ 
                  color: rarityStyle.borderColor,
                  backgroundColor: rarityStyle.backgroundColor,
                  border: `1px solid ${rarityStyle.borderColor}`
                }}
              >
                {showUnlock.rarity}
              </span>
            </div>
          )}
          
          {/* Auto-close indicator */}
          <div className="mt-4 text-xs text-gray-400">
            Click anywhere to close ‚Ä¢ Auto-closes in {showUnlock.isNew ? '3' : '2'}s
          </div>
        </div>
      </div>
    </div>
  );
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\components\UnlockModal.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\contexts\GameStateProvider.tsx ===== 
'use client';

import React, { createContext, useContext, ReactNode } from 'react';
import { useGameState, GameState, GameAction, MixingElement, LastCombination } from '../hooks/useGameState';
import { Element, Achievement } from '@/types/game.types';

// Context type definition
interface GameStateContextType {
  state: GameState;
  dispatch: React.Dispatch<GameAction>;
  actions: {
    setGameMode: (mode: 'science' | 'creative') => void;
    setElements: (elements: Element[]) => void;
    addElement: (element: Element) => void;
    setEndElements: (endElements: Element[]) => void;
    addEndElement: (element: Element) => void;
    setCombinations: (combinations: Record<string, string | null>) => void;
    addCombination: (key: string, result: string | null) => void;
    setMixingArea: (mixingArea: MixingElement[]) => void;
    addToMixingArea: (element: MixingElement) => void;
    removeFromMixingArea: (indices: number[]) => void;
    updateMixingElement: (index: number, updates: Partial<MixingElement>) => void;
    clearMixingArea: () => void;
    setAchievements: (achievements: Achievement[]) => void;
    addAchievements: (achievements: Achievement[]) => void;
    setFailedCombinations: (failedCombinations: string[]) => void;
    addFailedCombination: (combination: string) => void;
    setDimmedElements: (dimmedElements: Set<string>) => void;
    addDimmedElement: (elementName: string) => void;
    removeDimmedElement: (elementName: string) => void;
    clearDimmedElements: () => void;
    setAnimatingElements: (animatingElements: Set<string>) => void;
    addAnimatingElement: (elementName: string) => void;
    removeAnimatingElement: (elementName: string) => void;
    clearAnimatingElements: () => void;
    setIsUndoing: (isUndoing: boolean) => void;
    setIsMixing: (isMixing: boolean) => void;
    setIsDragging: (isDragging: boolean) => void;
    setHoveredElement: (elementIndex: number | null) => void;
    setTouchDragging: (element: MixingElement | null) => void;
    setTouchOffset: (offset: { x: number; y: number }) => void;
    setLastCombination: (combination: LastCombination | null) => void;
    setUndoAvailable: (available: boolean) => void;
    incrementTotalCombinations: () => void;
    setStateRestored: (restored: boolean) => void;
    loadSavedState: (savedState: Partial<GameState>) => void;
    resetGameState: (gameMode: 'science' | 'creative') => void;
  };
}

// Create the context
const GameStateContext = createContext<GameStateContextType | undefined>(undefined);

// Provider component props
interface GameStateProviderProps {
  children: ReactNode;
  initialGameMode?: 'science' | 'creative';
}

// Provider component
export function GameStateProvider({ children, initialGameMode = 'science' }: GameStateProviderProps) {
  const gameState = useGameState(initialGameMode);

  return (
    <GameStateContext.Provider value={gameState}>
      {children}
    </GameStateContext.Provider>
  );
}

// Custom hook to use the game state context
export function useGameStateContext(): GameStateContextType {
  const context = useContext(GameStateContext);
  
  if (context === undefined) {
    throw new Error('useGameStateContext must be used within a GameStateProvider');
  }
  
  return context;
}

// Convenience hooks for specific parts of the state
export function useGameMode() {
  const { state, actions } = useGameStateContext();
  return {
    gameMode: state.gameMode,
    setGameMode: actions.setGameMode,
  };
}

export function useElements() {
  const { state, actions } = useGameStateContext();
  return {
    elements: state.elements,
    endElements: state.endElements,
    setElements: actions.setElements,
    addElement: actions.addElement,
    setEndElements: actions.setEndElements,
    addEndElement: actions.addEndElement,
  };
}

export function useMixingArea() {
  const { state, actions } = useGameStateContext();
  return {
    mixingArea: state.mixingArea,
    setMixingArea: actions.setMixingArea,
    addToMixingArea: actions.addToMixingArea,
    removeFromMixingArea: actions.removeFromMixingArea,
    updateMixingElement: actions.updateMixingElement,
    clearMixingArea: actions.clearMixingArea,
  };
}

export function useCombinations() {
  const { state, actions } = useGameStateContext();
  return {
    combinations: state.combinations,
    failedCombinations: state.failedCombinations,
    setCombinations: actions.setCombinations,
    addCombination: actions.addCombination,
    setFailedCombinations: actions.setFailedCombinations,
    addFailedCombination: actions.addFailedCombination,
  };
}

export function useAchievements() {
  const { state, actions } = useGameStateContext();
  return {
    achievements: state.achievements,
    setAchievements: actions.setAchievements,
    addAchievements: actions.addAchievements,
  };
}

export function useGameUndo() {
  const { state, actions } = useGameStateContext();
  return {
    lastCombination: state.lastCombination,
    undoAvailable: state.undoAvailable,
    setLastCombination: actions.setLastCombination,
    setUndoAvailable: actions.setUndoAvailable,
  };
}

export function useGameStats() {
  const { state, actions } = useGameStateContext();
  return {
    totalCombinationsMade: state.totalCombinationsMade,
    isStateRestored: state.isStateRestored,
    incrementTotalCombinations: actions.incrementTotalCombinations,
    setStateRestored: actions.setStateRestored,
  };
}

export function useGamePersistence() {
  const { actions } = useGameStateContext();
  return {
    loadSavedState: actions.loadSavedState,
    resetGameState: actions.resetGameState,
  };
}

export function useElementInteractionState() {
  const { state, actions } = useGameStateContext();
  return {
    dimmedElements: state.dimmedElements,
    animatingElements: state.animatingElements,
    isUndoing: state.isUndoing,
    isMixing: state.isMixing,
    isDragging: state.isDragging,
    hoveredElement: state.hoveredElement,
    touchDragging: state.touchDragging,
    touchOffset: state.touchOffset,
    setDimmedElements: actions.setDimmedElements,
    addDimmedElement: actions.addDimmedElement,
    removeDimmedElement: actions.removeDimmedElement,
    clearDimmedElements: actions.clearDimmedElements,
    setAnimatingElements: actions.setAnimatingElements,
    addAnimatingElement: actions.addAnimatingElement,
    removeAnimatingElement: actions.removeAnimatingElement,
    clearAnimatingElements: actions.clearAnimatingElements,
    setIsUndoing: actions.setIsUndoing,
    setIsMixing: actions.setIsMixing,
    setIsDragging: actions.setIsDragging,
    setHoveredElement: actions.setHoveredElement,
    setTouchDragging: actions.setTouchDragging,
    setTouchOffset: actions.setTouchOffset,
  };
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\contexts\GameStateProvider.tsx ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useDelayedHover.ts ===== 
import { useRef, useCallback, useEffect } from 'react';
import { Element } from '@/types/game.types';
import { isTouchDevice } from '@/lib/ui-utils';

interface UseDelayedHoverProps {
  onHover: (element: Element, event: React.MouseEvent) => void;
  delay?: number;
}

interface UseDelayedHoverReturn {
  handleMouseEnter: (element: Element, event: React.MouseEvent) => void;
  handleMouseLeave: () => void;
}

/**
 * Unified hook for handling delayed hover effects with reasoning popups
 * Encapsulates the 500ms timer logic used by both ElementListView and MixingAreaView
 */
export function useDelayedHover({
  onHover,
  delay = 500
}: UseDelayedHoverProps): UseDelayedHoverReturn {
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isTouch = isTouchDevice();

  const handleMouseEnter = useCallback((element: Element, event: React.MouseEvent) => {
    // Only show popup on hover for desktop with delay, and only if element has reasoning
    if (!isTouch && element.reasoning) {
      // Clear any existing timeout
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }

      // Capture the bounding rect immediately
      const rect = event.currentTarget.getBoundingClientRect();

      // Set delay before showing popup
      hoverTimeoutRef.current = setTimeout(() => {
        // Create a synthetic event with the captured rect
        const syntheticEvent = {
          ...event,
          currentTarget: {
            getBoundingClientRect: () => rect
          },
          type: 'mouseenter'
        };
        onHover(element, syntheticEvent as React.MouseEvent);
      }, delay);
    }
  }, [onHover, delay, isTouch]);

  const handleMouseLeave = useCallback(() => {
    // Clear timeout if leaving before delay completes
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }
  }, []);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  return {
    handleMouseEnter,
    handleMouseLeave
  };
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useDelayedHover.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementInteraction.ts ===== 
import { useCallback, useRef } from 'react';
import { useMixingArea } from '../contexts/GameStateProvider';
import { Element, MixingElement } from './useGameState';
import * as GameLogic from '@/lib/game-logic';

interface UseElementInteractionProps {
  onMixElements: (elem1: MixingElement, elem2: MixingElement) => Promise<void>;
  onShowToast: (message: string) => void;
  onPlaySound: (type: string) => void;
  dropZoneRef: React.RefObject<HTMLDivElement | null>;
}

export function useElementInteraction({
  onMixElements,
  onShowToast,
  onPlaySound,
  dropZoneRef
}: UseElementInteractionProps) {
  const { mixingArea, addToMixingArea, updateMixingElement } = useMixingArea();
  const draggedElementRef = useRef<MixingElement | null>(null);
  const isDraggingRef = useRef(false);

  // Handle drag start for elements in mixing area
  const handleDragStart = useCallback((element: MixingElement, event: React.DragEvent | React.PointerEvent) => {
    draggedElementRef.current = element;
    isDraggingRef.current = true;
    onPlaySound('pick');
    
    // Haptic feedback for touch devices
    if ('vibrate' in navigator) {
      navigator.vibrate(50);
    }
    
    if ('dataTransfer' in event) {
      // Desktop drag and drop
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', element.id);
    }
  }, [onPlaySound]);

  // Handle drag over for mixing area
  const handleDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  // Handle drop in mixing area
  const handleDrop = useCallback((event: React.DragEvent | React.TouchEvent) => {
    event.preventDefault();
    
    if (!draggedElementRef.current || !dropZoneRef.current) return;
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    let clientX: number, clientY: number;
    
    if ('clientX' in event) {
      // Mouse/drag event
      clientX = event.clientX;
      clientY = event.clientY;
    } else if ('touches' in event) {
      // Touch event
      const touch = event.touches?.[0] || event.changedTouches?.[0];
      if (!touch) return;
      clientX = touch.clientX;
      clientY = touch.clientY;
    } else {
      return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Resolve collisions with other elements
    const newPosition = GameLogic.resolveCollisions(
      x, 
      y, 
      mixingArea, 
      dropZoneRef.current, 
      draggedElementRef.current.index
    );
    
    // Update element position
    updateMixingElement(draggedElementRef.current.index, {
      x: newPosition.x,
      y: newPosition.y
    });
    
    // Check for collisions with other elements after drop
    checkForMixing(draggedElementRef.current.index, newPosition.x, newPosition.y);
    
    draggedElementRef.current = null;
    isDraggingRef.current = false;
  }, [mixingArea, updateMixingElement, dropZoneRef]);

  // Check for element mixing after position update
  const checkForMixing = useCallback((movedIndex: number, x: number, y: number) => {
    const movedElement = mixingArea.find(el => el.index === movedIndex);
    if (!movedElement) return;
    
    // Check collision with other elements
    for (const otherElement of mixingArea) {
      if (otherElement.index === movedIndex) continue;
      
      if (GameLogic.checkCollision(x, y, otherElement.x, otherElement.y)) {
        // Found a collision - trigger mixing
        onMixElements(movedElement, otherElement);
        return;
      }
    }
  }, [mixingArea, onMixElements]);

  // Handle element drag from element panel to mixing area
  const handleElementDrop = useCallback((element: Element, clientX: number, clientY: number) => {
    if (!dropZoneRef.current) return;
    
    // Prevent dropping end elements
    if (element.isEndElement) {
      onShowToast('End elements cannot be mixed');
      return;
    }
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    const x = clientX - rect.left - GameLogic.getElementSize() / 2;
    const y = clientY - rect.top - GameLogic.getElementSize() / 2;
    
    // Resolve position to avoid collisions
    const newPosition = GameLogic.resolveCollisions(x, y, mixingArea, dropZoneRef.current);
    
    // Create mixing element
    const mixingElement: MixingElement = {
      ...element,
      x: newPosition.x,
      y: newPosition.y,
      index: Date.now() + Math.random(), // Unique index
      energized: false
    };
    
    addToMixingArea(mixingElement);
    onPlaySound('drop');
    
    // Check for immediate mixing
    setTimeout(() => {
      checkForMixing(mixingElement.index, newPosition.x, newPosition.y);
    }, 100);
  }, [mixingArea, addToMixingArea, onPlaySound, onShowToast, dropZoneRef, checkForMixing]);

  // Handle double click for quick mixing
  const handleElementDoubleClick = useCallback((element: Element) => {
    if (element.isEndElement) {
      onShowToast('End elements cannot be mixed');
      return;
    }
    
    // Find the center of the mixing area
    if (!dropZoneRef.current) return;
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    const centerX = rect.width / 2 - GameLogic.getElementSize() / 2;
    const centerY = rect.height / 2 - GameLogic.getElementSize() / 2;
    
    // Resolve position
    const newPosition = GameLogic.resolveCollisions(centerX, centerY, mixingArea, dropZoneRef.current);
    
    // Create mixing element
    const mixingElement: MixingElement = {
      ...element,
      x: newPosition.x,
      y: newPosition.y,
      index: Date.now() + Math.random(),
      energized: false
    };
    
    addToMixingArea(mixingElement);
    onPlaySound('drop');
  }, [mixingArea, addToMixingArea, onPlaySound, onShowToast, dropZoneRef]);

  // Touch handling for mobile devices
  const handleTouchStart = useCallback((element: MixingElement, event: React.TouchEvent) => {
    event.preventDefault();
    handleDragStart(element, event as unknown as React.PointerEvent);
  }, [handleDragStart]);

  const handleTouchMove = useCallback((event: React.TouchEvent) => {
    event.preventDefault();
    if (!isDraggingRef.current || !draggedElementRef.current || !dropZoneRef.current) return;
    
    const touch = event.touches[0];
    const rect = dropZoneRef.current.getBoundingClientRect();
    const x = touch.clientX - rect.left - GameLogic.getElementSize() / 2;
    const y = touch.clientY - rect.top - GameLogic.getElementSize() / 2;
    
    // Update position during drag
    updateMixingElement(draggedElementRef.current.index, { x, y });
  }, [updateMixingElement, dropZoneRef]);

  const handleTouchEnd = useCallback((event: React.TouchEvent) => {
    event.preventDefault();
    if (!isDraggingRef.current || !draggedElementRef.current) return;
    
    handleDrop(event);
  }, [handleDrop]);

  // Keyboard accessibility
  const handleKeyDown = useCallback((element: Element, event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleElementDoubleClick(element);
    }
  }, [handleElementDoubleClick]);

  // Clear dragging state (useful for cleanup)
  const clearDragState = useCallback(() => {
    draggedElementRef.current = null;
    isDraggingRef.current = false;
  }, []);

  // Get drag state
  const isDragging = useCallback(() => isDraggingRef.current, []);
  const getDraggedElement = useCallback(() => draggedElementRef.current, []);

  return {
    // Drag and drop handlers
    handleDragStart,
    handleDragOver,
    handleDrop,
    handleElementDrop,
    
    // Touch handlers
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    
    // Interaction handlers
    handleElementDoubleClick,
    handleKeyDown,
    
    // State management
    clearDragState,
    isDragging,
    getDraggedElement,
    
    // Mixing check
    checkForMixing
  };
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementInteraction.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementMixing.ts ===== 
import { useCallback } from 'react';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, incrementDailyCount, saveGameState, consumeToken } from '@/lib/supabase';
import { buildSharedSections, buildSciencePrompt, buildCreativePrompt } from '@/lib/llm-prompts';
import { checkAchievements } from '@/lib/achievements';
import { elementMatchesCategory } from '@/lib/challenge-elements';
import { resolveEmoji } from '@/lib/openmoji-service';
import { GAME_CONFIG } from '@/lib/game-config';
import { Achievement } from '@/types';
import { 
  useGameMode, 
  useElements, 
  useMixingArea, 
  useCombinations, 
  useAchievements, 
  useGameUndo, 
  useGameStats 
} from '../contexts/GameStateProvider';
import { Element } from '@/types/game.types';
import { MixingElement, LastCombination } from './useGameState';
import * as GameLogic from '@/lib/game-logic';

interface ShowUnlockElement extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

interface UseElementMixingProps {
  userApiKey: string;
  selectedModel: 'flash' | 'pro';
  onShowToast: (message: string) => void;
  onPlaySound: (type: string) => void;
  onShowUnlock: (element: ShowUnlockElement | null) => void;
  onSetShakeElement: (id: string | null) => void;
  onSetPopElement: (id: string | null) => void;
  onSetUnlockAnimationStartTime: (time: number | null) => void;
  onSetIsMixing: (isMixing: boolean) => void;
  dropZoneRef: React.RefObject<HTMLDivElement | null>;
}

export function useElementMixing({
  userApiKey,
  selectedModel,
  onShowToast,
  onPlaySound,
  onShowUnlock,
  onSetShakeElement,
  onSetPopElement,
  onSetUnlockAnimationStartTime,
  onSetIsMixing,
  dropZoneRef
}: UseElementMixingProps) {
  const { user, dailyCount, tokenBalance, refreshDailyCount, refreshTokenBalance } = useSupabase();
  const { gameMode } = useGameMode();
  const { elements, endElements, addElement, addEndElement } = useElements();
  const { mixingArea, setMixingArea, updateMixingElement, removeFromMixingArea, addToMixingArea } = useMixingArea();
  const { combinations, failedCombinations, addCombination, addFailedCombination } = useCombinations();
  const { achievements, addAchievements } = useAchievements();
  const { setLastCombination, setUndoAvailable } = useGameUndo();
  const { incrementTotalCombinations } = useGameStats();

  // Generate combination using API
  const generateCombination = useCallback(async (
    elem1: Element, 
    elem2: Element, 
    elem3: Element | null = null
  ): Promise<GameLogic.CombinationResult> => {
    // Check daily limit first
    const limitCheck = GameLogic.shouldAllowMixing(
      userApiKey, 
      tokenBalance, 
      dailyCount, 
      GAME_CONFIG.DAILY_FREE_COMBINATIONS
    );
    
    if (!limitCheck.allowed) {
      onShowToast(limitCheck.reason!);
      return { result: null, error: true, limitReached: true };
    }

    // Determine model selection
    const modelSelection = GameLogic.determineModelSelection(userApiKey, tokenBalance, selectedModel);
    console.log(`[LLM-Alchemy Frontend] User Type: ${modelSelection.userType} | Model: ${modelSelection.model} | Reason: ${modelSelection.reason}`);

    // Build combination key for caching
    const sortedNames = [elem1.name, elem2.name, elem3?.name].filter(Boolean).sort().join('+');
    const mixKey = elem3 ? `${sortedNames}+Energy` : sortedNames;

    // Check cache first
    const cachedResult = GameLogic.getCachedCombination(mixKey, combinations, elements, endElements);
    if (cachedResult) return cachedResult;

    // Check hardcoded combinations
    const hardcodedResult = GameLogic.getHardcodedCombination(sortedNames, gameMode);
    if (hardcodedResult) {
      // Add 1-second delay to simulate LLM processing
      await new Promise(resolve => setTimeout(resolve, 1000));
      return hardcodedResult;
    }

    // Build context for LLM
    const { recentText, failedText } = GameLogic.buildCombinationContext(combinations, failedCombinations);
    const rarityTarget = GameLogic.calculateRarityTarget();

    // Build shared sections and prompt
    const sharedSections = buildSharedSections(rarityTarget, gameMode);
    const mixingElements = [elem1, elem2, elem3].filter((e): e is Element => e !== null);
    
    const prompt = gameMode === 'science' 
      ? buildSciencePrompt(elements, mixingElements, sharedSections, recentText, failedText)
      : buildCreativePrompt(elements, mixingElements, sharedSections, recentText, failedText);

    // Make API request with retry logic
    const makeRequest = async (): Promise<{
      error?: string;
      outcomes?: Array<{
        result: string;
        emoji: string;
        color: string;
        rarity: string;
        reasoning: string;
        achievementTags: string[];
        emojiTags: string[];
        tags: string[];
        isEndElement: boolean;
      }> | null;
      reasoning?: string;
    }> => {
      const abortController = new AbortController();
      const timeoutId = setTimeout(() => abortController.abort(), 8000);
      
      try {
        const requestBody = { 
          prompt, 
          gameMode,
          apiKey: userApiKey,
          useProModel: modelSelection.useProModel
        };
        
        const response = await fetch('/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
          signal: abortController.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`[LLM-Alchemy Debug] API request failed:`, response.status, errorText);
          throw new Error(`API request failed: ${response.status}`);
        }

        const rawResponse = await response.text();
        return JSON.parse(rawResponse);
        
      } catch (error) {
        clearTimeout(timeoutId);
        
        if (error instanceof Error && error.name === 'AbortError') {
          throw new Error('Request timed out');
        }
        
        throw error;
      }
    };

    try {
      let parsedResult;
      
      try {
        parsedResult = await makeRequest();
      } catch (firstError) {
        const errorMessage = firstError instanceof Error ? firstError.message : 'Unknown error';
        
        if (errorMessage === 'Request timed out') {
          onShowToast('Connection slow, retrying...');
          
          try {
            parsedResult = await makeRequest();
          } catch (retryError) {
            const retryErrorMessage = retryError instanceof Error ? retryError.message : 'Unknown error';
            
            if (retryErrorMessage === 'Request timed out') {
              onShowToast('LLM timeout - try mixing again');
            } else {
              onShowToast('Network error - check connection');
            }
            
            return { result: null, error: true, timeout: true };
          }
        } else {
          throw firstError;
        }
      }
      
      // Handle API response
      if (parsedResult.error) {
        onShowToast('API Error: ' + parsedResult.error);
        return { result: null, error: true };
      }
      
      if (parsedResult.outcomes === null) {
        // No valid combination - track as failed
        const failedKey = `${elem1.name}+${elem2.name}${elem3 ? '+Energy' : ''}`;
        addFailedCombination(failedKey);
        
        // Increment counter for failed attempts too
        await incrementUsageCounter();
        return { result: null, reasoning: parsedResult.reasoning };
      }
      
      // Handle successful outcomes
      if (Array.isArray(parsedResult.outcomes) && parsedResult.outcomes.length > 0) {
        let selectedOutcome;
        
        if (parsedResult.outcomes.length === 1) {
          selectedOutcome = parsedResult.outcomes[0];
        } else {
          // Multiple outcomes - select based on rarity probabilities
          const roll = Math.random() * 100;
          
          const commonOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'common');
          const uncommonOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'uncommon');
          const rareOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'rare');
          
          if (roll < 60 && commonOutcomes.length > 0) {
            selectedOutcome = commonOutcomes[Math.floor(Math.random() * commonOutcomes.length)];
          } else if (roll < 90 && uncommonOutcomes.length > 0) {
            selectedOutcome = uncommonOutcomes[Math.floor(Math.random() * uncommonOutcomes.length)];
          } else if (rareOutcomes.length > 0) {
            selectedOutcome = rareOutcomes[Math.floor(Math.random() * rareOutcomes.length)];
          } else {
            selectedOutcome = parsedResult.outcomes[Math.floor(Math.random() * parsedResult.outcomes.length)];
          }
        }
        
        // Increment usage counter for successful API calls
        await incrementUsageCounter();
        
        return {
          result: selectedOutcome.result || null,
          emoji: selectedOutcome.emoji || '‚ú®',
          color: selectedOutcome.color || '#808080',
          rarity: selectedOutcome.rarity || 'common',
          reasoning: selectedOutcome.reasoning || '',
          achievementTags: selectedOutcome.achievementTags || [],
          emojiTags: selectedOutcome.emojiTags || [],
          tags: selectedOutcome.tags || [],
          isEndElement: selectedOutcome.isEndElement || false
        };
      }
      
      await incrementUsageCounter();
      return { result: null };
      
    } catch (error) {
      console.error('Error generating combination:', error);
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        onShowToast('Network Error: Check connection and try again');
      } else if (error instanceof SyntaxError) {
        onShowToast('API Error: Invalid response format');
      } else {
        onShowToast('LLM Error: Try mixing different elements');
      }
      
      return { result: null, error: true };
    }
  }, [userApiKey, selectedModel, gameMode, elements, endElements, combinations, failedCombinations, tokenBalance, dailyCount]);

  // Helper to increment usage counter
  const incrementUsageCounter = useCallback(async () => {
    try {
      if (user && !userApiKey) {
        const supabase = createClient();
        
        if (tokenBalance > 0) {
          await consumeToken(supabase, user.id);
          await refreshTokenBalance();
        } else {
          await incrementDailyCount(supabase, user.id);
          await refreshDailyCount();
        }
      }
      return true;
    } catch (error) {
      console.error('Error updating usage counter:', error);
      return true;
    }
  }, [user, userApiKey, tokenBalance, refreshTokenBalance, refreshDailyCount]);

  // Check challenge completion
  const checkChallengeCompletion = useCallback(async (element: Element) => {
    if (!user) return;
    
    try {
      const response = await fetch('/api/challenges/current');
      if (!response.ok) return;
      
      const data = await response.json();
      const currentChallenges = data.challenges || [];
      
      for (const challenge of currentChallenges) {
        if (challenge.isCompleted) continue;
        
        let isCompleted = false;
        
        if (challenge.target_element) {
          isCompleted = element.name.toLowerCase() === challenge.target_element.toLowerCase();
        } else if (challenge.target_category) {
          const elementTags = element.achievementTags || element.tags || [];
          isCompleted = elementMatchesCategory(elementTags, challenge.target_category);
        }
        
        if (isCompleted) {
          const response = await fetch('/api/challenges/complete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              challengeId: challenge.id,
              elementDiscovered: element.name,
              elementTags: element.tags || [],
              gameMode
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            
            if (result.tokensAwarded > 0) {
              onShowToast(`üéâ Challenge completed! +${result.tokensAwarded} tokens`);
              await refreshTokenBalance();
            } else {
              onShowToast(`üéâ Challenge completed!`);
            }
            
            onPlaySound('reward');
          }
        }
      }
    } catch (error) {
      console.error('Error checking challenge completion:', error);
    }
  }, [user, gameMode, refreshTokenBalance, onShowToast, onPlaySound]);

  // Main mixing function
  const mixElements = useCallback(async (elem1: MixingElement, elem2: MixingElement) => {
    if (!GameLogic.validateMixing(elem1, elem2)) return;
    
    onPlaySound('pop');
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate([10, 10, 10]);
    }
    
    const mixingType = GameLogic.getMixingType(elem1, elem2);
    
    if (mixingType === 'energize') {
      // Energize the non-energy element
      const targetEl = elem2.name === 'Energy' ? elem1 : elem2;
      updateMixingElement(targetEl.index, { energized: true });
      
      // Remove energy element
      const energyIndex = elem1.name === 'Energy' ? elem1.index : elem2.index;
      removeFromMixingArea([energyIndex]);
      
    } else if (mixingType === 'energy-mix') {
      // Mix with energy
      const baseElem1 = elem1.energized ? { ...elem1, energized: false } as Element : elem1;
      const baseElem2 = elem2.energized ? { ...elem2, energized: false } as Element : elem2;
      
      await performMix([baseElem1, baseElem2], true, elem1.index, elem2.index);
      
    } else {
      // Normal mixing
      await performMix([elem1, elem2], false, elem1.index, elem2.index);
    }
  }, [onPlaySound, updateMixingElement, setMixingArea]);

  // Perform the actual mixing logic
  const performMix = useCallback(async (
    elementsToMix: Element[], 
    hasEnergy: boolean = false, 
    ...indicesToRemove: number[]
  ) => {
    // Capture the mixing area state BEFORE removing elements for undo functionality
    const mixingAreaSnapshot = [...mixingArea];
    
    // Remove elements from mixing area immediately
    removeFromMixingArea(indicesToRemove);
    
    const mixKey = GameLogic.generateCombinationKey(elementsToMix, hasEnergy);
    
    // Check if combination already exists
    const cachedResult = GameLogic.getCachedCombination(mixKey, combinations, elements, endElements);
    if (cachedResult) {
      if (cachedResult.result) {
        const existingElement = elements.find(e => e.name === cachedResult.result) || 
                                endElements.find(e => e.name === cachedResult.result);
        if (existingElement) {
          onShowUnlock({ ...existingElement, isNew: false });
          if (!existingElement.isEndElement) {
            onSetShakeElement(existingElement.id);
            setTimeout(() => {
              onShowUnlock(null);
              onSetShakeElement(null);
            }, 1500);
          } else {
            setTimeout(() => onShowUnlock(null), 1500);
          }
        }
      } else {
        onShowToast('No reaction');
      }
      return;
    }

    // Generate new combination
    onSetIsMixing(true);
    const result = await generateCombination(
      elementsToMix[0], 
      elementsToMix[1], 
      hasEnergy ? { name: 'Energy' } as Element : null
    );
    onSetIsMixing(false);
    
    if (result.error) return;
    
    if (result.result) {
      // Check if element already exists
      const existing = elements.find(e => e.name.toLowerCase() === result.result!.toLowerCase()) ||
                      endElements.find(e => e.name.toLowerCase() === result.result!.toLowerCase());
      
      if (existing) {
        onShowUnlock({ ...existing, isNew: false });
        if (!existing.isEndElement) {
          onSetShakeElement(existing.id);
          setTimeout(() => {
            onShowUnlock(null);
            onSetShakeElement(null);
          }, 1500);
        } else {
          setTimeout(() => onShowUnlock(null), 1500);
        }
      } else {
        // Create new element
        const isEndElement = result.isEndElement || false;
        
        // Resolve OpenMoji for the new element
        const emojiTags = result.emojiTags || result.achievementTags || result.tags || [];
        const openmojiData = resolveEmoji({
          unicodeEmoji: result.emoji || '‚ú®',
          name: result.result,
          tags: emojiTags
        });
        
        const newElement: Element = {
          id: result.result.toLowerCase().replace(/\s+/g, '-'),
          name: result.result,
          emoji: result.emoji || '‚ú®',
          color: result.color || '#808080',
          unlockOrder: elements.length + endElements.length,
          rarity: result.rarity || 'common',
          reasoning: result.reasoning || '',
          achievementTags: result.achievementTags || [],
          emojiTags: result.emojiTags || [],
          tags: result.tags || [],
          isEndElement,
          parents: elementsToMix,
          energyEnhanced: hasEnergy && elementsToMix.length === 2,
          ...(openmojiData.isExtra && {
            openmojiHex: openmojiData.hexcode,
            isOpenmojiExtra: true
          })
        };
        
        // Add to appropriate collection
        if (isEndElement) {
          onPlaySound('end-element');
          addEndElement(newElement);
        } else {
          onPlaySound('reward');
          addElement(newElement);
          onSetPopElement(newElement.id);
        }
        
        // Check achievements
        let allAchievements: Achievement[] = [];
        let contextualAchievement = null;
        try {
          const updatedElements = isEndElement ? elements : [...elements, newElement];
          const updatedEndElements = isEndElement ? [...endElements, newElement] : endElements;
          
          allAchievements = checkAchievements(newElement, updatedElements, updatedEndElements, achievements, gameMode);
          contextualAchievement = allAchievements.find(a => a.id.startsWith('first-'));
          
          if (allAchievements.length > 0) {
            addAchievements(allAchievements);
          }
        } catch (error) {
          console.error('Achievement check failed:', error);
        }

        // Set up undo functionality
        const lastCombination: LastCombination = {
          createdElement: {
            element: newElement,
            isEndElement: isEndElement
          },
          combinationKey: mixKey,
          mixingAreaState: mixingAreaSnapshot, // Use the captured state from before mixing
          achievementsGained: allAchievements,
          endElementsGained: isEndElement ? [newElement] : [],
          timestamp: Date.now()
        };
        
        setLastCombination(lastCombination);
        setUndoAvailable(true);
        incrementTotalCombinations();

        // Save state immediately
        if (user && gameMode) {
          try {
            const supabase = createClient();
            const updatedElements = isEndElement ? elements : [...elements, newElement];
            const updatedEndElements = isEndElement ? [...endElements, newElement] : endElements;
            
            await saveGameState(supabase, user.id, {
              game_mode: gameMode,
              elements: updatedElements,
              end_elements: updatedEndElements,
              combinations: { ...combinations, [mixKey]: result.result },
              achievements: [...achievements, ...allAchievements],
              failed_combinations: failedCombinations
            });
          } catch (error) {
            console.error('Immediate save failed:', error);
          }
        }
        
        // Check challenge completion
        await checkChallengeCompletion(newElement);
        
        // Show unlock modal
        onShowUnlock({ 
          ...newElement, 
          isNew: true,
          achievement: contextualAchievement || null
        });
        onSetUnlockAnimationStartTime(Date.now());
        
        if (!isEndElement) {
          // Add new element to mixing area center
          const rect = dropZoneRef.current?.getBoundingClientRect();
          if (rect) {
            const offset = GameLogic.getElementSize() / 2;
            const centerX = rect.width / 2 - offset;
            const centerY = rect.height / 2 - offset;
            const newPos = GameLogic.resolveCollisions(centerX, centerY, mixingArea, dropZoneRef.current);
            
            const centerElement: MixingElement = {
              ...newElement,
              x: newPos.x,
              y: newPos.y,
              index: Date.now() + 1000,
              energized: false
            };
            
            addToMixingArea(centerElement);
          }
          
          setTimeout(() => {
            onShowUnlock(null);
            onSetPopElement(null);
            onSetUnlockAnimationStartTime(null);
          }, 3000);
        } else {
          setTimeout(() => {
            onShowUnlock(null);
            onSetUnlockAnimationStartTime(null);
          }, 3000);
        }
      }
      
      // Cache the result
      addCombination(mixKey, result.result);
    } else {
      // No reaction
      const reasoningText = result.reasoning || 'No reaction';
      onShowToast(reasoningText);
      addCombination(mixKey, null);
    }
  }, [
    setMixingArea, combinations, elements, endElements, generateCombination, onShowUnlock, 
    onSetShakeElement, onPlaySound, onSetPopElement, addEndElement, addElement, achievements, 
    addAchievements, setLastCombination, setUndoAvailable, incrementTotalCombinations, 
    user, gameMode, failedCombinations, checkChallengeCompletion, onSetUnlockAnimationStartTime,
    dropZoneRef, mixingArea, addCombination, onShowToast
  ]);

  return {
    mixElements,
    performMix
  };
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementMixing.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAnimations.ts ===== 
'use client';

import { useState, useCallback, useRef } from 'react';
import { Element, MixingElement } from './useGameState';

/**
 * Hook for managing game animations and visual feedback
 * Handles shake, pop, removal, and load animations
 */
export const useGameAnimations = () => {
  // Animation state
  const [shakeElement, setShakeElement] = useState<string | null>(null);
  const [popElement, setPopElement] = useState<string | null>(null);
  const [animatingElements, setAnimatingElements] = useState<Set<string>>(new Set());
  const isPlayingLoadAnimation = useRef<boolean>(false);
  const [animatedElements, setAnimatedElements] = useState<Set<string>>(new Set());
  
  // Timeout tracking for cleanup
  const animationTimeouts = useRef<Map<string, NodeJS.Timeout>>(new Map());

  // Clear existing timeout helper
  const clearExistingTimeout = useCallback((key: string) => {
    const existing = animationTimeouts.current.get(key);
    if (existing) {
      clearTimeout(existing);
      animationTimeouts.current.delete(key);
    }
  }, []);

  // Trigger shake animation on an element
  const triggerShake = useCallback((elementId: string) => {
    setShakeElement(elementId);
    
    // Clear any existing shake timeout for this element
    clearExistingTimeout(`shake-${elementId}`);
    
    // Set new timeout to clear shake
    const timeout = setTimeout(() => {
      setShakeElement(null);
    }, 500);
    
    animationTimeouts.current.set(`shake-${elementId}`, timeout);
  }, [clearExistingTimeout]);

  // Trigger pop animation on an element
  const triggerPop = useCallback((elementId: string) => {
    setPopElement(elementId);
    
    // Clear any existing pop timeout for this element
    clearExistingTimeout(`pop-${elementId}`);
    
    // Set new timeout to clear pop
    const timeout = setTimeout(() => {
      setPopElement(null);
    }, 300);
    
    animationTimeouts.current.set(`pop-${elementId}`, timeout);
  }, [clearExistingTimeout]);

  // Animate removal of elements from mixing area
  const animateRemoval = useCallback((elements: MixingElement[], onComplete: () => void) => {
    if (elements.length === 0) {
      onComplete();
      return;
    }
    
    // Stagger the removal animation for each element
    elements.forEach((el, index) => {
      const timeout = setTimeout(() => {
        setAnimatingElements(prev => new Set(prev).add(`${el.id}-${el.index}`));
      }, index * 50);
      
      animationTimeouts.current.set(`removal-${el.id}-${el.index}`, timeout);
    });
    
    // Complete the animation and call onComplete
    const totalDuration = elements.length * 50 + 300;
    const completeTimeout = setTimeout(() => {
      onComplete();
      setAnimatingElements(new Set());
    }, totalDuration);
    
    animationTimeouts.current.set('removal-complete', completeTimeout);
  }, []);

  // Play element load animation (for loading saved game state)
  const playElementLoadAnimation = useCallback((elementsToAnimate: Element[]) => {
    const elementsToAnimate_filtered = elementsToAnimate.filter(e => e.unlockOrder > 4);
    if (elementsToAnimate_filtered.length === 0 || isPlayingLoadAnimation.current) return;
    
    console.log('[LOAD_ANIMATION] Starting element load animation for', elementsToAnimate_filtered.length, 'elements');
    isPlayingLoadAnimation.current = true;
    
    // Sort elements by unlock order for proper animation sequence
    const sortedElements = [...elementsToAnimate_filtered].sort((a, b) => a.unlockOrder - b.unlockOrder);
    setAnimatedElements(new Set(sortedElements.map(e => e.id)));
    
    // Calculate total animation duration
    const totalDuration = (sortedElements.length * 25) + 300 + 200;
    
    // Clear existing load animation timeout
    clearExistingTimeout('load-animation');
    
    // Set timeout to complete load animation
    const timeout = setTimeout(() => {
      isPlayingLoadAnimation.current = false;
      setAnimatedElements(new Set());
    }, totalDuration);
    
    animationTimeouts.current.set('load-animation', timeout);
  }, [clearExistingTimeout]);

  // Clear all animations (useful for cleanup or mode switching)
  const clearAllAnimations = useCallback(() => {
    setShakeElement(null);
    setPopElement(null);
    setAnimatingElements(new Set());
    isPlayingLoadAnimation.current = false;
    setAnimatedElements(new Set());
    
    // Clear all timeouts
    animationTimeouts.current.forEach(timeout => clearTimeout(timeout));
    animationTimeouts.current.clear();
  }, []);

  // Check if an element is currently being animated
  const isElementAnimated = useCallback((elementId: string) => {
    return animatedElements.has(elementId);
  }, [animatedElements]);

  // Check if an element is in removal animation
  const isElementRemoving = useCallback((elementId: string, elementIndex?: number) => {
    const key = elementIndex !== undefined ? `${elementId}-${elementIndex}` : elementId;
    return animatingElements.has(key);
  }, [animatingElements]);

  return {
    // State
    shakeElement,
    popElement,
    animatingElements,
    isPlayingLoadAnimation: isPlayingLoadAnimation.current,
    animatedElements,
    
    // Actions
    triggerShake,
    triggerPop,
    animateRemoval,
    playElementLoadAnimation,
    clearAllAnimations,
    
    // Helpers
    isElementAnimated,
    isElementRemoving
  };
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAnimations.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAudio.ts ===== 
'use client';

import { useRef, useEffect, useCallback } from 'react';

// Type for window.webkitAudioContext
interface WindowWithWebkit extends Window {
  webkitAudioContext?: typeof AudioContext;
}

export type SoundType = 'plop' | 'pop' | 'reward' | 'end-element' | 'press' | 'click' | 'reverse-pop';

/**
 * Hook for managing Web Audio API sound effects
 * Uses oscillator-based sounds for game interactions
 */
export const useGameAudio = () => {
  const audioContext = useRef<AudioContext | null>(null);

  // Initialize Web Audio API
  useEffect(() => {
    audioContext.current = new (window.AudioContext || (window as WindowWithWebkit).webkitAudioContext!)();
  }, []);

  const playSound = useCallback((type: SoundType) => {
    if (!audioContext.current) return;
    
    const osc = audioContext.current.createOscillator();
    const gainNode = audioContext.current.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioContext.current.destination);
    
    const now = audioContext.current.currentTime;
    
    switch(type) {
      case 'plop':
        // Element dropped into mixing area
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
        
      case 'pop':
        // Element interaction or mixing success
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
        gainNode.gain.setValueAtTime(0.4, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
        
      case 'reward':
        // Achievement or milestone reached
        osc.frequency.setValueAtTime(523.25, now);
        osc.frequency.setValueAtTime(659.25, now + 0.1);
        osc.frequency.setValueAtTime(783.99, now + 0.2);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
        break;
        
      case 'end-element':
        // Discovery of an end element (science mode)
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554.37, now + 0.15);
        osc.frequency.setValueAtTime(659.25, now + 0.3);
        gainNode.gain.setValueAtTime(0.35, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
        break;
        
      case 'press':
        // Element pressed down (drag start)
        osc.frequency.setValueAtTime(200, now);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
        
      case 'click':
        // Button clicks and UI interactions
        osc.frequency.setValueAtTime(1000, now);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
        osc.start(now);
        osc.stop(now + 0.03);
        break;
        
      case 'reverse-pop':
        // Undo operation
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);
        gainNode.gain.setValueAtTime(0.4, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
    }
  }, []);

  return {
    playSound
  };
};
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAudio.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.test.ts ===== 
import { describe, it, expect } from 'vitest';
import { GameState, GameAction, Element, MixingElement } from './useGameState';

// Initial state factory (copied from the main file)
const createInitialState = (gameMode: 'science' | 'creative' = 'science'): GameState => {
  const baseElements = gameMode === 'creative' 
    ? [
        { id: 'life', name: 'Life', emoji: 'üß¨', color: '#32CD32', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: 'üåç', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: 'üí®', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: 'üî•', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: 'üíß', color: '#4682B4', unlockOrder: 4 },
      ]
    : [
        { id: 'energy', name: 'Energy', emoji: '„Ä∞Ô∏è', color: '#FFD700', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: 'üåç', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: 'üí®', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: 'üî•', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: 'üíß', color: '#4682B4', unlockOrder: 4 },
      ];

  return {
    elements: baseElements,
    endElements: [],
    combinations: {},
    gameMode,
    mixingArea: [],
    achievements: [],
    failedCombinations: [],
    dimmedElements: new Set<string>(),
    animatingElements: new Set<string>(),
    isUndoing: false,
    isMixing: false,
    isDragging: false,
    hoveredElement: null,
    touchDragging: null,
    touchOffset: { x: 0, y: 0 },
    lastCombination: null,
    undoAvailable: false,
    totalCombinationsMade: 0,
    isStateRestored: false,
  };
};

// Import the reducer function directly for testing
function gameStateReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'SET_GAME_MODE':
      return createInitialState(action.payload);

    case 'SET_ELEMENTS':
      return { ...state, elements: action.payload };

    case 'ADD_ELEMENT':
      return { 
        ...state, 
        elements: [...state.elements, action.payload] 
      };

    case 'SET_COMBINATIONS':
      return { ...state, combinations: action.payload };

    case 'ADD_COMBINATION':
      return { 
        ...state, 
        combinations: { 
          ...state.combinations, 
          [action.payload.key]: action.payload.result 
        } 
      };

    case 'SET_MIXING_AREA':
      return { ...state, mixingArea: action.payload };

    case 'ADD_TO_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: [...state.mixingArea, action.payload] 
      };

    case 'REMOVE_FROM_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: state.mixingArea.filter((el: MixingElement) => !action.payload.includes(el.index)) 
      };

    case 'UPDATE_MIXING_ELEMENT':
      return {
        ...state,
        mixingArea: state.mixingArea.map((el: MixingElement) => 
          el.index === action.payload.index 
            ? { ...el, ...action.payload.updates }
            : el
        )
      };

    case 'CLEAR_MIXING_AREA':
      return { ...state, mixingArea: [] };

    case 'SET_ACHIEVEMENTS':
      return { ...state, achievements: action.payload };

    case 'ADD_ACHIEVEMENTS':
      return { 
        ...state, 
        achievements: [...state.achievements, ...action.payload] 
      };

    case 'SET_FAILED_COMBINATIONS':
      return { ...state, failedCombinations: action.payload };

    case 'ADD_FAILED_COMBINATION':
      return { 
        ...state, 
        failedCombinations: [...state.failedCombinations.slice(-4), action.payload] 
      };

    case 'SET_LAST_COMBINATION':
      return { ...state, lastCombination: action.payload };

    case 'SET_UNDO_AVAILABLE':
      return { ...state, undoAvailable: action.payload };

    case 'INCREMENT_TOTAL_COMBINATIONS':
      return { ...state, totalCombinationsMade: state.totalCombinationsMade + 1 };

    case 'SET_STATE_RESTORED':
      return { ...state, isStateRestored: action.payload };

    case 'LOAD_SAVED_STATE':
      return { ...state, ...action.payload };

    case 'RESET_GAME_STATE':
      return createInitialState(action.payload.gameMode);

    default:
      return state;
  }
}

// Test data
const testElement: Element = {
  id: 'steam',
  name: 'Steam',
  emoji: 'üí®',
  color: '#E0E0E0',
  unlockOrder: 5
};

const testMixingElement: MixingElement = {
  ...testElement,
  x: 100,
  y: 100,
  index: 12345,
  energized: false
};

describe('Game State Reducer', () => {
  describe('ADD_ELEMENT', () => {
    it('should add a new element to the elements array', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_ELEMENT',
        payload: testElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.elements).toHaveLength(6); // 5 base + 1 new
      expect(result.elements).toContain(testElement);
      expect(result.elements[5]).toEqual(testElement);
    });

    it('should not modify other state properties', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_ELEMENT',
        payload: testElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.mixingArea).toEqual(initialState.mixingArea);
      expect(result.combinations).toEqual(initialState.combinations);
      expect(result.gameMode).toEqual(initialState.gameMode);
    });
  });

  describe('SET_GAME_MODE', () => {
    it('should switch from science to creative mode with correct base elements', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'SET_GAME_MODE',
        payload: 'creative'
      };

      const result = gameStateReducer(initialState, action);

      expect(result.gameMode).toBe('creative');
      expect(result.elements).toHaveLength(5);
      expect(result.elements[0].name).toBe('Life'); // Creative mode starts with Life
      expect(result.elements.find((e: Element) => e.name === 'Energy')).toBeUndefined(); // No Energy in creative
    });

    it('should reset all state when switching modes', () => {
      const stateWithProgress = {
        ...createInitialState('science'),
        elements: [...createInitialState('science').elements, testElement],
        mixingArea: [testMixingElement],
        combinations: { 'fire+water': 'steam' }
      };

      const action: GameAction = {
        type: 'SET_GAME_MODE',
        payload: 'creative'
      };

      const result = gameStateReducer(stateWithProgress, action);

      expect(result.elements).toHaveLength(5); // Back to base elements
      expect(result.mixingArea).toHaveLength(0); // Cleared
      expect(result.combinations).toEqual({}); // Cleared
    });
  });

  describe('ADD_TO_MIXING_AREA', () => {
    it('should add element to mixing area', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_TO_MIXING_AREA',
        payload: testMixingElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.mixingArea).toHaveLength(1);
      expect(result.mixingArea[0]).toEqual(testMixingElement);
    });

    it('should allow multiple elements in mixing area', () => {
      const initialState = createInitialState('science');
      
      const firstAdd = gameStateReducer(initialState, {
        type: 'ADD_TO_MIXING_AREA',
        payload: testMixingElement
      });

      const secondElement = { ...testMixingElement, id: 'water', index: 54321 };
      const secondAdd = gameStateReducer(firstAdd, {
        type: 'ADD_TO_MIXING_AREA',
        payload: secondElement
      });

      expect(secondAdd.mixingArea).toHaveLength(2);
      expect(secondAdd.mixingArea[1]).toEqual(secondElement);
    });
  });

  describe('CLEAR_MIXING_AREA', () => {
    it('should remove all elements from mixing area', () => {
      const stateWithMixing = {
        ...createInitialState('science'),
        mixingArea: [testMixingElement, { ...testMixingElement, index: 99999 }]
      };

      const action: GameAction = { type: 'CLEAR_MIXING_AREA' };
      const result = gameStateReducer(stateWithMixing, action);

      expect(result.mixingArea).toHaveLength(0);
      expect(result.mixingArea).toEqual([]);
    });
  });

  describe('ADD_COMBINATION', () => {
    it('should add successful combination to combinations record', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_COMBINATION',
        payload: { key: 'fire+water', result: 'steam' }
      };

      const result = gameStateReducer(initialState, action);

      expect(result.combinations['fire+water']).toBe('steam');
      expect(Object.keys(result.combinations)).toHaveLength(1);
    });

    it('should preserve existing combinations when adding new ones', () => {
      const stateWithCombinations = {
        ...createInitialState('science'),
        combinations: { 'earth+water': 'mud' }
      };

      const action: GameAction = {
        type: 'ADD_COMBINATION',
        payload: { key: 'fire+water', result: 'steam' }
      };

      const result = gameStateReducer(stateWithCombinations, action);

      expect(result.combinations['earth+water']).toBe('mud');
      expect(result.combinations['fire+water']).toBe('steam');
      expect(Object.keys(result.combinations)).toHaveLength(2);
    });
  });

  describe('LOAD_SAVED_STATE', () => {
    it('should merge saved state with existing state', () => {
      const initialState = createInitialState('science');
      const savedElements = [
        ...initialState.elements,
        testElement
      ];

      const action: GameAction = {
        type: 'LOAD_SAVED_STATE',
        payload: {
          elements: savedElements,
          combinations: { 'fire+water': 'steam' }
        }
      };

      const result = gameStateReducer(initialState, action);

      expect(result.elements).toEqual(savedElements);
      expect(result.combinations['fire+water']).toBe('steam');
      expect(result.gameMode).toBe('science'); // Should preserve existing game mode
    });
  });

  describe('INCREMENT_TOTAL_COMBINATIONS', () => {
    it('should increment the total combinations counter', () => {
      const initialState = createInitialState('science');
      const action: GameAction = { type: 'INCREMENT_TOTAL_COMBINATIONS' };

      const result = gameStateReducer(initialState, action);

      expect(result.totalCombinationsMade).toBe(1);
      expect(initialState.totalCombinationsMade).toBe(0); // Original unchanged
    });

    it('should increment from existing count', () => {
      const stateWithCount = {
        ...createInitialState('science'),
        totalCombinationsMade: 5
      };

      const action: GameAction = { type: 'INCREMENT_TOTAL_COMBINATIONS' };
      const result = gameStateReducer(stateWithCount, action);

      expect(result.totalCombinationsMade).toBe(6);
    });
  });
});
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.test.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.ts ===== 
import { useReducer, useCallback } from 'react';
import type { Element, Achievement } from '@/types/game.types';

// Re-export types for other hooks
export type { Element, Achievement };

export interface MixingElement extends Element {
  x: number;
  y: number;
  index: number;
  energized: boolean;
  fromMixingArea?: boolean;
  mixIndex?: number | null;
}

export interface LastCombination {
  createdElement: {
    element: Element;
    isEndElement: boolean;
  };
  combinationKey: string;
  mixingAreaState: MixingElement[];
  achievementsGained: Achievement[];
  endElementsGained: Element[];
  timestamp: number;
}

// Core game state (domain/persistent data only)
export interface GameState {
  // Core game data
  elements: Element[];
  endElements: Element[];
  combinations: Record<string, string | null>;
  gameMode: 'science' | 'creative';
  
  // Game logic state
  mixingArea: MixingElement[];
  achievements: Achievement[];
  failedCombinations: string[];
  
  // UI interaction state
  dimmedElements: Set<string>;
  animatingElements: Set<string>;
  isUndoing: boolean;
  isMixing: boolean;
  isDragging: boolean;
  hoveredElement: number | null;
  touchDragging: MixingElement | null;
  touchOffset: { x: number; y: number };
  
  // Undo/redo functionality
  lastCombination: LastCombination | null;
  undoAvailable: boolean;
  totalCombinationsMade: number;
  
  // State restoration tracking
  isStateRestored: boolean;
}

// Action types for the reducer
export type GameAction =
  | { type: 'SET_GAME_MODE'; payload: 'science' | 'creative' }
  | { type: 'SET_ELEMENTS'; payload: Element[] }
  | { type: 'ADD_ELEMENT'; payload: Element }
  | { type: 'SET_END_ELEMENTS'; payload: Element[] }
  | { type: 'ADD_END_ELEMENT'; payload: Element }
  | { type: 'SET_COMBINATIONS'; payload: Record<string, string | null> }
  | { type: 'ADD_COMBINATION'; payload: { key: string; result: string | null } }
  | { type: 'SET_MIXING_AREA'; payload: MixingElement[] }
  | { type: 'ADD_TO_MIXING_AREA'; payload: MixingElement }
  | { type: 'REMOVE_FROM_MIXING_AREA'; payload: number[] }
  | { type: 'UPDATE_MIXING_ELEMENT'; payload: { index: number; updates: Partial<MixingElement> } }
  | { type: 'CLEAR_MIXING_AREA' }
  | { type: 'SET_ACHIEVEMENTS'; payload: Achievement[] }
  | { type: 'ADD_ACHIEVEMENTS'; payload: Achievement[] }
  | { type: 'SET_FAILED_COMBINATIONS'; payload: string[] }
  | { type: 'ADD_FAILED_COMBINATION'; payload: string }
  | { type: 'SET_DIMMED_ELEMENTS'; payload: Set<string> }
  | { type: 'ADD_DIMMED_ELEMENT'; payload: string }
  | { type: 'REMOVE_DIMMED_ELEMENT'; payload: string }
  | { type: 'CLEAR_DIMMED_ELEMENTS' }
  | { type: 'SET_ANIMATING_ELEMENTS'; payload: Set<string> }
  | { type: 'ADD_ANIMATING_ELEMENT'; payload: string }
  | { type: 'REMOVE_ANIMATING_ELEMENT'; payload: string }
  | { type: 'CLEAR_ANIMATING_ELEMENTS' }
  | { type: 'SET_IS_UNDOING'; payload: boolean }
  | { type: 'SET_IS_MIXING'; payload: boolean }
  | { type: 'SET_IS_DRAGGING'; payload: boolean }
  | { type: 'SET_HOVERED_ELEMENT'; payload: number | null }
  | { type: 'SET_TOUCH_DRAGGING'; payload: MixingElement | null }
  | { type: 'SET_TOUCH_OFFSET'; payload: { x: number; y: number } }
  | { type: 'SET_LAST_COMBINATION'; payload: LastCombination | null }
  | { type: 'SET_UNDO_AVAILABLE'; payload: boolean }
  | { type: 'INCREMENT_TOTAL_COMBINATIONS' }
  | { type: 'SET_STATE_RESTORED'; payload: boolean }
  | { type: 'LOAD_SAVED_STATE'; payload: Partial<GameState> }
  | { type: 'RESET_GAME_STATE'; payload: { gameMode: 'science' | 'creative' } };

// Initial state factory
const createInitialState = (gameMode: 'science' | 'creative' = 'science'): GameState => {
  const baseElements = gameMode === 'creative' 
    ? [
        { id: 'life', name: 'Life', emoji: 'üß¨', color: '#32CD32', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: 'üåç', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: 'üí®', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: 'üî•', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: 'üíß', color: '#4682B4', unlockOrder: 4 },
      ]
    : [
        { id: 'energy', name: 'Energy', emoji: '„Ä∞Ô∏è', color: '#FFD700', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: 'üåç', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: 'üí®', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: 'üî•', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: 'üíß', color: '#4682B4', unlockOrder: 4 },
      ];

  return {
    elements: baseElements,
    endElements: [],
    combinations: {},
    gameMode,
    mixingArea: [],
    achievements: [],
    failedCombinations: [],
    dimmedElements: new Set<string>(),
    animatingElements: new Set<string>(),
    isUndoing: false,
    isMixing: false,
    isDragging: false,
    hoveredElement: null,
    touchDragging: null,
    touchOffset: { x: 0, y: 0 },
    lastCombination: null,
    undoAvailable: false,
    totalCombinationsMade: 0,
    isStateRestored: false,
  };
};

// Game state reducer
function gameStateReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'SET_GAME_MODE':
      // When mode changes, reset to base elements for that mode
      return createInitialState(action.payload);

    case 'SET_ELEMENTS':
      return { ...state, elements: action.payload };

    case 'ADD_ELEMENT':
      return { 
        ...state, 
        elements: [...state.elements, action.payload] 
      };

    case 'SET_END_ELEMENTS':
      return { ...state, endElements: action.payload };

    case 'ADD_END_ELEMENT':
      return { 
        ...state, 
        endElements: [...state.endElements, action.payload] 
      };

    case 'SET_COMBINATIONS':
      return { ...state, combinations: action.payload };

    case 'ADD_COMBINATION':
      return { 
        ...state, 
        combinations: { 
          ...state.combinations, 
          [action.payload.key]: action.payload.result 
        } 
      };

    case 'SET_MIXING_AREA':
      return { ...state, mixingArea: action.payload };

    case 'ADD_TO_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: [...state.mixingArea, action.payload] 
      };

    case 'REMOVE_FROM_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: state.mixingArea.filter(el => !action.payload.includes(el.index)) 
      };

    case 'UPDATE_MIXING_ELEMENT':
      return {
        ...state,
        mixingArea: state.mixingArea.map(el => 
          el.index === action.payload.index 
            ? { ...el, ...action.payload.updates }
            : el
        )
      };

    case 'CLEAR_MIXING_AREA':
      return { ...state, mixingArea: [] };

    case 'SET_ACHIEVEMENTS':
      return { ...state, achievements: action.payload };

    case 'ADD_ACHIEVEMENTS':
      return { 
        ...state, 
        achievements: [...state.achievements, ...action.payload] 
      };

    case 'SET_FAILED_COMBINATIONS':
      return { ...state, failedCombinations: action.payload };

    case 'ADD_FAILED_COMBINATION':
      return { 
        ...state, 
        failedCombinations: [...state.failedCombinations.slice(-4), action.payload] 
      };

    case 'SET_DIMMED_ELEMENTS':
      return { ...state, dimmedElements: action.payload };

    case 'ADD_DIMMED_ELEMENT':
      return { 
        ...state, 
        dimmedElements: new Set([...state.dimmedElements, action.payload])
      };

    case 'REMOVE_DIMMED_ELEMENT':
      const newDimmedElements = new Set(state.dimmedElements);
      newDimmedElements.delete(action.payload);
      return { ...state, dimmedElements: newDimmedElements };

    case 'CLEAR_DIMMED_ELEMENTS':
      return { ...state, dimmedElements: new Set<string>() };

    case 'SET_ANIMATING_ELEMENTS':
      return { ...state, animatingElements: action.payload };

    case 'ADD_ANIMATING_ELEMENT':
      return { 
        ...state, 
        animatingElements: new Set([...state.animatingElements, action.payload])
      };

    case 'REMOVE_ANIMATING_ELEMENT':
      const newAnimatingElements = new Set(state.animatingElements);
      newAnimatingElements.delete(action.payload);
      return { ...state, animatingElements: newAnimatingElements };

    case 'CLEAR_ANIMATING_ELEMENTS':
      return { ...state, animatingElements: new Set<string>() };

    case 'SET_IS_UNDOING':
      return { ...state, isUndoing: action.payload };

    case 'SET_IS_MIXING':
      return { ...state, isMixing: action.payload };

    case 'SET_IS_DRAGGING':
      return { ...state, isDragging: action.payload };

    case 'SET_HOVERED_ELEMENT':
      return { ...state, hoveredElement: action.payload };

    case 'SET_TOUCH_DRAGGING':
      return { ...state, touchDragging: action.payload };

    case 'SET_TOUCH_OFFSET':
      return { ...state, touchOffset: action.payload };

    case 'SET_LAST_COMBINATION':
      return { ...state, lastCombination: action.payload };

    case 'SET_UNDO_AVAILABLE':
      return { ...state, undoAvailable: action.payload };

    case 'INCREMENT_TOTAL_COMBINATIONS':
      return { ...state, totalCombinationsMade: state.totalCombinationsMade + 1 };

    case 'SET_STATE_RESTORED':
      return { ...state, isStateRestored: action.payload };

    case 'LOAD_SAVED_STATE':
      return { ...state, ...action.payload };

    case 'RESET_GAME_STATE':
      return createInitialState(action.payload.gameMode);

    default:
      return state;
  }
}

// Custom hook for game state management
export function useGameState(initialGameMode: 'science' | 'creative' = 'science') {
  const [state, dispatch] = useReducer(
    gameStateReducer,
    createInitialState(initialGameMode)
  );

  // Action creators for easier dispatch calls
  const actions = {
    setGameMode: useCallback((mode: 'science' | 'creative') => {
      dispatch({ type: 'SET_GAME_MODE', payload: mode });
    }, []),

    setElements: useCallback((elements: Element[]) => {
      dispatch({ type: 'SET_ELEMENTS', payload: elements });
    }, []),

    addElement: useCallback((element: Element) => {
      dispatch({ type: 'ADD_ELEMENT', payload: element });
    }, []),

    setEndElements: useCallback((endElements: Element[]) => {
      dispatch({ type: 'SET_END_ELEMENTS', payload: endElements });
    }, []),

    addEndElement: useCallback((element: Element) => {
      dispatch({ type: 'ADD_END_ELEMENT', payload: element });
    }, []),

    setCombinations: useCallback((combinations: Record<string, string | null>) => {
      dispatch({ type: 'SET_COMBINATIONS', payload: combinations });
    }, []),

    addCombination: useCallback((key: string, result: string | null) => {
      dispatch({ type: 'ADD_COMBINATION', payload: { key, result } });
    }, []),

    setMixingArea: useCallback((mixingArea: MixingElement[]) => {
      dispatch({ type: 'SET_MIXING_AREA', payload: mixingArea });
    }, []),

    addToMixingArea: useCallback((element: MixingElement) => {
      dispatch({ type: 'ADD_TO_MIXING_AREA', payload: element });
    }, []),

    removeFromMixingArea: useCallback((indices: number[]) => {
      dispatch({ type: 'REMOVE_FROM_MIXING_AREA', payload: indices });
    }, []),

    updateMixingElement: useCallback((index: number, updates: Partial<MixingElement>) => {
      dispatch({ type: 'UPDATE_MIXING_ELEMENT', payload: { index, updates } });
    }, []),

    clearMixingArea: useCallback(() => {
      dispatch({ type: 'CLEAR_MIXING_AREA' });
    }, []),

    setAchievements: useCallback((achievements: Achievement[]) => {
      dispatch({ type: 'SET_ACHIEVEMENTS', payload: achievements });
    }, []),

    addAchievements: useCallback((achievements: Achievement[]) => {
      dispatch({ type: 'ADD_ACHIEVEMENTS', payload: achievements });
    }, []),

    setFailedCombinations: useCallback((failedCombinations: string[]) => {
      dispatch({ type: 'SET_FAILED_COMBINATIONS', payload: failedCombinations });
    }, []),

    addFailedCombination: useCallback((combination: string) => {
      dispatch({ type: 'ADD_FAILED_COMBINATION', payload: combination });
    }, []),

    setDimmedElements: useCallback((dimmedElements: Set<string>) => {
      dispatch({ type: 'SET_DIMMED_ELEMENTS', payload: dimmedElements });
    }, []),

    addDimmedElement: useCallback((elementName: string) => {
      dispatch({ type: 'ADD_DIMMED_ELEMENT', payload: elementName });
    }, []),

    removeDimmedElement: useCallback((elementName: string) => {
      dispatch({ type: 'REMOVE_DIMMED_ELEMENT', payload: elementName });
    }, []),

    clearDimmedElements: useCallback(() => {
      dispatch({ type: 'CLEAR_DIMMED_ELEMENTS' });
    }, []),

    setAnimatingElements: useCallback((animatingElements: Set<string>) => {
      dispatch({ type: 'SET_ANIMATING_ELEMENTS', payload: animatingElements });
    }, []),

    addAnimatingElement: useCallback((elementName: string) => {
      dispatch({ type: 'ADD_ANIMATING_ELEMENT', payload: elementName });
    }, []),

    removeAnimatingElement: useCallback((elementName: string) => {
      dispatch({ type: 'REMOVE_ANIMATING_ELEMENT', payload: elementName });
    }, []),

    clearAnimatingElements: useCallback(() => {
      dispatch({ type: 'CLEAR_ANIMATING_ELEMENTS' });
    }, []),

    setIsUndoing: useCallback((isUndoing: boolean) => {
      dispatch({ type: 'SET_IS_UNDOING', payload: isUndoing });
    }, []),

    setIsMixing: useCallback((isMixing: boolean) => {
      dispatch({ type: 'SET_IS_MIXING', payload: isMixing });
    }, []),

    setIsDragging: useCallback((isDragging: boolean) => {
      dispatch({ type: 'SET_IS_DRAGGING', payload: isDragging });
    }, []),

    setHoveredElement: useCallback((elementIndex: number | null) => {
      dispatch({ type: 'SET_HOVERED_ELEMENT', payload: elementIndex });
    }, []),

    setTouchDragging: useCallback((element: MixingElement | null) => {
      dispatch({ type: 'SET_TOUCH_DRAGGING', payload: element });
    }, []),

    setTouchOffset: useCallback((offset: { x: number; y: number }) => {
      dispatch({ type: 'SET_TOUCH_OFFSET', payload: offset });
    }, []),

    setLastCombination: useCallback((combination: LastCombination | null) => {
      dispatch({ type: 'SET_LAST_COMBINATION', payload: combination });
    }, []),

    setUndoAvailable: useCallback((available: boolean) => {
      dispatch({ type: 'SET_UNDO_AVAILABLE', payload: available });
    }, []),

    incrementTotalCombinations: useCallback(() => {
      dispatch({ type: 'INCREMENT_TOTAL_COMBINATIONS' });
    }, []),

    setStateRestored: useCallback((restored: boolean) => {
      dispatch({ type: 'SET_STATE_RESTORED', payload: restored });
    }, []),

    loadSavedState: useCallback((savedState: Partial<GameState>) => {
      dispatch({ type: 'LOAD_SAVED_STATE', payload: savedState });
    }, []),

    resetGameState: useCallback((gameMode: 'science' | 'creative') => {
      dispatch({ type: 'RESET_GAME_STATE', payload: { gameMode } });
    }, []),
  };

  return {
    state,
    dispatch,
    actions,
  };
}
 
===== END: C:\ai\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\achievements.ts ===== 
// Achievement system for LLM Alchemy
// Extracted from LLMAlchemy.tsx for better code organization

import { Achievement, Element } from '@/types';

// Tiered achievement configuration - easy to extend
interface TieredAchievementConfig {
  id: string;
  name: string;
  description: string;
  emoji: string;
  countType: string;
  tiers: [number, number, number]; // Bronze, Silver, Gold
  tags?: string[]; // Tags to count for this achievement
}

const TIERED_ACHIEVEMENTS: TieredAchievementConfig[] = [
  {
    id: 'danger-zone',
    name: 'Danger Zone',
    description: 'Create dangerous elements',
    emoji: '‚ö†Ô∏è',
    countType: 'danger',
    tiers: [5, 25, 100],
    tags: ['danger', 'catastrophe', 'toxic', 'explosive', 'corrosive', 'radioactive', 'unstable']
  },
  {
    id: 'advanced-metallurgist',
    name: 'Metallurgist',
    description: 'Discover metals',
    emoji: '‚öíÔ∏è',
    countType: 'metal',
    tiers: [10, 30, 75],
    tags: ['metal']
  },
  {
    id: 'life-finds-a-way',
    name: 'Life Finds a Way',
    description: 'Discover organisms',
    emoji: 'üß¨',
    countType: 'life',
    tiers: [15, 50, 150],
    tags: ['plant', 'animal', 'organism']
  },
  {
    id: 'element-master',
    name: 'Element Master',
    description: 'Discover elements',
    emoji: 'üíØ',
    countType: 'total',
    tiers: [10, 50, 100]
  }
];

/**
 * Calculate current count for a specific achievement type
 */
function calculateAchievementCount(
  countType: string,
  allElements: Element[],
  allEndElements: Element[],
  tags?: string[]
): number {
  const allDiscoveredElements = [...allElements, ...allEndElements];
  
  if (countType === 'total') {
    return allDiscoveredElements.length;
  }
  
  if (tags) {
    return allDiscoveredElements.filter(e => {
      // Check achievementTags first, then fall back to tags for backwards compatibility
      const elementTags = e.achievementTags || e.tags || [];
      return elementTags.some(tag => tags.includes(tag));
    }).length;
  }
  
  return 0;
}

/**
 * Get tier information for a current count
 */
function getTierInfo(count: number, tiers: [number, number, number]): {
  tier: 1 | 2 | 3 | null;
  nextTierAt: number | null;
} {
  if (count >= tiers[2]) return { tier: 3, nextTierAt: null }; // Gold
  if (count >= tiers[1]) return { tier: 2, nextTierAt: tiers[2] }; // Silver
  if (count >= tiers[0]) return { tier: 1, nextTierAt: tiers[1] }; // Bronze
  return { tier: null, nextTierAt: tiers[0] };
}

/**
 * Update existing achievements with current progress information
 */
export function updateAchievementsWithProgress(
  achievements: Achievement[],
  allElements: Element[],
  allEndElements: Element[]
): Achievement[] {
  return achievements.map(achievement => {
    // Find if this achievement is tiered
    const tieredConfig = TIERED_ACHIEVEMENTS.find(config => config.id === achievement.id);
    
    if (!tieredConfig) {
      return achievement; // Not a tiered achievement
    }
    
    // Calculate current count
    const currentCount = calculateAchievementCount(
      tieredConfig.countType,
      allElements,
      allEndElements,
      tieredConfig.tags
    );
    
    // Get tier information
    const { tier, nextTierAt } = getTierInfo(currentCount, tieredConfig.tiers);
    
    return {
      ...achievement,
      isProgressive: true,
      countType: tieredConfig.countType,
      tier: tier || 1, // Default to bronze if unlocked
      currentCount,
      nextTierAt
    };
  });
}

/**
 * Check for new achievements based on a newly discovered element
 * @param newElement The element that was just discovered
 * @param allElements Array of all discovered regular elements
 * @param allEndElements Array of all discovered end elements
 * @param existingAchievements Array of already unlocked achievements
 * @param gameMode Current game mode ('science' or 'creative')
 * @returns Array of newly unlocked achievements
 */
export function checkAchievements(
  newElement: Element,
  allElements: Element[],
  allEndElements: Element[],
  existingAchievements: Achievement[],
  gameMode: 'science' | 'creative'
): Achievement[] {
  const newAchievements: Achievement[] = [];
  
  try {
    // Tag-based achievement detection
    const newElementTags = newElement.achievementTags || newElement.tags || [];
    if (newElementTags.length > 0) {
      for (const tag of newElementTags) {
        let achievementId: string | null = null;
        let achievementName: string = '';
        let achievementDescription: string = '';
        let achievementEmoji: string = 'üèÜ';
        
        // Check if this is the first element with this tag
        const hasExistingWithTag = [...allElements, ...allEndElements]
          .filter(e => e.id !== newElement.id)
          .some(e => {
            const elementTags = e.achievementTags || e.tags || [];
            return elementTags.includes(tag);
          });
        
        if (!hasExistingWithTag) {
          // Map tags to achievements based on game mode
          if (gameMode === 'creative') {
            switch (tag) {
              case 'food':
                achievementId = 'first-food';
                achievementName = 'Edible Elements';
                achievementDescription = 'Created your first food item';
                achievementEmoji = 'üçé';
                break;
              case 'lifeform':
              case 'creature':
              case 'animal':
                achievementId = 'first-lifeform';
                achievementName = 'First Lifeform!';
                achievementDescription = 'Brought life into existence';
                achievementEmoji = 'üß¨';
                break;
              case 'metal':
                achievementId = 'first-metal';
                achievementName = 'Metalworker';
                achievementDescription = 'Forged your first metal';
                achievementEmoji = '‚öíÔ∏è';
                break;
              case 'tool':
                achievementId = 'first-tool';
                achievementName = 'Tool Maker';
                achievementDescription = 'Crafted your first tool';
                achievementEmoji = 'üî®';
                break;
              case 'fictional-character':
              case 'character':
                achievementId = 'first-character';
                achievementName = 'Fictional Hero';
                achievementDescription = 'Summoned a legendary being';
                achievementEmoji = 'ü¶∏';
                break;
              case 'disaster':
                achievementId = 'first-disaster';
                achievementName = 'Chaos Alchemist';
                achievementDescription = 'Unleashed destructive forces';
                achievementEmoji = 'üí•';
                break;
            }
          } else { // Science mode
            switch (tag) {
              case 'lifeform':
              case 'organism':
              case 'microorganism':
                achievementId = 'first-lifeform';
                achievementName = 'Genesis';
                achievementDescription = 'Created the first living organism';
                achievementEmoji = 'üß¨';
                break;
              case 'mineral':
              case 'compound':
                achievementId = 'first-mineral';
                achievementName = 'Geologist';
                achievementDescription = 'Discovered your first mineral compound';
                achievementEmoji = 'üíé';
                break;
              case 'metal':
                achievementId = 'first-metal';
                achievementName = 'Metallurgist';
                achievementDescription = 'Refined your first metal';
                achievementEmoji = '‚öíÔ∏è';
                break;
              case 'plant':
                achievementId = 'first-plant';
                achievementName = 'Botanist';
                achievementDescription = 'Cultivated plant life';
                achievementEmoji = 'üå±';
                break;
            }
          }
          
          // Add the achievement if we found a match and don't already have it
          if (achievementId && !existingAchievements.find(a => a.id === achievementId)) {
            newAchievements.push({
              id: achievementId,
              name: achievementName,
              description: achievementDescription,
              emoji: achievementEmoji,
              unlocked: Date.now()
            });
          }
        }
      }
    }
    
    // Milestone achievements using passed arrays
    const totalElements = allElements.length + allEndElements.length;
    
    // 10 elements achievement
    if (totalElements >= 10 && !existingAchievements.find(a => a.id === 'alchemist-apprentice')) {
      newAchievements.push({
        id: 'alchemist-apprentice',
        name: 'Alchemist Apprentice',
        description: 'Discovered 10 elements',
        emoji: 'üéì',
        unlocked: Date.now()
      });
    }
    
    // 50 elements achievement
    if (totalElements >= 50 && !existingAchievements.find(a => a.id === 'skilled-alchemist')) {
      newAchievements.push({
        id: 'skilled-alchemist',
        name: 'Skilled Alchemist',
        description: 'Discovered 50 elements',
        emoji: 'üßô',
        unlocked: Date.now()
      });
    }
    
    // 100 elements achievement
    if (totalElements >= 100 && !existingAchievements.find(a => a.id === 'century-club')) {
      newAchievements.push({
        id: 'century-club',
        name: 'Century Club',
        description: 'Discovered 100 elements',
        emoji: 'üíØ',
        unlocked: Date.now()
      });
    }
    
    // End element achievements (Science mode only)
    if (gameMode === 'science') {
      if (allEndElements.length >= 1 && !existingAchievements.find(a => a.id === 'dead-end')) {
        newAchievements.push({
          id: 'dead-end',
          name: 'End of Branch',
          description: 'Discovered your first End Element',
          emoji: 'üîö',
          unlocked: Date.now()
        });
      }
      
      if (allEndElements.length >= 10 && !existingAchievements.find(a => a.id === 'end-collector')) {
        newAchievements.push({
          id: 'end-collector',
          name: 'End Collector',
          description: 'Collected 10 End Elements',
          emoji: 'üèÅ',
          unlocked: Date.now()
        });
      }
      
      // Advanced Science Mode Achievements
      const allDiscoveredElements = [...allElements, ...allEndElements];
      
      // Master of States: 5 elements in each state of matter
      if (!existingAchievements.find(a => a.id === 'master-of-states')) {
        const solidElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.includes('solid');
        });
        const liquidElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.includes('liquid');
        });
        const gasElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.includes('gas');
        });
        
        if (solidElements.length >= 5 && liquidElements.length >= 5 && gasElements.length >= 5) {
          newAchievements.push({
            id: 'master-of-states',
            name: 'Master of States',
            description: 'Discover 5 elements in each state of matter (5 solids, 5 liquids, 5 gases)',
            emoji: 'üßä',
            unlocked: Date.now()
          });
        }
      }
      
      // Biome Explorer: 4 different environments
      if (!existingAchievements.find(a => a.id === 'biome-explorer')) {
        const biomeTags = ['terrestrial', 'aquatic', 'aerial', 'arctic', 'desert', 'forest', 'marine'];
        const discoveredBiomes = new Set();
        
        allDiscoveredElements.forEach(element => {
          const elementTags = element.achievementTags || element.tags || [];
          elementTags.forEach(tag => {
            if (biomeTags.includes(tag)) {
              discoveredBiomes.add(tag);
            }
          });
        });
        
        if (discoveredBiomes.size >= 4) {
          newAchievements.push({
            id: 'biome-explorer',
            name: 'Biome Explorer',
            description: 'Create elements from 4 different environments',
            emoji: 'üåç',
            unlocked: Date.now()
          });
        }
      }
      
      // Metallurgist: 10 different metals
      if (!existingAchievements.find(a => a.id === 'advanced-metallurgist')) {
        const metalElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.includes('metal');
        });
        
        if (metalElements.length >= 10) {
          newAchievements.push({
            id: 'advanced-metallurgist',
            name: 'Metallurgist',
            description: 'Discover 10 different metals',
            emoji: '‚öíÔ∏è',
            unlocked: Date.now()
          });
        }
      }
      
      // Danger Zone: 5 dangerous elements
      if (!existingAchievements.find(a => a.id === 'danger-zone')) {
        const dangerTags = ['danger', 'catastrophe', 'toxic', 'explosive', 'corrosive', 'radioactive', 'unstable'];
        const dangerousElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.some(tag => dangerTags.includes(tag));
        });
        
        if (dangerousElements.length >= 5) {
          newAchievements.push({
            id: 'danger-zone',
            name: 'Danger Zone',
            description: 'Create 5 dangerous elements',
            emoji: '‚ö†Ô∏è',
            unlocked: Date.now()
          });
        }
      }
      
      // Life Finds a Way: 15 organisms
      if (!existingAchievements.find(a => a.id === 'life-finds-a-way')) {
        const lifeTags = ['plant', 'animal', 'organism'];
        const lifeElements = allDiscoveredElements.filter(e => {
          const elementTags = e.achievementTags || e.tags || [];
          return elementTags.some(tag => lifeTags.includes(tag));
        });
        
        if (lifeElements.length >= 15) {
          newAchievements.push({
            id: 'life-finds-a-way',
            name: 'Life Finds a Way',
            description: 'Discover 15 organisms',
            emoji: 'üß¨',
            unlocked: Date.now()
          });
        }
      }
    }
    
  } catch (error) {
    console.error('Error checking achievements:', error);
  }
  
  return newAchievements;
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\achievements.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\auth-utils.ts ===== 
import { createClient } from '@/lib/supabase';
import { User } from '@supabase/supabase-js';

export interface AccountUpgradeResult {
  success: boolean;
  message: string;
  user?: User;
}

export async function upgradeAnonymousAccount(
  anonymousUserId: string,
  newUserData: {
    email: string;
    password: string;
    displayName?: string;
  }
): Promise<AccountUpgradeResult> {
  const supabase = createClient();
  
  try {
    // First, create the new registered account
    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
      email: newUserData.email,
      password: newUserData.password,
      options: {
        data: {
          display_name: newUserData.displayName || newUserData.email.split('@')[0],
        }
      }
    });

    if (signUpError) {
      return { success: false, message: signUpError.message };
    }

    if (!signUpData.user) {
      return { success: false, message: 'Failed to create account' };
    }

    // Wait for the user to be created in our database
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Migrate the anonymous user data to the new account
    const { data: migrationResult, error: migrationError } = await supabase
      .rpc('migrate_anonymous_data', {
        p_anonymous_user_id: anonymousUserId,
        p_registered_user_id: signUpData.user.id
      });

    if (migrationError) {
      console.error('Migration error:', migrationError);
      return { 
        success: false, 
        message: 'Account created but data migration failed. Please contact support.' 
      };
    }

    if (!migrationResult) {
      return { 
        success: false, 
        message: 'Failed to migrate your game progress. Please contact support.' 
      };
    }

    return {
      success: true,
      message: 'Account upgraded successfully! Your progress has been saved.',
      user: signUpData.user
    };

  } catch (error) {
    console.error('Account upgrade error:', error);
    return {
      success: false,
      message: 'An unexpected error occurred during account upgrade.'
    };
  }
}

export async function upgradeAnonymousAccountWithGoogle(
  anonymousUserId: string
): Promise<AccountUpgradeResult> {
  const supabase = createClient();
  
  try {
    // Store the anonymous user ID in localStorage for later migration
    localStorage.setItem('llm-alchemy-anonymous-user-id', anonymousUserId);
    
    // Initiate Google OAuth
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback?upgrade=true`
      }
    });

    if (error) {
      return { success: false, message: error.message };
    }

    // OAuth redirect will handle the rest
    return { success: true, message: 'Redirecting to Google...' };

  } catch (error) {
    console.error('Google upgrade error:', error);
    return {
      success: false,
      message: 'Failed to initiate Google authentication.'
    };
  }
}

export async function checkAndHandleUpgradeCallback(): Promise<boolean> {
  const supabase = createClient();
  const urlParams = new URLSearchParams(window.location.search);
  const isUpgrade = urlParams.get('upgrade') === 'true';
  
  if (!isUpgrade) return false;

  const anonymousUserId = localStorage.getItem('llm-alchemy-anonymous-user-id');
  if (!anonymousUserId) return false;

  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    
    if (error || !user) {
      console.error('Failed to get user after OAuth:', error);
      return false;
    }

    // Migrate the anonymous user data
    const { error: migrationError } = await supabase
      .rpc('migrate_anonymous_data', {
        p_anonymous_user_id: anonymousUserId,
        p_registered_user_id: user.id
      });

    if (migrationError) {
      console.error('Migration error after OAuth:', migrationError);
      return false;
    }

    // Clean up
    localStorage.removeItem('llm-alchemy-anonymous-user-id');
    
    return true;

  } catch (error) {
    console.error('OAuth upgrade callback error:', error);
    return false;
  }
}

export async function getUserAuthStatus(userId: string) {
  const supabase = createClient();
  
  try {
    const { data, error } = await supabase
      .rpc('get_user_auth_status', { p_user_id: userId });
    
    if (error) {
      console.error('Error getting auth status:', error);
      return null;
    }
    
    return data?.[0] || null;
  } catch (error) {
    console.error('Error getting auth status:', error);
    return null;
  }
}

export function shouldShowUpgradePrompt(
  dailyCount: number,
  dailyLimit: number,
  isAnonymous: boolean
): boolean {
  return isAnonymous && dailyCount >= dailyLimit;
}

export function shouldShowUpgradeButton(
  dailyCount: number,
  dailyLimit: number,
  isAnonymous: boolean
): boolean {
  return isAnonymous && dailyCount >= Math.floor(dailyLimit * 0.8); // Show at 80% of limit
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\auth-utils.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\challenge-elements.ts ===== 
// Curated lists for LLM Alchemy challenge system
// Daily challenges use categories, weekly challenges use specific elements

// Daily challenge categories with proper tag mapping and game mode support
export const DAILY_CATEGORIES = {
  science: [
    { category: 'lifeform', title: 'Discover a lifeform', tag: 'lifeform' },
    { category: 'edible', title: 'Discover something edible', tag: 'edible' },
    { category: 'tool', title: 'Discover a tool', tag: 'tool' },
    { category: 'metal', title: 'Discover a metal', tag: 'metal' },
    { category: 'gas', title: 'Discover a gas', tag: 'gas' },
    { category: 'liquid', title: 'Discover a liquid', tag: 'liquid' },
    { category: 'mineral', title: 'Discover a mineral', tag: 'mineral' },
    { category: 'chemical', title: 'Discover a chemical compound', tag: 'chemical' },
    { category: 'plant', title: 'Discover a plant', tag: 'plant' },
    { category: 'organism', title: 'Discover an organism', tag: 'organism' },
    { category: 'material', title: 'Discover a building material', tag: 'material' },
    { category: 'technology', title: 'Discover modern tech', tag: 'technology' }
  ],
  creative: [
    { category: 'creature', title: 'Discover a creature', tag: 'creature' },
    { category: 'magical', title: 'Discover something magical', tag: 'magical' },
    { category: 'weapon', title: 'Discover a weapon', tag: 'weapon' },
    { category: 'mythological', title: 'Discover something mythological', tag: 'mythological' },
    { category: 'artifact', title: 'Discover an artifact', tag: 'artifact' },
    { category: 'divine', title: 'Discover something divine', tag: 'divine' },
    { category: 'everyday', title: 'Discover an everyday object', tag: 'everyday' },
    { category: 'fictional', title: 'Discover something fictional', tag: 'fictional' },
    // Include science categories too for creative mode
    { category: 'lifeform', title: 'Discover a lifeform', tag: 'lifeform' },
    { category: 'edible', title: 'Discover something edible', tag: 'edible' },
    { category: 'tool', title: 'Discover a tool', tag: 'tool' }
  ]
};

// Weekly elements separated by game mode
export const WEEKLY_ELEMENTS = {
  science: [
    // Realistic, grounded elements for Science mode
    'Steam', 'Mud', 'Sand', 'Glass', 'Metal', 'Rust',
    'Salt', 'Sugar', 'Vinegar', 'Oil', 'Soap', 'Paper',
    'Plastic', 'Rubber', 'Cement', 'Brick', 'Wood', 'Coal',
    
    // Biological elements
    'Bacteria', 'Algae', 'Mushroom', 'Coral', 'Pearl',
    'Honey', 'Milk', 'Cheese', 'Yogurt', 'Bread', 'Wine',
    'Beer', 'Whiskey', 'Vodka', 'Rum',
    
    // Technology and tools
    'Telescope', 'Microscope', 'Compass', 'Clock', 'Battery',
    'Magnet', 'Laser', 'Computer', 'Radio', 'Television',
    
    // Materials and compounds
    'Gunpowder', 'Dynamite', 'Fertilizer', 'Pesticide',
    'Medicine', 'Penicillin', 'Insulin', 'Vaccine',
    'Alloy', 'Bronze', 'Steel', 'Titanium',
    
    // Natural phenomena
    'Rainbow', 'Lightning', 'Thunder', 'Tornado', 'Hurricane',
    'Earthquake', 'Volcano', 'Aurora', 'Eclipse',
    
    // Food and cuisine
    'Pizza', 'Sushi', 'Pasta', 'Burger', 'Taco',
    'Ice Cream', 'Chocolate', 'Coffee', 'Tea',
    'Tomato', 'Potato', 'Carrot', 'Apple', 'Orange',
    
    // Precious materials
    'Diamond', 'Gold', 'Silver', 'Platinum', 'Ruby',
    'Emerald', 'Sapphire', 'Crystal', 'Jade'
  ],
  creative: [
    // All science elements plus creative/mythological ones
    'Steam', 'Mud', 'Sand', 'Glass', 'Metal', 'Rust',
    'Salt', 'Sugar', 'Vinegar', 'Oil', 'Soap', 'Paper',
    'Plastic', 'Rubber', 'Cement', 'Brick', 'Wood', 'Coal',
    'Bacteria', 'Algae', 'Mushroom', 'Coral', 'Pearl',
    'Honey', 'Milk', 'Cheese', 'Yogurt', 'Bread', 'Wine',
    'Beer', 'Whiskey', 'Vodka', 'Rum',
    'Telescope', 'Microscope', 'Compass', 'Clock', 'Battery',
    'Magnet', 'Laser', 'Computer', 'Radio', 'Television',
    'Gunpowder', 'Dynamite', 'Fertilizer', 'Pesticide',
    'Medicine', 'Penicillin', 'Insulin', 'Vaccine',
    'Alloy', 'Bronze', 'Steel', 'Titanium',
    'Rainbow', 'Lightning', 'Thunder', 'Tornado', 'Hurricane',
    'Earthquake', 'Volcano', 'Aurora', 'Eclipse',
    'Pizza', 'Sushi', 'Pasta', 'Burger', 'Taco',
    'Ice Cream', 'Chocolate', 'Coffee', 'Tea',
    'Tomato', 'Potato', 'Carrot', 'Apple', 'Orange',
    'Diamond', 'Gold', 'Silver', 'Platinum', 'Ruby',
    'Emerald', 'Sapphire', 'Crystal', 'Jade',
    
    // Creative/Mythological elements (only for creative mode)
    'Dragon', 'Phoenix', 'Unicorn', 'Pegasus', 'Griffin',
    'Kraken', 'Mermaid', 'Vampire', 'Werewolf', 'Ghost',
    'Excalibur', 'Holy Grail', 'Philosopher Stone',
    'Love Potion', 'Invisibility Cloak', 'Time Machine',
    'Portal', 'Lightsaber', 'Wand', 'Spell Book'
  ]
};

// Helper function to get random daily categories based on game mode
export function getRandomDailyCategories(gameMode: 'science' | 'creative' = 'science', count: number = 2) {
  const categories = DAILY_CATEGORIES[gameMode];
  const shuffled = [...categories].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

// Helper function to get a random weekly element based on game mode
export function getRandomWeeklyElement(
  gameMode: 'science' | 'creative' = 'science', 
  excludeRecent: string[] = []
): string {
  const elements = WEEKLY_ELEMENTS[gameMode];
  const available = elements.filter(e => !excludeRecent.includes(e));
  if (available.length === 0) return elements[0]; // Fallback
  return available[Math.floor(Math.random() * available.length)];
}

// Helper function to determine appropriate game mode for challenge
export function getRandomGameMode(): 'science' | 'creative' | 'any' {
  const modes = ['science', 'creative', 'any'];
  return modes[Math.floor(Math.random() * modes.length)] as 'science' | 'creative' | 'any';
}

// Tag mapping for proper completion detection
export const TAG_MAPPING: Record<string, string[]> = {
  // Map display categories to actual element tags that might be used
  'lifeform': ['lifeform', 'organism', 'life', 'living'],
  'edible': ['edible', 'food', 'consumable'],
  'tool': ['tool', 'implement', 'device'],
  'metal': ['metal', 'metallic'],
  'gas': ['gas', 'gaseous'],
  'liquid': ['liquid', 'fluid'],
  'mineral': ['mineral', 'stone', 'rock'],
  'chemical': ['chemical', 'compound', 'substance'],
  'plant': ['plant', 'vegetation', 'flora'],
  'organism': ['organism', 'lifeform', 'life'],
  'material': ['material', 'building'],
  'technology': ['technology', 'tech', 'electronic'],
  'creature': ['creature', 'being'],
  'magical': ['magical', 'magic', 'mystical'],
  'weapon': ['weapon', 'armament'],
  'mythological': ['mythological', 'mythical', 'legendary'],
  'artifact': ['artifact', 'relic'],
  'divine': ['divine', 'holy', 'sacred'],
  'everyday': ['everyday', 'common', 'ordinary'],
  'fictional': ['fictional', 'fantasy']
};

// Helper function to check if element matches category
// Updated to support both legacy tags and new achievementTags structure
export function elementMatchesCategory(elementTags: string[], targetCategory: string): boolean {
  if (!elementTags || elementTags.length === 0) return false;
  
  const possibleTags = TAG_MAPPING[targetCategory] || [targetCategory];
  return elementTags.some(tag => possibleTags.includes(tag.toLowerCase()));
}

// Overloaded version that accepts an element object with achievementTags
export function elementMatchesCategoryFromElement(element: { achievementTags?: string[], tags?: string[] }, targetCategory: string): boolean {
  // Use achievementTags first, fall back to tags for backwards compatibility
  const elementTags = element.achievementTags || element.tags || [];
  return elementMatchesCategory(elementTags, targetCategory);
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\challenge-elements.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\game-config.ts ===== 
/**
 * Centralized game configuration constants
 * 
 * This file contains all game-related constants to ensure consistency
 * across the application and make it easy to adjust values.
 */

export const GAME_CONFIG = {
  /**
   * Daily free combinations limit for non-paying users
   * Used across main menu display, game logic, and upgrade prompts
   */
  DAILY_FREE_COMBINATIONS: 3,
  
  // Future game constants can be added here, such as:
  // TOKEN_COSTS: { combination: 1, undo: 1 },
  // ACHIEVEMENT_THRESHOLDS: { apprentice: 10, skilled: 50, expert: 100 },
  // etc.
} as const;
 
===== END: C:\ai\LLM-Alchemy\src\lib\game-config.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\game-logic.ts ===== 
import { Element } from '@/types/game.types';
import { MixingElement } from '@/components/game/LLMAlchemy/hooks/useGameState';

// Constants for collision detection and UI
export const GAME_CONSTANTS = {
  HOVER_DELAY: 500,
  ANIMATION_DURATION: 300,
  TOAST_DURATION: 3000,
  ELEMENT_SIZES: { sm: 48, md: 56, lg: 64 },
  BREAKPOINTS: { sm: 640, md: 768 },
  COLLISION_SPACING: 8,
  MAX_COLLISION_DISTANCE: 300,
  COLLISION_POSITIONS: 16
};

// Utility functions
export const getElementSize = (): number => {
  if (typeof window === 'undefined') return GAME_CONSTANTS.ELEMENT_SIZES.md;
  
  if (window.innerWidth < GAME_CONSTANTS.BREAKPOINTS.sm) return GAME_CONSTANTS.ELEMENT_SIZES.sm;
  if (window.innerWidth < GAME_CONSTANTS.BREAKPOINTS.md) return GAME_CONSTANTS.ELEMENT_SIZES.md;
  return GAME_CONSTANTS.ELEMENT_SIZES.lg;
};

export const getContrastColor = (hexcolor: string): string => {
  const r = parseInt(hexcolor.slice(1, 3), 16);
  const g = parseInt(hexcolor.slice(3, 5), 16);
  const b = parseInt(hexcolor.slice(5, 7), 16);
  const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
  return (yiq >= 128) ? '#000000' : '#FFFFFF';
};

export const getRarityHoverColor = (rarity: string = 'common'): string => {
  switch (rarity) {
    case 'uncommon': return '#10B981'; // Green
    case 'rare': return '#8B5CF6';     // Purple  
    default: return '#6B7280';         // Gray (common)
  }
};

// Collision detection functions - Fixed to match legacy working implementation
export const checkCollision = (
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number, 
  size: number | null = null
): boolean => {
  const currentSize = size || getElementSize();
  return Math.abs(x1 - x2) < currentSize && Math.abs(y1 - y2) < currentSize;
};

export const hasCollisionAt = (
  x: number, 
  y: number, 
  mixingArea: MixingElement[], 
  dropZoneElement: HTMLDivElement | null,
  excludeIndex: number | null = null
): boolean => {
  const rect = dropZoneElement?.getBoundingClientRect();
  if (!rect) return false;
  
  const elementSize = getElementSize();
  
  // Check boundaries
  if (x < 0 || y < 0 || x + elementSize > rect.width || y + elementSize > rect.height) {
    return true; // Out of bounds
  }
  
  // Check collision with existing elements
  return mixingArea.some(el => 
    el.index !== excludeIndex && checkCollision(x, y, el.x, el.y, elementSize)
  );
};

export const findBestPosition = (
  centerX: number, 
  centerY: number, 
  mixingArea: MixingElement[], 
  dropZoneElement: HTMLDivElement | null,
  excludeIndex: number | null = null
): { x: number; y: number } => {
  const elementSize = getElementSize();
  const spacing = elementSize + GAME_CONSTANTS.COLLISION_SPACING;
  
  // Try center first
  if (!hasCollisionAt(centerX, centerY, mixingArea, dropZoneElement, excludeIndex)) {
    return { x: centerX, y: centerY };
  }
  
  // Spiral outward from center
  for (let distance = spacing; distance < GAME_CONSTANTS.MAX_COLLISION_DISTANCE; distance += spacing * 0.7) {
    // Try positions around each circle
    for (let i = 0; i < GAME_CONSTANTS.COLLISION_POSITIONS; i++) {
      const angle = (i / GAME_CONSTANTS.COLLISION_POSITIONS) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      
      if (!hasCollisionAt(x, y, mixingArea, dropZoneElement, excludeIndex)) {
        return { x, y };
      }
    }
  }
  
  // Fallback: find any available position in grid pattern
  const rect = dropZoneElement?.getBoundingClientRect();
  if (rect) {
    for (let y = 0; y < rect.height - elementSize; y += spacing) {
      for (let x = 0; x < rect.width - elementSize; x += spacing) {
        if (!hasCollisionAt(x, y, mixingArea, dropZoneElement, excludeIndex)) {
          return { x, y };
        }
      }
    }
  }
  
  // Final fallback: return center even if it collides
  return { x: centerX, y: centerY };
};

export const resolveCollisions = (
  newX: number, 
  newY: number, 
  mixingArea: MixingElement[], 
  dropZoneElement: HTMLDivElement | null,
  excludeIndex: number | null = null
): { x: number; y: number } => {
  return findBestPosition(newX, newY, mixingArea, dropZoneElement, excludeIndex);
};

// Game logic functions
export const getPreviouslyMixedElements = (
  elementName: string, 
  combinations: Record<string, string | null>, 
  failedCombinations: string[]
): Set<string> => {
  const mixedWith = new Set<string>();
  
  // Check combinations object
  Object.keys(combinations).forEach(comboKey => {
    const parts = comboKey.split('+');
    if (parts.includes(elementName)) {
      parts.forEach(part => {
        if (part !== elementName && part !== 'Energy') {
          mixedWith.add(part);
        }
      });
    }
  });
  
  // Check failed combinations
  failedCombinations.forEach(failedCombo => {
    const parts = failedCombo.split('+');
    if (parts.includes(elementName)) {
      parts.forEach(part => {
        if (part !== elementName && part !== 'Energy') {
          mixedWith.add(part);
        }
      });
    }
  });
  
  return mixedWith;
};

// Touch device detection
export const isTouchDevice = (): boolean => {
  if (typeof window === 'undefined') return false;
  return (('ontouchstart' in window) || navigator.maxTouchPoints > 0);
};

// Sorting functions for elements
export const sortElements = (
  elements: Element[], 
  sortMode: 'unlock' | 'alpha', 
  searchTerm: string = ''
): Element[] => {
  const filtered = elements
    .filter(e => e.name !== 'Energy')
    .filter(e => searchTerm === '' || e.name.toLowerCase().includes(searchTerm.toLowerCase()));
  
  return filtered.sort((a, b) => {
    if (sortMode === 'alpha') {
      return a.name.localeCompare(b.name);
    }
    return a.unlockOrder - b.unlockOrder;
  });
};

// Game mode validation
export const isValidGameMode = (mode: string): mode is 'science' | 'creative' => {
  return mode === 'science' || mode === 'creative';
};

// Element validation helpers
export const isEndElement = (element: Element): boolean => {
  return element.isEndElement === true;
};

export const canElementBeDragged = (element: Element): boolean => {
  return !isEndElement(element);
};

// Combination key generation
export const generateCombinationKey = (elements: Element[], hasEnergy: boolean = false): string => {
  const sortedNames = elements.map(e => e.name).sort().join('+');
  return hasEnergy ? `${sortedNames}+Energy` : sortedNames;
};

// Animation helpers
export const getAnimationDuration = (type: 'fast' | 'normal' | 'slow'): number => {
  switch (type) {
    case 'fast': return 150;
    case 'slow': return 500;
    default: return GAME_CONSTANTS.ANIMATION_DURATION;
  }
};

// API request helpers (pure functions)
export interface CombinationRequest {
  elem1: Element;
  elem2: Element;
  elem3?: Element | null;
  gameMode: 'science' | 'creative';
  useProModel: boolean;
  userApiKey?: string;
  combinations: Record<string, string | null>;
  failedCombinations: string[];
  elements: Element[];
}

export interface CombinationResult {
  result: string | null;
  emoji?: string;
  color?: string;
  rarity?: string;
  reasoning?: string;
  tags?: string[];
  achievementTags?: string[];
  emojiTags?: string[];
  isEndElement?: boolean;
  error?: boolean;
  limitReached?: boolean;
  timeout?: boolean;
}

// Hardcoded combinations for life form path (pure function)
export const getHardcodedCombination = (
  sortedNames: string, 
  gameMode: 'science' | 'creative'
): CombinationResult | null => {
  if (gameMode !== 'science') return null;
  
  // Microbe creation
  if ((sortedNames.includes('Mud') || sortedNames.includes('Clay') || sortedNames.includes('Nutrient')) && 
      sortedNames.includes('Air') && sortedNames.includes('Energy')) {
    return { 
      result: 'Microbe', 
      emoji: 'ü¶†', 
      color: '#90EE90', 
      rarity: 'common', 
      reasoning: 'Energy activates organic matter in suitable environment',
      achievementTags: ['lifeform', 'microorganism'],
      isEndElement: false
    };
  }
  
  // Microbe branches
  if (sortedNames === 'Energy+Microbe+Water' || sortedNames === 'Air+Energy+Microbe' || sortedNames === 'Earth+Energy+Microbe') {
    return { 
      result: 'Algae', 
      emoji: 'üåø', 
      color: '#228B22', 
      rarity: 'common', 
      reasoning: 'Microbes evolve photosynthesis in favorable conditions',
      achievementTags: ['lifeform', 'plant', 'organism'],
      isEndElement: false
    };
  }
  if (sortedNames === 'Microbe+Water') {
    return { 
      result: 'Protozoa', 
      emoji: 'üî¨', 
      color: '#4169E1', 
      rarity: 'common', 
      reasoning: 'Single-celled organisms thrive in aquatic environment',
      achievementTags: ['lifeform', 'microorganism'],
      isEndElement: false
    };
  }
  if (sortedNames === 'Microbe+Mud' || sortedNames === 'Compost+Microbe') {
    return { 
      result: 'Fungi', 
      emoji: 'üçÑ', 
      color: '#8B4513', 
      rarity: 'common', 
      reasoning: 'Decomposer organisms break down organic matter',
      achievementTags: ['lifeform', 'organism'],
      isEndElement: false
    };
  }
  
  return null;
};

// Mixing validation logic (pure)
export const validateMixing = (elem1: Element, elem2: Element): boolean => {
  // Don't allow mixing with self
  if (elem1.name === elem2.name) return false;
  
  // Don't allow mixing End Elements
  if (elem1.isEndElement || elem2.isEndElement) return false;
  
  return true;
};

// Determine mixing type (pure)
export const getMixingType = (elem1: MixingElement, elem2: MixingElement): 'energize' | 'mix' | 'energy-mix' => {
  if (elem1.name === 'Energy' && !elem2.energized) {
    return 'energize';
  } else if (elem1.energized || elem2.energized) {
    return 'energy-mix';
  } else {
    return 'mix';
  }
};

// Calculate rarity target (pure)
export const calculateRarityTarget = (): 'common' | 'uncommon' | 'rare' => {
  const roll = Math.random();
  if (roll < 0.85) return 'common';
  else if (roll < 0.96) return 'uncommon';
  else return 'rare';
};

// Build combination context for LLM (pure)
export const buildCombinationContext = (
  combinations: Record<string, string | null>,
  failedCombinations: string[]
): { recentText: string; failedText: string } => {
  // Keep only last 10 combinations for context (prevents endless chains)
  const recentCombinations = Object.entries(combinations).slice(-10);
  const recentText = recentCombinations.length > 0 
    ? recentCombinations.map(([mix, result]) => `${mix}=${result || 'null'}`).join(', ')
    : 'none';

  // Prepare failed combinations text
  const failedText = failedCombinations.length > 0 
    ? failedCombinations.slice(-5).join(', ')
    : 'none';
    
  return { recentText, failedText };
};

// Check if combination exists in cache (pure)
export const getCachedCombination = (
  mixKey: string,
  combinations: Record<string, string | null>,
  elements: Element[],
  endElements: Element[]
): CombinationResult | null => {
  if (combinations[mixKey] === undefined) return null;
  
  const cachedResult = combinations[mixKey];
  if (!cachedResult) return { result: null };
  
  // Find the full element data
  const existingElement = elements.find(e => e.name === cachedResult) || 
                          endElements.find(e => e.name === cachedResult);
                          
  return existingElement ? { 
    result: existingElement.name, 
    emoji: existingElement.emoji, 
    color: existingElement.color, 
    rarity: existingElement.rarity,
    reasoning: existingElement.reasoning || '',
    achievementTags: existingElement.achievementTags || [],
    emojiTags: existingElement.emojiTags || [],
    tags: existingElement.tags || [],
    isEndElement: existingElement.isEndElement || false
  } : { result: null };
};

// Determine model selection (pure)
export const determineModelSelection = (
  userApiKey: string,
  tokenBalance: number,
  selectedModel: 'flash' | 'pro'
): { useProModel: boolean; userType: string; reason: string; model: string } => {
  const useProModel = userApiKey 
    ? (selectedModel === 'pro') 
    : (tokenBalance > 0 && selectedModel === 'pro');
  
  let userType: string;
  let reason: string;
  let model: string;
  
  if (userApiKey) {
    userType = 'API Key User';
    model = useProModel ? 'google/gemini-2.5-pro' : 'google/gemini-2.5-flash';
    reason = `User preference (${useProModel ? 'Pro' : 'Flash'} selected)`;
  } else {
    userType = useProModel ? 'Token User' : 'Freemium User';
    model = useProModel ? 'google/gemini-2.5-pro' : 'google/gemini-2.5-flash';
    reason = useProModel ? `Has tokens (${tokenBalance} remaining)` : `Daily limit user`;
  }
  
  return { useProModel, userType, reason, model };
};

// Rate limiting logic (pure)
export const shouldAllowMixing = (
  userApiKey: string,
  tokenBalance: number,
  dailyCount: number,
  dailyLimit: number
): { allowed: boolean; reason?: string } => {
  // If user has their own API key, no limits
  if (userApiKey) return { allowed: true };
  
  // If user has tokens, they can use them
  if (tokenBalance > 0) return { allowed: true };
  
  // Otherwise check daily limit
  if (dailyCount >= dailyLimit) {
    return { 
      allowed: false, 
      reason: `Daily limit reached: ${dailyCount}/${dailyLimit} - Click "Get more" for tokens!` 
    };
  }
  
  return { allowed: true };
};
 
===== END: C:\ai\LLM-Alchemy\src\lib\game-logic.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\llm-prompts.ts ===== 
// LLM Prompt Building Functions for LLM Alchemy Game
// Extracted from LLMAlchemy.tsx for better organization

// Type definitions for prompt building
interface Element {
  id: string;
  name: string;
  emoji: string;
  color: string;
  unlockOrder: number;
  rarity?: string;
  reasoning?: string;
  // Tag separation for different purposes
  achievementTags?: string[];  // For achievements and challenges
  emojiTags?: string[];        // For OpenMoji visual search
  tags?: string[];             // Legacy fallback for backwards compatibility
  isEndElement?: boolean;
  parents?: Element[];
  energyEnhanced?: boolean;
}

interface SharedSections {
  raritySystem: string;
  reasoningRequirement: string;
  responseFormat: string;
}

// Modular prompt building system
export const buildSharedSections = (rarityTarget: string, currentGameMode: string): SharedSections => ({
  raritySystem: `RARITY SYSTEM (Target: ${rarityTarget}):
- "common" = the most expected/obvious outcome (85% chance)
- "uncommon" = a less obvious but plausible outcome (11% chance)
- "rare" = an unexpected but valid outcome (4% chance)
- Generate outcome with ${rarityTarget} rarity for this combination`,

  reasoningRequirement: `REASONING REQUIREMENT:
- Every valid result needs a brief (15-60 characters) explanation
- Keep explanations simple and educational`,

  responseFormat: `Respond with ONLY a valid JSON object:
{
  "outcomes": [
    {
      "result": "Element Name",
      "emoji": "one appropriate Unicode emoji (no text or Asian characters)", 
      "color": "hex color code",
      "rarity": "common" or "uncommon" or "rare",${currentGameMode === 'science' ? '\n      "isEndElement": true or false,' : ''}
      "reasoning": "brief explanation",
      "achievementTags": ["category1", "category2"],
      "emojiTags": ["visual1", "visual2", "descriptive3"]
    }
  ]
}
Failure or rejection: { "outcomes": null, "reasoning": "No reaction: [reason, max 40 chars]" }`
});

export const buildSciencePrompt = (
  elements: Element[], 
  mixingElements: Element[], 
  shared: SharedSections, 
  recentText: string, 
  failedText: string
): string => {
  return `You are an element combination system for a science-based alchemy game. Your role is to determine logical outcomes when players mix elements, following rules to maintain game balance and scientific grounding. You may return "null" if certain criteria is met.

Current discovered elements: ${elements.map(e => e.name).join(', ')}
Mixing: ${mixingElements.map(e => e.name).join(' + ')}

CORE RULES:
‚Ä¢ Generate only common, well-known scientific outcomes (high school level)
‚Ä¢ NO obscure terms (Heterokaryon, Plasmogamy, etc.)
‚Ä¢ Outcomes must have clear scientific connections based on real principles
‚Ä¢ Good examples: Rock, Sand, Steam, Cloud, Plant, Tree, Metal, Glass
‚Ä¢ Same element √ó2 OK if logical (Fungi+Fungi=Mycelium)

COMBINATION RULES:
Similar Elements: If outcome too similar to existing (pre-discovered), return existing element name (for natural "rediscovery" rather than null responses).

Endless Chains: Focus on tangible elements, not phenomena progressions. Water‚ÜíSteam‚ÜíCloud GOOD (distinct states); Rain‚ÜíDrizzle‚ÜíSprinkle BAD (minor variations) - return null when results become too nonsensical.

Avoid Escalation: Instead of going bigger, explore states (solid‚Üíliquid‚Üígas), compositions (rock‚Üígravel‚Üísand), applications (water‚Üíice‚Üílens), variants (metal‚Üíiron).

Energy Transform: Energy+element=NEW substance (Energy+Rock=Crystal, not "Energized Rock") - if no valid transformation exists, return null.

No Abstract: Never create Life/Death/Time/Love/Speed. Use concrete forms ("Decay" not "Death").

Basic Stays Basic: Water+Fire usually=Steam regardless of game progress (don't overcomplicate fundamental reactions).

RESIDUAL OUTCOMES: If an interaction seems to "cancel out", find the residual element (Dust+Wind doesn't = nothing, it = Sandstorm). Consider outputting what REMAINS or FORMS after interaction.

SCALE & PHYSICAL CONSTRAINTS:
‚Ä¢ Never generate physical outcomes larger than a building or smaller than a molecule
‚Ä¢ If a combination would create something larger, return a fragment instead (Rock+Rock=Gravel not Boulder, Water+Water=Pool not Ocean)
‚Ä¢ Natural phenomena exception: Can exceed if fundamental (Atmosphere, Hurricane are valid; but Cosmic phenomena like Black Hole or Supernova are invalid)
‚Ä¢ Very large phenomena must be End Elements

NULL RESPONSE CRITERIA:
Return null when:
- No scientific basis for the combination exists
- Result would exceed scale limits (see Scale Constraints above)
- Combination would create abstract concepts or actions
- Elements cancel without meaningful residual
- No sensible transformation or reaction occurs

MODE CONSTRAINTS - Valid Types & Technology:

VALID TYPES:
‚úì Natural materials (Rock, Sand, Metal)
‚úì Living organisms (Plant, Bacteria, Fish)
‚úì Natural phenomena (Lightning, Snow)
‚úì Chemical compounds (Water, Salt, Acid)
‚úì Transformation products (Steam, Ash, Charcoal, Glass)
‚úì Combined materials (Alloy, Ceramic, Composite, Rope)

INVALID TYPES:
‚úó Human actions (Mixing, Cutting)
‚úó Abstract concepts (Life, Speed)
‚úó Adjective versions (Hot Water, Energized Rock)

TECHNOLOGY: Prefer natural outcomes. Guide toward biology, geology, chemistry over modern technology.

LIFE PROGRESSION: Build complexity gradually. If no simple organisms exist yet, start with foundational life (Microbe from any energised wet soil + gas), e.g. "Mud + Energy + Air". Progress step-by-step: Microbe ‚Üí Protozoa ‚Üí Algae ‚Üí Plants. Avoid too miniscule and too large evolutionary leaps.

END ELEMENTS
‚Ä¢ Evolutionary dead-ends (Extremophile)
‚Ä¢ Final mineral forms (Diamond, Obsidian) ¬†
‚Ä¢ Advanced tech and tools (Computer, Phone, Microscope)
‚Ä¢ Terminal Species (Great White Shark, Venus Flytrap, Platypus)
‚Ä¢ Unique Landmarks (Old Faithful, The Little Mermaid)


SCIENTIFIC GROUNDING:
1. Generate only outcomes with clear scientific logic
2. Results must be well-known at high school level (no obscure terms)
3. Mixing the same element with itself CAN produce results if scientifically valid
4. Return null if no sensible outcome exists. Always consider:
   - What physical result the interaction leaves behind
   - What natural process would occur and its end result
   - What material forms when elements combine or transform

REASONING REQUIREMENT:
Every result needs a brief (15-60 character) scientific explanation.
Focus on mechanism: "Heat evaporates liquid" or "Pressure crystallizes minerals"

TAGS REQUIREMENT - TWO SEPARATE TAG TYPES:

1. ACHIEVEMENT TAGS (1-6 tags for game mechanics):
- Used for challenges, achievements, and game progression
- Science categories: "organism", "mineral", "compound", "metal", "plant", "animal", "chemical", "gas", "liquid", "solid", "edible", "tool", "danger", "catastrophe", "terrestrial", "aquatic", "aerial", "arctic", "desert", "forest", "marine", "energy-form", "thermal", "electrical", "radioactive", "natural", "synthetic", "geological", "biological", "volcanic", "atmospheric", "industrial", "modern-tech", "massive", "corrosive", "explosive", "toxic", "medicinal", "building-material", "fuel", "unstable", "microscopic"

2. EMOJI TAGS (2-4 descriptive visual hints):
- Used for finding better OpenMoji emoji representations
- Descriptive visual terms that help match the element to appropriate emoji
- Examples: For "Coffee Grinder" ‚Üí achievementTags: ["tool", "kitchen"] + emojiTags: ["coffee", "grinder", "mill", "machine"]
- Examples: For "Microbe" ‚Üí achievementTags: ["organism", "microscopic"] + emojiTags: ["microbe", "germ", "cell"]

Recent successful combinations (last 10): ${recentText}
Recent failed combinations (last 5): ${failedText}

Respond with ONLY a valid JSON object:
{
  "outcomes": [
    {
      "result": "Element Name",
      "emoji": "one appropriate Unicode emoji (no text or Asian characters)",
      "color": "hex color",
      "rarity": "common",
      "isEndElement": false,
      "reasoning": "brief explanation",
      "achievementTags": ["category1", "category2"],
      "emojiTags": ["visual1", "visual2", "descriptive3"]
    }
  ]
}
Failure or rejection:
{
  "outcomes": null,
  "reasoning": "No reaction: [specific reason, max 40 chars]"
}`;
};

export const buildCreativePrompt = (
  elements: Element[], 
  mixingElements: Element[], 
  shared: SharedSections, 
  recentText: string, 
  failedText: string
): string => {
  return `You are an element combination system for a creative alchemy game. Your role is to determine imaginative yet grounded outcomes when players mix elements, following rules to maintain game balance and thematic coherence. You may return "null" if certain criteria is met.

Current discovered elements: ${elements.map(e => e.name).join(', ')}
Mixing: ${mixingElements.map(e => e.name).join(' + ')}

CORE PRINCIPLES:
‚Ä¢ Generate recognizable outcomes from mythology, folklore, pop culture, or everyday life
‚Ä¢ Every outcome must have clear thematic connections to ALL input elements
‚Ä¢ Make creative leaps to fundamentally different concepts, not minor variations
‚Ä¢ Return null when no meaningful synthesis exists
‚Ä¢ Same element √ó2 OK if logical (Life+Life=Evolution, Fire+Fire=Inferno)

EXAMPLE OUTCOMES BY TYPE:
‚Ä¢ Mythological: Dragon, Phoenix, Unicorn, Mermaid
‚Ä¢ Everyday Items: Pizza, Telescope, Castle, Tomato
‚Ä¢ Cultural Icons: Batman, Excalibur, Atlantis
‚Ä¢ Historical: Pompeii, Stonehenge
‚Ä¢ Abstract: Love, Dreams, Chaos

COMBINATION GUIDELINES:
Rediscovery: If outcome resembles existing element, return that element's exact name (enables natural rediscovery).


Creative Leaps: Avoid adjective variations, endless chains or minor modifications. 
‚úó BAD: Dragon ‚Üí Fire Dragon ‚Üí Red Dragon (just variations)
‚úì GOOD: Dragon ‚Üí Knight ‚Üí Castle (different entity types)

Special Transformations:
- Life + element = ANIMATED version (Life+Rock=Golem, not "Living Rock")

Synthesis Logic: Find what emerges from thematic interaction:
- Fire+Water could = Steam (physical) OR Hot Spring (mythological)
- Consider cultural associations, functional relationships, mythological connections

NULL RESPONSE CRITERIA:
Return null when:
- No thematic or cultural basis for the combination exists
- Result would just be an adjective variation of existing element
- Combination creates boring descriptive versions (Red X, Big Y)
- Elements contradict without meaningful synthesis
- No recognizable concept would result

Always consider:
   - What story or myth combines these concepts
   - What cultural artifact or creature embodies both elements
   - What everyday object uses both inputs
   - What fantastical result makes thematic sense

MODE CONSTRAINTS - Creative Freedom with Boundaries:
SCALE FLEXIBILITY:
‚Ä¢ Can exceed physical limits IF culturally significant (World Tree, Mount Olympus valid)
‚Ä¢ Cosmic entities allowed IF from mythology/culture (Phoenix, Rainbow Bridge valid)
‚Ä¢ Abstract concepts allowed and encouraged (Love, Chaos, Dreams, Hope)
‚Ä¢ Historical places/events welcome (Pompeii, Titanic, Stonehenge)
‚Ä¢ Microscopic allowed IF commonly known (Bacteria, DNA)

VALID OUTCOME TYPES:
‚úì Mythological beings (Dragon, Phoenix, Kraken)
‚úì Cultural artifacts (Excalibur, Holy Grail)  
‚úì Everyday objects and creatures (Pizza, Telescope, Tomato, Cat)
‚úì Pop culture icons (Batman, Godzilla - when thematically fitting)
‚úì Historical places/events (Pompeii, Atlantis)
‚úì Abstract concepts (Love, Chaos - when meaningfully derived)
‚úì Natural wonders (Aurora, Rainbow)
‚úì Fantastical materials (Mithril, Ectoplasm)

INVALID TYPES:
‚úó Adjective modifications of existing elements (Red Dragon, Big Castle, Energised Sword)
‚úó Actions or verbs (Running, Thinking)
‚úó Unrecognizable nonsense (Florbix, Zyphon)
‚úó Overly niche references

CREATIVE BALANCE:
- Mix categories freely - Pizza is as valid as Phoenix
- Compound words OK when creating distinct concepts (Ice Cream, Storm Cloud)
- Scale flexible - can exceed physical limits if culturally significant (World Tree, Mount Olympus)
- Abstract concepts allowed when meaningfully derived


${shared.raritySystem}

Multiple outcome generation:
- Generate 1-3 possible outcomes based on creative logic
- Each outcome should offer a different thematic interpretation
- Common: Most obvious cultural/mythological connection
- Uncommon: Less obvious but equally valid interpretation  
- Rare: Surprising but meaningful creative leap
- Only include outcomes that make genuine thematic sense

${shared.reasoningRequirement}

TAGS REQUIREMENT - TWO SEPARATE TAG TYPES:

1. ACHIEVEMENT TAGS (1-6 tags for game mechanics):
- Used for challenges, achievements, and game progression
- Creative categories: "creature", "animal", "plant", "food", "tool", "weapon", "artifact", "mythological", "celestial", "aquatic", "flying", "magical", "technology", "furniture", "clothing", "mineral", "undead", "divine", "demonic", "legendary", "everyday", "natural", "synthetic", "fictional-character", "building", "vehicle", "musical", "explosive", "edible", "toxic", "precious", "ancient", "modern", "ethereal", "solid", "liquid", "gas", "fire-related", "ice-related", "earth-related", "air-related", "water-related", "life-related", "abstract", "emotion", "historical", "pop-culture", "superhero", "place", "event"

2. EMOJI TAGS (2-4 descriptive visual hints):
- Used for finding better OpenMoji emoji representations
- Descriptive visual terms that help match the element to appropriate emoji
- Examples: For "Dragon" ‚Üí achievementTags: ["creature", "mythological"] + emojiTags: ["dragon", "fire", "wings", "beast"]
- Examples: For "Pizza" ‚Üí achievementTags: ["food", "everyday"] + emojiTags: ["pizza", "slice", "food"]

Recent successful combinations (last 10): ${recentText}
Recent rejected combinations (last 5): ${failedText}

Respond with ONLY a valid JSON object:
{
  "outcomes": [
    {
      "result": "Element Name",
      "emoji": "one appropriate Unicode emoji (no text or Asian characters)", 
      "color": "hex color",
      "rarity": "common",
      "reasoning": "brief explanation",
      "achievementTags": ["category1", "category2"],
      "emojiTags": ["visual1", "visual2", "descriptive3"]
    }
  ]
}
Failure or rejection:
{
  "outcomes": null,
  "reasoning": "No reaction: [reason, max 40 chars]"
}`;
};
 
===== END: C:\ai\LLM-Alchemy\src\lib\llm-prompts.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\OpenMoji-API.md ===== 
OpenMoji API
========

Access OpenMoji emoji images, their metadata, and colors from your Node.js application.

## Install

Install with [npm](https://www.npmjs.com/package/openmoji):

    $ npm install openmoji

## Usage

    > const openmoji = require('openmoji')
    > const om = openmoji.openmojis[0]
    > om.emoji
    'üòÄ'
    > om.hexcode
    '1F600'
    > om.openmoji_tags
    'smile, happy'
    > om.openmoji_images.color.svg
    '/path/to/your/local/openmoji/color/svg/1F600.svg'
    > openmoji.color_palette.colors[23]
    '#186648'
    > openmoji.color_palette.skintones.hair[4]
    '#000000'

## API

### openmoji.openmojis

An array of openmoji emoji data. A openmoji emoji datum has the following structure:

```javascript
{
  emoji: 'üòÄ',
  hexcode: '1F600',
  group: 'smileys-emotion',
  subgroups: 'face-smiling',
  annotation: 'grinning face',
  tags: 'face, grin',
  openmoji_tags: 'smile, happy',
  openmoji_author: 'Emily J√§ger',
  openmoji_date: '2018-04-18',
  skintone: '',
  skintone_combination: '',
  skintone_base_emoji: '',
  skintone_base_hexcode: '',
  unicode: 1,
  order: 1,
  openmoji_images: {
    black: {
      svg: '/path/to/your/local/openmoji/black/svg/1F600.svg'
    },
    color: {
      svg: '/path/to/your/local/openmoji/color/svg/1F600.svg'
    }
  }
}
```

The paths under `openmoji_images` are absolute paths to image files located inside the `openmoji` package.

### openmoji.color_palette

Colors and skintones allowed in the emojis.

```javascript
{
  colors: <an array of color strings>
  skintones: {
    fitzpatric: <an array of color strings>,
    shadow: <an array of color strings>,
    hair: <an array of color strings>
  }
}
```

where an array of color strings is structurally similar to:

```javascript
[ '#debb90', '#c19a65', '#a57939', '#6a462f', '#352318' ]
```

### openmoji.version

The current package version string.
 
===== END: C:\ai\LLM-Alchemy\src\lib\OpenMoji-API.md ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\openmoji-service.ts ===== 
import Fuse from 'fuse.js';

// Type definitions for OpenMoji data structure
interface OpenMojiData {
  emoji: string;
  hexcode: string;
  group: string;
  subgroups: string;
  annotation: string;
  tags: string;
  openmoji_tags: string;
  openmoji_author: string;
  openmoji_date: string;
  skintone?: string;
  skintone_combination?: string;
  skintone_base_emoji?: string;
  skintone_base_hexcode?: string;
  unicode?: number;
  order?: number;
}

// Import OpenMoji data with proper typing
// eslint-disable-next-line @typescript-eslint/no-require-imports
const openmoji = require('openmoji') as { openmojis: OpenMojiData[] };

// Global cache for serverless warm starts
const globalCache = globalThis as any; // eslint-disable-line @typescript-eslint/no-explicit-any
if (!globalCache.__openmojiFuse) {
  globalCache.__openmojiFuse = new Fuse(openmoji.openmojis, {
    keys: ['annotation', 'openmoji_tags'],
    threshold: 0.32,
    includeScore: true
  });
}
const fuse = globalCache.__openmojiFuse;

// Create Unicode ‚Üí OpenMoji map for O(1) lookups
if (!globalCache.__openmojiUnicodeMap) {
  globalCache.__openmojiUnicodeMap = new Map(
    openmoji.openmojis.map(d => [d.emoji, d])
  );
}
const unicodeMap = globalCache.__openmojiUnicodeMap;

// Result cache to avoid repeat fuzzy searches
if (!globalCache.__openmojiResultCache) {
  globalCache.__openmojiResultCache = new Map<string, ResolveEmojiResult>();
}
const resultCache = globalCache.__openmojiResultCache;

// v2.1: Alias table for known mismatches
const aliasHex: Record<string, string> = {
  microbe: 'E011',        // Dedicated microbe emoji
  'coffee grinder': 'E156', // Coffee grinder (if exists)
  golem: 'E0BF'          // Golem (if exists)
};

interface ResolveEmojiParams {
  unicodeEmoji: string;
  name: string;
  tags?: string[];  // These are specifically emojiTags for visual search
}

interface ResolveEmojiResult {
  hexcode: string;
  svgPath: string;
  isExtra: boolean; // true if it's a PUA (Private Use Area) emoji
}

/**
 * Resolves the best OpenMoji for a given element
 * Always returns an OpenMoji (fallback to ‚ùì if nothing found)
 * v2.1: Enhanced with debug logging and aliases
 */
export function resolveEmoji({ 
  unicodeEmoji = '', 
  name, 
  tags = [] 
}: ResolveEmojiParams): ResolveEmojiResult {
  // Check cache first
  const cacheKey = `${name}|${tags.join(',')}`;
  if (resultCache.has(cacheKey)) {
    return resultCache.get(cacheKey)!;
  }
  
  // v2.1: Check aliases first
  const alias = aliasHex[name.toLowerCase()];
  if (alias) {
    const datum = openmoji.openmojis.find(o => o.hexcode === alias);
    if (datum) {
      const result = wrap(datum);
      resultCache.set(cacheKey, result);
      
      if (process.env.NODE_ENV !== 'production') {
        console.debug('[OpenMoji] Alias match:', { name, alias, hexcode: datum.hexcode });
      }
      
      return result;
    }
  }
  
  // Get direct Unicode match if available
  const direct = unicodeEmoji ? unicodeMap.get(unicodeEmoji) : null;
  
  // Two-phase search: prioritize element name, fallback to tags
  // Phase 1: Search by name only
  let searchResults = fuse.search(name);
  let bestHit = searchResults[0];
  
  // Phase 2: If no good match by name alone (score > 0.3), try with tags
  if (!bestHit || bestHit.score! > 0.3) {
    const searchQuery = `${name} ${tags.join(' ')}`.trim();
    searchResults = fuse.search(searchQuery);
    bestHit = searchResults[0];
  }

  // Decision logic for using search result vs direct match (v2.1: threshold 0.35)
  const useBest = bestHit && (
    // Use if it's a PUA emoji (extends beyond Unicode)
    bestHit.item.hexcode.startsWith('E') ||
    // Use if no direct match exists
    !direct ||
    // Use if search result is significantly better (v2.1: 0.35 threshold)
    (direct && bestHit.score! < 0.35) // Score closer to 0 is better
  );

  // v2.1: Debug logging in development
  if (process.env.NODE_ENV !== 'production') {
    const searchPhase = (bestHit?.score ?? 1) <= 0.3 ? 'name-only' : 'name-with-tags';
    console.debug('[OpenMoji] Search result:', {
      name,
      tags,
      unicodeEmoji,
      searchPhase,
      direct: direct ? `${direct.emoji} (${direct.hexcode})` : null,
      bestHit: bestHit ? `${bestHit.item.emoji || bestHit.item.hexcode} (score: ${bestHit.score?.toFixed(3)})` : null,
      useBest,
      decision: useBest ? 'fuzzy' : 'direct'
    });
  }

  const datum = useBest ? bestHit.item : direct;
  const result = wrap(datum);
  
  // Cache the result
  resultCache.set(cacheKey, result);
  return result;
}

// v2.1: Helper function for consistent result wrapping
function wrap(datum?: OpenMojiData): ResolveEmojiResult {
  if (!datum) {
    const fallback = unicodeMap.get('‚ùì')!;
    return {
      hexcode: fallback.hexcode,
      svgPath: `/openmoji/${fallback.hexcode}.svg`,
      isExtra: false
    };
  }
  
  return {
    hexcode: datum.hexcode,
    svgPath: `/openmoji/${datum.hexcode}.svg`,
    isExtra: datum.hexcode.startsWith('E')
  };
}

/**
 * Converts Unicode emoji to hexcode sequence
 * Handles multi-codepoint emojis (flags, skin tones, ZWJ sequences)
 * UPDATED: Strips FE0F anywhere in the sequence
 */
export function unicodeToHexSequence(emoji: string): string {
  return [...emoji]
    .map(cp => cp.codePointAt(0)!)
    .filter(code => code !== 0xFE0F) // Remove variation selector-16 anywhere
    .map(code => code.toString(16).toUpperCase().padStart(4, '0'))
    .join('-');
}

/**
 * Helper function for static OpenMoji usage in UI components
 * Returns the SVG path for a given Unicode emoji
 */
export function getStaticOpenMoji(emoji: string): string {
  const hexcode = unicodeToHexSequence(emoji);
  return `/openmoji/${hexcode}.svg`;
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\openmoji-service.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase-client.ts ===== 
// DEPRECATED: This file has been refactored into separate files for better security
// Please update your imports to use:
// - import { ... } from '@/lib/supabase' for browser-safe functions
// - import { ... } from '@/lib/supabase/server' for server-only functions

console.warn('‚ö†Ô∏è DEPRECATED: Importing from @/lib/supabase-client is deprecated. Please update to @/lib/supabase');

// Re-export everything from new location for backwards compatibility
export * from './supabase';
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase-client.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\turnstile.ts ===== 
// Clean, minimal Turnstile implementation using explicit+execute pattern
// Works reliably on both desktop and mobile without hidden containers or timeouts

declare global {
  interface Window {
    turnstile?: {
      render: (element: string | HTMLElement, options: {
        sitekey: string;
        callback: (token: string) => void;
        'error-callback'?: () => void;
        'expired-callback'?: () => void;
        size?: 'normal' | 'compact' | 'flexible';
        theme?: 'light' | 'dark';
        appearance?: 'always' | 'execute' | 'interaction-only';
        execution?: 'render' | 'execute';
      }) => string;
      execute: (element: string | HTMLElement | string) => void;
      remove: (widgetId: string) => void;
      reset: (widgetId?: string) => void;
    };
  }
}

/**
 * Initialize Turnstile widget using explicit+execute pattern
 * This is the recommended approach that works on all devices
 * 
 * @param element - The HTML element to render the widget into
 * @param onToken - Callback when token is received (or null on error)
 * @returns Cleanup function to reset the widget
 */
export async function initTurnstile(
  element: HTMLElement,
  onToken: (token: string | null) => void
): Promise<(() => void) | null> {
  const siteKey = process.env.NEXT_PUBLIC_TURNSTILE_SITE_KEY;
  
  if (!siteKey) {
    console.warn('Turnstile site key not found');
    onToken(null);
    return null;
  }

  // Wait for Turnstile to load
  const loaded = await waitForTurnstile();
  if (!loaded) {
    console.warn('Turnstile failed to load');
    onToken(null);
    return null;
  }

  try {
    const widgetId = window.turnstile!.render(element, {
      sitekey: siteKey,
      execution: 'execute', // Explicit render, manual execute
      appearance: 'interaction-only', // Invisible until interaction needed
      theme: 'dark',
      callback: (token: string) => {
        onToken(token);
      },
      'error-callback': () => {
        console.error('Turnstile error');
        onToken(null);
      },
      'expired-callback': () => {
        console.warn('Turnstile token expired');
        onToken(null);
      }
    });

    // Return cleanup function
    return () => {
      try {
        window.turnstile?.reset(widgetId);
      } catch (e) {
        console.warn('Error resetting Turnstile:', e);
      }
    };
  } catch (error) {
    console.error('Error initializing Turnstile:', error);
    onToken(null);
    return null;
  }
}

/**
 * Execute Turnstile challenge on a rendered widget
 * Call this when user submits the form
 */
export function executeTurnstile(element: HTMLElement | string): void {
  if (typeof window !== 'undefined' && window.turnstile) {
    try {
      window.turnstile.execute(element);
    } catch (error) {
      console.error('Error executing Turnstile:', error);
    }
  }
}

/**
 * Check if Turnstile is loaded and ready
 */
export function isTurnstileReady(): boolean {
  return typeof window !== 'undefined' && !!window.turnstile;
}

/**
 * Wait for Turnstile to load
 */
export function waitForTurnstile(timeout = 5000): Promise<boolean> {
  return new Promise((resolve) => {
    if (isTurnstileReady()) {
      resolve(true);
      return;
    }

    const startTime = Date.now();
    const checkInterval = setInterval(() => {
      if (isTurnstileReady()) {
        clearInterval(checkInterval);
        resolve(true);
      } else if (Date.now() - startTime > timeout) {
        clearInterval(checkInterval);
        resolve(false);
      }
    }, 100);
  });
}

/**
 * Simple server verification helper
 * @param token - The Turnstile token to verify
 * @returns true if verification succeeded
 */
export async function verifyTurnstileToken(token: string): Promise<boolean> {
  try {
    const response = await fetch('/api/verify-turnstile', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token })
    });
    
    return response.ok;
  } catch (error) {
    console.error('Turnstile verification error:', error);
    return false;
  }
}

// Singleton widget for automated flows
let automatedWidgetId: string | null = null;
let automatedWidgetContainer: HTMLElement | null = null;
let pendingResolve: ((value: string | null) => void) | null = null;

/**
 * Get Turnstile token for automated flows (like anonymous user creation)
 * Uses a singleton widget pattern to avoid conflicts
 * 
 * Note: For form submissions, use initTurnstile() instead
 */
export async function getTurnstileToken(): Promise<string | null> {
  const siteKey = process.env.NEXT_PUBLIC_TURNSTILE_SITE_KEY;
  
  if (!siteKey || !isTurnstileReady()) {
    return null;
  }

  // Try to use existing container in modal first, otherwise create one
  if (!automatedWidgetContainer) {
    // Look for container inside the modal
    automatedWidgetContainer = document.getElementById('turnstile-container');
    
    if (!automatedWidgetContainer) {
      // Fallback: create floating container if modal isn't open
      automatedWidgetContainer = document.createElement('div');
      automatedWidgetContainer.id = 'turnstile-automated';
      automatedWidgetContainer.style.position = 'fixed';
      automatedWidgetContainer.style.bottom = '20px';
      automatedWidgetContainer.style.right = '20px';
      automatedWidgetContainer.style.zIndex = '9999';
      document.body.appendChild(automatedWidgetContainer);
    }
  }
  
  // Show the container before executing
  if (automatedWidgetContainer) {
    automatedWidgetContainer.style.display = '';
  }

  return new Promise((resolve) => {
    pendingResolve = resolve;

    // Extended timeout for slow mobile networks (20 seconds)
    const timeout = setTimeout(() => {
      pendingResolve = null;
      resolve(null);
    }, 20000);

    try {
      if (!automatedWidgetId && automatedWidgetContainer) {
        // First time - create widget
        automatedWidgetId = window.turnstile!.render(automatedWidgetContainer, {
          sitekey: siteKey,
          execution: 'execute', // Use explicit mode for better control
          appearance: 'interaction-only',
          theme: 'dark',
          callback: (token: string) => {
            clearTimeout(timeout);
            if (pendingResolve) {
              pendingResolve(token);
              pendingResolve = null;
            }
            // Clean up both iframe and container
            if (automatedWidgetId && window.turnstile) {
              window.turnstile.remove(automatedWidgetId);
              automatedWidgetId = null;
            }
            if (automatedWidgetContainer) {
              automatedWidgetContainer.style.display = 'none';
            }
          },
          'error-callback': () => {
            clearTimeout(timeout);
            if (pendingResolve) {
              pendingResolve(null);
              pendingResolve = null;
            }
          }
        });
      } else if (automatedWidgetId) {
        // Reset existing widget for fresh token
        window.turnstile!.reset(automatedWidgetId);
      }

      // Wait for next frame to ensure widget is ready
      requestAnimationFrame(() => {
        if (automatedWidgetId && window.turnstile) {
          window.turnstile.execute(automatedWidgetId);
        }
      });
    } catch {
      clearTimeout(timeout);
      resolve(null);
    }
  });
}

/**
 * Cleanup automated widget (call on page unload or route change)
 */
export function cleanupAutomatedWidget(): void {
  if (automatedWidgetId && window.turnstile) {
    try {
      window.turnstile.remove(automatedWidgetId);
    } catch {}
    automatedWidgetId = null;
  }
  
  if (automatedWidgetContainer) {
    try {
      document.body.removeChild(automatedWidgetContainer);
    } catch {}
    automatedWidgetContainer = null;
  }
  
  pendingResolve = null;
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\turnstile.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\ui-utils.ts ===== 
/**
 * UI utility functions shared across game components
 */

/**
 * Get contrast color (black or white) based on background color
 */
export const getContrastColor = (hexcolor: string): string => {
  const r = parseInt(hexcolor.slice(1, 3), 16);
  const g = parseInt(hexcolor.slice(3, 5), 16);
  const b = parseInt(hexcolor.slice(5, 7), 16);
  const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
  return (yiq >= 128) ? '#000000' : '#FFFFFF';
};

/**
 * Get rarity-based hover color for element cards
 */
export const getRarityHoverColor = (rarity: string = 'common'): string => {
  switch (rarity) {
    case 'uncommon': return '#10B981'; // Green
    case 'rare': return '#8B5CF6';     // Purple  
    default: return '#6B7280';         // Gray (common)
  }
};

/**
 * Get element size based on screen width (responsive design)
 */
export const getElementSize = (): number => {
  if (typeof window === 'undefined') return 56; // SSR fallback
  
  const BREAKPOINTS = { sm: 640, md: 768 };
  const ELEMENT_SIZES = { sm: 48, md: 56, lg: 64 };
  
  if (window.innerWidth < BREAKPOINTS.sm) return ELEMENT_SIZES.sm;
  if (window.innerWidth < BREAKPOINTS.md) return ELEMENT_SIZES.md;
  return ELEMENT_SIZES.lg;
};

/**
 * Detect if the device has touch capabilities
 */
export const isTouchDevice = (): boolean => {
  if (typeof window === 'undefined') return false; // SSR fallback
  return (('ontouchstart' in window) || navigator.maxTouchPoints > 0);
};

/**
 * Get element size classes for Tailwind CSS
 */
export const getElementSizeClasses = (): string => {
  return 'w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16';
};

/**
 * Get element emoji size classes based on element card size
 */
export const getElementEmojiSizeClasses = (): string => {
  return 'text-lg sm:text-xl';
};

/**
 * Get element name text size classes
 */
export const getElementNameSizeClasses = (): string => {
  return 'text-[8px] sm:text-[10px]';
};
 
===== END: C:\ai\LLM-Alchemy\src\lib\ui-utils.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase\browser.ts ===== 
// Client-side only Supabase client
// WARNING: This file MUST NOT import any server-side modules like next/headers
import { createBrowserClient } from '@supabase/ssr'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export function createClient() {
  return createBrowserClient(supabaseUrl, supabaseAnonKey)
}

// Client-side auth functions
export async function signInWithEmail(email: string, password: string) {
  const supabase = createClient()
  return supabase.auth.signInWithPassword({ email, password })
}

export async function signInWithGoogle() {
  const supabase = createClient()
  return supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${window.location.origin}/auth/callback`
    }
  })
}

// Re-export commonly used types
export type { SupabaseClient } from '@supabase/supabase-js'
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase\browser.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase\helpers.ts ===== 
import type { SupabaseClient } from '@supabase/supabase-js'
import type { User, GameState, GameProgress } from '@/types'

// Generic Supabase client type that accepts different client configurations
// This allows compatibility with both browser and server clients
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type GenericSupabaseClient = SupabaseClient<any, any, any>

// Prevent multiple simultaneous signup attempts
let isCreatingUser = false;
let lastAttemptTime = 0;
const MIN_RETRY_INTERVAL = 5000; // 5 seconds between attempts

// Helper functions for common database operations
export async function getOrCreateAnonymousUser(supabase: GenericSupabaseClient): Promise<User | null> {
  try {
    // Prevent multiple simultaneous calls
    if (isCreatingUser) {
      console.log('Anonymous user creation already in progress, waiting...');
      return null;
    }
    
    // Rate limiting: prevent rapid retry attempts
    const now = Date.now();
    if (now - lastAttemptTime < MIN_RETRY_INTERVAL) {
      console.log('Too soon to retry anonymous user creation');
      return null;
    }
    
    lastAttemptTime = now;

    // First check for existing session to prevent duplicate signups
    const { data: { session } } = await supabase.auth.getSession()
    
    if (session?.user) {
      // Get existing user record from our database
      const { data: dbUser } = await supabase
        .from('users')
        .select('*')
        .eq('id', session.user.id)
        .single()
      
      if (dbUser) {
        return dbUser as User
      }
    }

    isCreatingUser = true;

    // Create anonymous user with Turnstile protection and timeout fallback
    let captchaToken: string | undefined;
    
    // Get Turnstile token with shorter timeout for better UX
    try {
      const { getTurnstileToken, waitForTurnstile } = await import('../turnstile');
      const turnstileReady = await waitForTurnstile(3000); // 3 seconds to load
      
      if (turnstileReady) {
        // Get Turnstile token with 5 second timeout (matches the function's internal timeout)
        captchaToken = await getTurnstileToken() || undefined;
      }
    } catch (error) {
      console.warn('Turnstile not available, proceeding without captcha:', error);
    }

    const { data, error } = await supabase.auth.signInAnonymously(
      captchaToken ? { options: { captchaToken } } : undefined
    )
    
    if (error || !data.user) {
      console.error('Error creating anonymous user:', error)
      // If it's a captcha error, don't retry immediately
      if (error?.message?.includes('captcha')) {
        lastAttemptTime = now + MIN_RETRY_INTERVAL; // Force longer wait
      }
      return null
    }

    // Create user record in our database
    const newUser = {
      id: data.user.id,
      email: null,
      is_anonymous: true,
      subscription_status: 'free' as const,
      subscription_ends_at: null
    }

    const { data: dbUser, error: dbError } = await supabase
      .from('users')
      .insert([newUser])
      .select()
      .single()

    if (dbError) {
      console.error('Error creating user record:', dbError)
      return null
    }

    // Store anonymous user ID for potential migration later
    if (typeof window !== 'undefined') {
      localStorage.setItem('anonymous_user_id', data.user.id)
    }

    return dbUser as User

  } catch (error) {
    console.error('Error in getOrCreateAnonymousUser:', error)
    return null
  } finally {
    isCreatingUser = false;
  }
}

export async function getDailyCount(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    const today = new Date().toISOString().split('T')[0]
    
    const { data, error } = await supabase
      .from('user_sessions')
      .select('daily_count')
      .eq('user_id', userId)
      .eq('date', today)
      .single()
    
    if (error) {
      // Handle different error types gracefully
      if (error.code === 'PGRST116') {
        // No rows returned - user hasn't used any combinations today
        return 0
      } else if (error.code === 'PGRST301' || error.message?.includes('406')) {
        // RLS policy issues - return 0 and continue silently (expected for anonymous users)
        return 0
      } else {
        console.error('Error getting daily count:', error)
        return 0
      }
    }
    
    return data?.daily_count || 0
  } catch (error) {
    console.error('Error in getDailyCount:', error)
    return 0
  }
}

export async function incrementDailyCount(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    // Use the database function to atomically increment
    const { data, error } = await supabase.rpc('increment_daily_count', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error incrementing daily count:', error)
      return 0
    }

    return data || 1
  } catch (error) {
    console.error('Error in incrementDailyCount:', error)
    return 0
  }
}

export async function decrementDailyCount(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    // Use the database function to atomically decrement
    const { data, error } = await supabase.rpc('decrement_daily_count', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error decrementing daily count:', error)
      return 0
    }

    return data || 0
  } catch (error) {
    console.error('Error in decrementDailyCount:', error)
    return 0
  }
}

export async function saveGameState(supabase: GenericSupabaseClient, userId: string, gameState: Partial<GameState>): Promise<boolean> {
  try {
    const { error } = await supabase
      .from('game_states')
      .upsert({
        user_id: userId,
        ...gameState,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'user_id,game_mode'
      })

    if (error) {
      console.error('Error saving game state:', error)
      return false
    }

    return true
  } catch (error) {
    console.error('Error in saveGameState:', error)
    return false
  }
}

export async function loadGameState(supabase: GenericSupabaseClient, userId: string, gameMode: string): Promise<GameState | null> {
  try {
    const { data, error } = await supabase
      .from('game_states')
      .select('*')
      .eq('user_id', userId)
      .eq('game_mode', gameMode)
      .single()

    if (error) {
      // Handle different error types gracefully
      if (error.code === 'PGRST116') {
        // No rows returned - no saved state for this mode
        return null
      } else if (error.code === 'PGRST301' || error.message?.includes('406')) {
        // RLS policy issues - return null and continue silently (expected for anonymous users)
        return null
      } else {
        console.error('Error loading game state:', error)
        return null
      }
    }

    return data as GameState
  } catch (error) {
    console.error('Error in loadGameState:', error)
    return null
  }
}

export async function getGameProgress(supabase: GenericSupabaseClient, userId: string): Promise<GameProgress> {
  try {
    const { data, error } = await supabase
      .from('game_states')
      .select('*')
      .eq('user_id', userId)

    if (error && error.code !== 'PGRST116') {
      console.error('Error getting game progress:', error)
      return { science: null, creative: null, lastMode: 'science' }
    }

    if (!data || data.length === 0) {
      return { science: null, creative: null, lastMode: 'science' }
    }

    const progress: GameProgress = {
      science: null,
      creative: null,
      lastMode: 'science'
    }

    // Find the most recently updated mode
    let latestUpdate = 0
    
    data.forEach((gameState: GameState) => {
      const updatedAt = new Date(gameState.updated_at).getTime()
      if (updatedAt > latestUpdate) {
        latestUpdate = updatedAt
        progress.lastMode = gameState.game_mode
      }

      const modeProgress = {
        elements: Array.isArray(gameState.elements) ? gameState.elements.length : 0,
        endElements: Array.isArray(gameState.end_elements) ? gameState.end_elements.length : 0,
        achievements: Array.isArray(gameState.achievements) ? gameState.achievements.length : 0,
        lastPlayed: gameState.updated_at
      }

      if (gameState.game_mode === 'science') {
        progress.science = modeProgress
      } else if (gameState.game_mode === 'creative') {
        progress.creative = modeProgress
      }
    })

    return progress
  } catch (error) {
    console.error('Error in getGameProgress:', error)
    return { science: null, creative: null, lastMode: 'science' }
  }
}

export async function resetGameState(supabase: GenericSupabaseClient, userId: string, gameMode: string, includeAchievements: boolean = false): Promise<boolean> {
  try {
    if (includeAchievements) {
      // Delete the entire game state record
      const { error } = await supabase
        .from('game_states')
        .delete()
        .eq('user_id', userId)
        .eq('game_mode', gameMode)

      if (error) {
        console.error('Error deleting game state:', error)
        return false
      }
    } else {
      // Get existing achievements first
      const existingState = await loadGameState(supabase, userId, gameMode)
      const existingAchievements = existingState?.achievements || []
      
      // Reset but keep achievements
      const { error } = await supabase
        .from('game_states')
        .upsert({
          user_id: userId,
          game_mode: gameMode,
          elements: [],
          end_elements: [],
          combinations: {},
          achievements: existingAchievements, // Preserve existing achievements
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id,game_mode'
        })

      if (error) {
        console.error('Error resetting game state:', error)
        return false
      }
    }

    return true
  } catch (error) {
    console.error('Error in resetGameState:', error)
    return false
  }
}

// Token-related functions
export async function getTokenBalance(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    const { data, error } = await supabase.rpc('get_token_balance', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error getting token balance:', error)
      return 0
    }

    return data || 0
  } catch (error) {
    console.error('Error in getTokenBalance:', error)
    return 0
  }
}

export async function consumeToken(supabase: GenericSupabaseClient, userId: string): Promise<boolean> {
  try {
    const { data, error } = await supabase.rpc('consume_token', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error consuming token:', error)
      return false
    }

    return data || false
  } catch (error) {
    console.error('Error in consumeToken:', error)
    return false
  }
}

export async function addTokens(supabase: GenericSupabaseClient, userId: string, tokens: number): Promise<number> {
  try {
    const { data, error } = await supabase.rpc('add_tokens', {
      p_user_id: userId,
      p_tokens: tokens
    })

    if (error) {
      console.error('Error adding tokens:', error)
      return 0
    }

    return data || 0
  } catch (error) {
    console.error('Error in addTokens:', error)
    return 0
  }
}

// Monthly usage tracking functions for subscription fair use
export async function getMonthlyUsage(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    const { data, error } = await supabase.rpc('get_monthly_usage', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error getting monthly usage:', error)
      return 0
    }

    return data || 0
  } catch (error) {
    console.error('Error in getMonthlyUsage:', error)
    return 0
  }
}

export async function incrementMonthlyUsage(supabase: GenericSupabaseClient, userId: string): Promise<number> {
  try {
    const { data, error } = await supabase.rpc('increment_monthly_usage', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error incrementing monthly usage:', error)
      return 0
    }

    return data || 0
  } catch (error) {
    console.error('Error in incrementMonthlyUsage:', error)
    return 0
  }
}

export async function hasExceededFairUse(supabase: GenericSupabaseClient, userId: string): Promise<boolean> {
  try {
    const { data, error } = await supabase.rpc('has_exceeded_fair_use', {
      p_user_id: userId
    })

    if (error) {
      console.error('Error checking fair use limit:', error)
      return false
    }

    return data || false
  } catch (error) {
    console.error('Error in hasExceededFairUse:', error)
    return false
  }
}

// LLM Model preference functions
export async function getLlmModelPreference(supabase: GenericSupabaseClient, userId: string): Promise<'flash' | 'pro'> {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('llm_model')
      .eq('id', userId)
      .single()

    if (error) {
      console.error('Error getting LLM model preference:', error)
      return 'flash'
    }

    return data?.llm_model || 'flash'
  } catch (error) {
    console.error('Error in getLlmModelPreference:', error)
    return 'flash'
  }
}

export async function updateLlmModelPreference(supabase: GenericSupabaseClient, userId: string, model: 'flash' | 'pro'): Promise<boolean> {
  try {
    const { error } = await supabase
      .from('users')
      .update({ llm_model: model })
      .eq('id', userId)

    if (error) {
      console.error('Error updating LLM model preference:', error)
      return false
    }

    return true
  } catch (error) {
    console.error('Error in updateLlmModelPreference:', error)
    return false
  }
}

// Challenge preference functions
export async function getChallengePreference(supabase: GenericSupabaseClient, userId: string): Promise<boolean> {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('show_challenges')
      .eq('id', userId)
      .single()

    if (error) {
      console.error('Error getting challenge preference:', error)
      return true // Default to showing challenges
    }

    return data?.show_challenges ?? true
  } catch (error) {
    console.error('Error in getChallengePreference:', error)
    return true
  }
}

export async function updateChallengePreference(supabase: GenericSupabaseClient, userId: string, showChallenges: boolean): Promise<boolean> {
  try {
    const { error } = await supabase
      .from('users')
      .update({ show_challenges: showChallenges })
      .eq('id', userId)

    if (error) {
      console.error('Error updating challenge preference:', error)
      return false
    }

    return true
  } catch (error) {
    console.error('Error in updateChallengePreference:', error)
    return false
  }
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase\helpers.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase\index.ts ===== 
// Safe barrel export - only browser-safe symbols
// This file ensures no server-only code leaks to the client

// Export browser client and auth functions
export { createClient, signInWithEmail, signInWithGoogle } from './browser'

// Export all helper functions (runtime-agnostic)
export {
  getOrCreateAnonymousUser,
  getDailyCount,
  incrementDailyCount,
  decrementDailyCount,
  saveGameState,
  loadGameState,
  getGameProgress,
  resetGameState,
  getTokenBalance,
  consumeToken,
  addTokens,
  getMonthlyUsage,
  incrementMonthlyUsage,
  hasExceededFairUse,
  getLlmModelPreference,
  updateLlmModelPreference,
  getChallengePreference,
  updateChallengePreference,
} from './helpers'

// Export types
export type {
  User,
  UserSession,
  GameState,
  Element,
  Achievement,
  DiscoveredElement,
  GameProgress,
} from './types'

// DO NOT EXPORT SERVER-ONLY FUNCTIONS:
// - createServerSupabaseClient
// - createServiceRoleClient  
// - createMiddlewareClient
//
// These must be imported directly from './server' in server-side code only
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase\index.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase\server.ts ===== 
import { createServerClient } from '@supabase/ssr'
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

// Server client for API routes
export async function createServerSupabaseClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: Record<string, unknown>) {
          cookieStore.set({ name, value, ...options })
        },
        remove(name: string, options: Record<string, unknown>) {
          cookieStore.delete({ name, ...options })
        },
      },
    }
  )
}

// Service role client for admin operations (bypasses RLS)
export async function createServiceRoleClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: Record<string, unknown>) {
          cookieStore.set({ name, value, ...options })
        },
        remove(name: string, options: Record<string, unknown>) {
          cookieStore.delete({ name, ...options })
        },
      },
    }
  )
}

// Middleware client for request handling
export function createMiddlewareClient(request: NextRequest) {
  const response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: Record<string, unknown>) {
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: Record<string, unknown>) {
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  return { supabase, response }
}
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase\server.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\lib\supabase\types.ts ===== 
// DEPRECATED: Import types from @/types instead
console.warn('‚ö†Ô∏è Importing types from @/lib/supabase/types is deprecated. Please import from @/types instead.');

// Re-export from new location for backwards compatibility
export type { User, UserSession, Element, GameState, Achievement, DiscoveredElement, GameProgress } from '@/types'
 
===== END: C:\ai\LLM-Alchemy\src\lib\supabase\types.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\styles\animations.css ===== 
/* LLM Alchemy Game Animations */
/* Extracted from original component to make them globally available */

/* Mobile scrollbar styles */
.scrollbar-mobile {
  scrollbar-width: thin;
  scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
}

.scrollbar-mobile::-webkit-scrollbar {
  width: 6px;
}

.scrollbar-mobile::-webkit-scrollbar-track {
  background: transparent;
}

.scrollbar-mobile::-webkit-scrollbar-thumb {
  background-color: rgba(156, 163, 175, 0.5);
  border-radius: 3px;
}

.scrollbar-mobile::-webkit-scrollbar-thumb:hover {
  background-color: rgba(156, 163, 175, 0.7);
}

/* Show scrollbar on mobile when content overflows */
@media (max-width: 768px) {
  .scrollbar-mobile::-webkit-scrollbar {
    width: 8px;
  }
  
  .scrollbar-mobile::-webkit-scrollbar-thumb {
    background-color: rgba(156, 163, 175, 0.6);
  }
}

/* Animation Keyframes */
@keyframes shake {
  0%, 100% { transform: translateX(0) rotate(0deg); }
  25% { transform: translateX(-1px) rotate(-0.5deg); }
  75% { transform: translateX(1px) rotate(0.5deg); }
}

@keyframes zoom-pulse {
  0% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes end-zoom-pulse {
  0% { transform: scale(0) rotate(0deg); opacity: 0; }
  50% { transform: scale(1.1) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

@keyframes small-pulse {
  0% { transform: scale(0.8); opacity: 0; }
  50% { transform: scale(1.05); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes mix-pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); opacity: 0.7; }
  100% { transform: scale(0); opacity: 0; }
}

@keyframes element-pop-in {
  0% { transform: scale(0); opacity: 0; }
  70% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes element-pop-out {
  0% { transform: scale(1); opacity: 1; }
  30% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(0); opacity: 0; }
}

@keyframes element-load-delayed {
  0% { transform: scale(0); opacity: 0; }
  70% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes element-remove-staggered {
  0% { transform: scale(1); opacity: 1; }
  30% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(0); opacity: 0; }
}

@keyframes mixing-blur {
  0%, 100% { backdrop-filter: blur(0px); }
  50% { backdrop-filter: blur(4px); }
}

@keyframes fade-in {
  0% { opacity: 0; }
  100% { opacity: 1; }
}

@keyframes element-drop-in {
  0% { transform: scale(0) rotate(-180deg); opacity: 0; }
  60% { transform: scale(1.1) rotate(0deg); opacity: 1; }
  100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

@keyframes element-unlock-bounce {
  0% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.15); opacity: 1; }
  75% { transform: scale(0.95); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes element-pop {
  0% { transform: scale(0); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

@keyframes element-shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-3px); }
  75% { transform: translateX(3px); }
}

@keyframes continuous-pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.15); }
}

/* Animation Utility Classes */
.animate-shake {
  animation: shake 0.5s ease-in-out infinite;
}

.animate-zoom-pulse {
  animation: zoom-pulse 0.5s ease-out;
}

.animate-end-zoom-pulse {
  animation: end-zoom-pulse 0.6s ease-out;
}

.animate-small-pulse {
  animation: small-pulse 0.3s ease-out;
}

.animate-mix-pop {
  animation: mix-pop 0.6s ease-out forwards;
}

.animate-element-pop {
  animation: element-pop 0.3s ease-out;
}

.animate-element-pop-in {
  animation: element-pop-in 0.3s ease-out;
}

.animate-element-pop-out {
  animation: element-pop-out 0.3s ease-out forwards;
}

.animate-element-load-delayed {
  animation: element-load-delayed 0.3s ease-out;
  animation-fill-mode: both;
  animation-delay: var(--animation-delay, 0ms);
}

.animate-element-remove-staggered {
  animation: element-remove-staggered 0.3s ease-out forwards;
}

.animate-element-shake {
  animation: element-shake 0.3s ease-out;
}

.animate-continuous-pulse {
  animation: continuous-pulse 1s ease-in-out infinite;
}

.animate-mixing-blur {
  animation: mixing-blur 2s ease-in-out infinite;
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out;
}

.animate-element-drop-in {
  animation: element-drop-in 0.4s ease-out;
}

.animate-element-unlock-bounce {
  animation: element-unlock-bounce 0.5s ease-out;
}

/* Element Dimming for Drag Feedback */
.element-dimmed {
  opacity: 0.3;
  transition: opacity 0.2s ease-in-out;
}

/* Button Styles */
.btn {
  @apply px-3 py-2 rounded-lg font-medium transition-colors;
}

.btn-sm {
  @apply px-2 py-1 text-sm;
}

.btn-science {
  @apply bg-blue-600 hover:bg-blue-500 text-white;
}

.btn-creative {
  @apply bg-purple-600 hover:bg-purple-500 text-white;
}

.btn-surface {
  @apply bg-gray-700 hover:bg-gray-600 text-white;
}

.btn-danger {
  @apply bg-red-600 hover:bg-red-500 text-white;
}

/* Modal Backdrop */
.modal-backdrop {
  @apply fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4;
}
 
===== END: C:\ai\LLM-Alchemy\src\styles\animations.css ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\types\challenge.types.ts ===== 
// Challenge system types
export interface Challenge {
  id: string;
  challenge_type: 'daily' | 'weekly';
  title: string;
  target_element?: string;
  target_category?: string;
  game_mode?: 'science' | 'creative' | 'any';
  reward_tokens: number;
  start_date: string;
  end_date: string;
  isCompleted: boolean;
  completionDetails?: {
    element_discovered: string;
    game_mode: string;
    completed_at: string;
  } | null;
}

export interface ChallengeBarProps {
  isAnonymous?: boolean;
  currentGameMode?: 'science' | 'creative';
}
 
===== END: C:\ai\LLM-Alchemy\src\types\challenge.types.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\types\db.generated.ts ===== 
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      challenge_completions: {
        Row: {
          challenge_id: string
          completed_at: string
          element_discovered: string
          game_mode: string
          id: string
          user_id: string
        }
        Insert: {
          challenge_id: string
          completed_at?: string
          element_discovered: string
          game_mode: string
          id?: string
          user_id: string
        }
        Update: {
          challenge_id?: string
          completed_at?: string
          element_discovered?: string
          game_mode?: string
          id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "challenge_completions_challenge_id_fkey"
            columns: ["challenge_id"]
            isOneToOne: false
            referencedRelation: "challenges"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "challenge_completions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      challenges: {
        Row: {
          challenge_type: string
          created_at: string
          end_date: string
          game_mode: string | null
          id: string
          reward_tokens: number
          start_date: string
          target_category: string | null
          target_element: string | null
          title: string
        }
        Insert: {
          challenge_type: string
          created_at?: string
          end_date: string
          game_mode?: string | null
          id?: string
          reward_tokens?: number
          start_date: string
          target_category?: string | null
          target_element?: string | null
          title: string
        }
        Update: {
          challenge_type?: string
          created_at?: string
          end_date?: string
          game_mode?: string | null
          id?: string
          reward_tokens?: number
          start_date?: string
          target_category?: string | null
          target_element?: string | null
          title?: string
        }
        Relationships: []
      }
      game_states: {
        Row: {
          created_at: string
          elements: Json | null
          game_mode: string
          id: string
          total_elements: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          elements?: Json | null
          game_mode?: string
          id?: string
          total_elements?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          elements?: Json | null
          game_mode?: string
          id?: string
          total_elements?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "game_states_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      payments: {
        Row: {
          amount: number
          created_at: string
          currency: string
          id: string
          status: string
          stripe_customer_id: string | null
          stripe_payment_id: string | null
          stripe_session_id: string
          tokens_granted: number | null
          type: string
          updated_at: string
          user_id: string
          webhook_data: Json | null
        }
        Insert: {
          amount: number
          created_at?: string
          currency?: string
          id?: string
          status?: string
          stripe_customer_id?: string | null
          stripe_payment_id?: string | null
          stripe_session_id: string
          tokens_granted?: number | null
          type: string
          updated_at?: string
          user_id: string
          webhook_data?: Json | null
        }
        Update: {
          amount?: number
          created_at?: string
          currency?: string
          id?: string
          status?: string
          stripe_customer_id?: string | null
          stripe_payment_id?: string | null
          stripe_session_id?: string
          tokens_granted?: number | null
          type?: string
          updated_at?: string
          user_id?: string
          webhook_data?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "payments_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriptions: {
        Row: {
          canceled_at: string | null
          created_at: string
          id: string
          next_payment_date: string | null
          status: string
          stripe_customer_id: string
          stripe_subscription_id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          canceled_at?: string | null
          created_at?: string
          id?: string
          next_payment_date?: string | null
          status: string
          stripe_customer_id: string
          stripe_subscription_id: string
          updated_at?: string
          user_id: string
        }
        Update: {
          canceled_at?: string | null
          created_at?: string
          id?: string
          next_payment_date?: string | null
          status?: string
          stripe_customer_id?: string
          stripe_subscription_id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "subscriptions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      users: {
        Row: {
          challenge_preference: boolean | null
          created_at: string
          daily_count: number | null
          email: string | null
          id: string
          is_anonymous: boolean | null
          llm_model_preference: string | null
          monthly_usage: number | null
          subscription_ends_at: string | null
          subscription_status: string | null
          token_balance: number | null
          updated_at: string
        }
        Insert: {
          challenge_preference?: boolean | null
          created_at?: string
          daily_count?: number | null
          email?: string | null
          id: string
          is_anonymous?: boolean | null
          llm_model_preference?: string | null
          monthly_usage?: number | null
          subscription_ends_at?: string | null
          subscription_status?: string | null
          token_balance?: number | null
          updated_at?: string
        }
        Update: {
          challenge_preference?: boolean | null
          created_at?: string
          daily_count?: number | null
          email?: string | null
          id?: string
          is_anonymous?: boolean | null
          llm_model_preference?: string | null
          monthly_usage?: number | null
          subscription_ends_at?: string | null
          subscription_status?: string | null
          token_balance?: number | null
          updated_at?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      create_stripe_payment: {
        Args: {
          p_user_id: string
          p_stripe_session_id: string
          p_amount: number
          p_currency: string
          p_type: string
          p_tokens_granted: number
        }
        Returns: string
      }
      increment_user_tokens: {
        Args: {
          p_user_id: string
          p_amount: number
        }
        Returns: number
      }
      update_stripe_payment_status: {
        Args: {
          p_stripe_session_id: string
          p_stripe_payment_id: string
          p_status: string
          p_stripe_customer_id: string
          p_webhook_data: Json
        }
        Returns: boolean
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof PublicSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema["CompositeTypes"]
    ? PublicSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
 
===== END: C:\ai\LLM-Alchemy\src\types\db.generated.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\types\game.types.ts ===== 
// GameElement, GameState, etc. (domain-prefixed)

// Comprehensive game element structure used throughout the game
export interface Element {
  id: string;
  name: string;
  emoji: string;
  color: string;
  unlockOrder: number;
  rarity?: string;
  reasoning?: string;
  // Tag separation for different purposes
  achievementTags?: string[];  // For achievements and challenges
  emojiTags?: string[];        // For OpenMoji visual search
  tags?: string[];             // Legacy fallback for backwards compatibility
  isEndElement?: boolean;
  parents?: Element[];
  energyEnhanced?: boolean;
  // OpenMoji-specific fields (only for PUA emojis)
  openmojiHex?: string;      // Hexcode for non-Unicode emojis
  isOpenmojiExtra?: boolean; // True if using PUA emoji
}

// Comprehensive achievement structure with tiering support
export interface Achievement {
  id: string;
  name: string;
  description: string;
  emoji: string;
  unlocked: number;
  // Tiering support
  isProgressive?: boolean;
  countType?: string;
  tier?: 1 | 2 | 3;
  currentCount?: number;
  nextTierAt?: number | null;
}

export interface GameState {
  id: string
  user_id: string
  game_mode: 'science' | 'creative'
  elements: Element[]
  end_elements: Element[]
  combinations: Record<string, string | null>
  achievements: Achievement[]
  failed_combinations: string[]
  updated_at: string
}

export interface DiscoveredElement {
  user_id: string
  element_name: string
  discovered_at: string
}

// Helper type for game progress data
export interface GameProgress {
  science: { 
    elements: number
    endElements: number
    achievements: number
    lastPlayed?: string 
  } | null
  creative: { 
    elements: number
    endElements: number
    achievements: number
    lastPlayed?: string 
  } | null
  lastMode: 'science' | 'creative'
}
 
===== END: C:\ai\LLM-Alchemy\src\types\game.types.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\types\index.ts ===== 
// Barrel export file
export * from './user.types'
export * from './game.types'
export * from './challenge.types'
// TODO: Add db.generated export once Supabase types are generated
// export * from './db.generated'
 
===== END: C:\ai\LLM-Alchemy\src\types\index.ts ===== 
 
 
===== START: C:\ai\LLM-Alchemy\src\types\user.types.ts ===== 
// User-related interfaces
export interface User {
  id: string
  email?: string | null
  created_at: string
  is_anonymous: boolean
  subscription_status: 'free' | 'premium'
  subscription_ends_at?: string | null
  token_balance?: number
  display_name?: string | null
  avatar_url?: string | null
  google_id?: string | null
  email_verified?: boolean
  upgraded_from_anonymous?: boolean
  anonymous_data_migrated?: boolean
  llm_model?: 'flash' | 'pro'
  show_challenges?: boolean
}

export interface UserSession {
  id: string
  user_id: string
  date: string
  daily_count: number
  created_at: string
  updated_at: string
}
 
===== END: C:\ai\LLM-Alchemy\src\types\user.types.ts ===== 
 
 
