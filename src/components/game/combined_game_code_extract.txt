===== START: C:\AI\LLM-Alchemy\src\components\game\ChallengeBar.tsx ===== 
'use client';

import { useEffect, useState } from 'react';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, getChallengePreference } from '@/lib/supabase';
import { getStaticOpenMoji } from '@/lib/openmoji-service';
import { Challenge, ChallengeBarProps } from '@/types';

export function ChallengeBar({ isAnonymous, currentGameMode }: ChallengeBarProps) {
  const { user } = useSupabase();
  const [challenges, setChallenges] = useState<Challenge[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hiddenChallenges, setHiddenChallenges] = useState<Set<string>>(new Set());
  const [showChallenges, setShowChallenges] = useState<boolean>(true);

  // Load hidden challenges from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('llm-alchemy-hidden-challenges');
    if (saved) {
      try {
        const hiddenIds = JSON.parse(saved);
        setHiddenChallenges(new Set(hiddenIds));
      } catch (error) {
        console.error('Error loading hidden challenges:', error);
      }
    }
  }, []);

  // Save hidden challenges to localStorage whenever it changes
  useEffect(() => {
    if (hiddenChallenges.size > 0) {
      localStorage.setItem('llm-alchemy-hidden-challenges', JSON.stringify([...hiddenChallenges]));
    }
  }, [hiddenChallenges]);

  // Load challenge preference for authenticated users
  useEffect(() => {
    const loadChallengePreference = async () => {
      if (user && !isAnonymous) {
        const supabase = createClient();
        const preference = await getChallengePreference(supabase, user.id);
        setShowChallenges(preference);
      }
    };

    loadChallengePreference();
  }, [user, isAnonymous]);

  useEffect(() => {
    fetchChallenges();
    // Refresh challenges every 10 minutes (for testing phase)
    const interval = setInterval(fetchChallenges, 600000); // 10 minutes
    return () => clearInterval(interval);
  }, []);

  // Auto-hide completed challenges after 3 seconds
  useEffect(() => {
    const completedIds = challenges
      .filter(c => c.isCompleted)
      .map(c => c.id);

    if (completedIds.length > 0) {
      const timer = setTimeout(() => {
        setHiddenChallenges(prev => {
          const newSet = new Set(prev);
          completedIds.forEach(id => newSet.add(id));
          return newSet;
        });
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [challenges]);

  const fetchChallenges = async () => {
    try {
      const response = await fetch('/api/challenges/current');
      if (!response.ok) throw new Error('Failed to fetch challenges');
      
      const data = await response.json();
      setChallenges(data.challenges || []);
      setError(null);
    } catch (err) {
      console.error('Error fetching challenges:', err);
      setError('Failed to load challenges');
    } finally {
      setLoading(false);
    }
  };

  const hideChallenge = (challengeId: string) => {
    setHiddenChallenges(prev => new Set([...prev, challengeId]));
  };

  // Don't show anything for anonymous users - challenges are for registered users only
  if (isAnonymous) {
    return null;
  }

  // Don't show challenges if user has disabled them
  if (!showChallenges) return null;

  if (loading) return null;
  if (error) return null;
  if (challenges.length === 0) return null;

  // Filter challenges by game mode and hidden status
  const filterChallengesByMode = (challenge: Challenge) => {
    if (hiddenChallenges.has(challenge.id)) return false;
    
    // If no currentGameMode provided, show all challenges (main menu case)
    if (!currentGameMode) return true;
    
    // Show "any" mode challenges or challenges matching current game mode
    return challenge.game_mode === 'any' || challenge.game_mode === currentGameMode;
  };

  const dailyChallenges = challenges.filter(c => c.challenge_type === 'daily' && filterChallengesByMode(c));
  const weeklyChallenges = challenges.filter(c => c.challenge_type === 'weekly' && filterChallengesByMode(c));

  return (
    <div className="challenge-bar-container mb-4 relative z-50">
      <div className="flex flex-wrap gap-3">
        {/* Daily Challenges */}
        {dailyChallenges.map((challenge) => (
          <div
            key={challenge.id}
            className="challenge-item transition-all duration-300 flex-1 min-w-0 max-w-md"
          >
            <div className="flex items-center justify-between p-3 rounded-lg bg-surface-secondary border border-primary/20">
              <div className="flex items-center gap-3 flex-1">
                <img src={getStaticOpenMoji('🌟')} alt="Star" className="w-8 h-8" />
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-muted uppercase tracking-wider">Daily Quest</span>
                    {challenge.game_mode && (
                      <span className={`text-xs px-2 py-0.5 rounded ${
                        challenge.game_mode === 'science' ? 'bg-blue-500/20 text-blue-300' :
                        challenge.game_mode === 'creative' ? 'bg-purple-500/20 text-purple-300' :
                        'bg-gray-500/20 text-gray-300'
                      }`}>
                        {challenge.game_mode === 'science' ? <><img src={getStaticOpenMoji('🔬')} alt="Science" className="inline w-3 h-3" /> Science</> :
                         challenge.game_mode === 'creative' ? <><img src={getStaticOpenMoji('🎨')} alt="Creative" className="inline w-3 h-3" /> Creative</> :
                         <><img src={getStaticOpenMoji('🌟')} alt="Star" className="inline w-3 h-3" /> Any Mode</>}
                      </span>
                    )}
                    {challenge.isCompleted && (
                      <span className="text-xs text-success">✓ Completed</span>
                    )}
                  </div>
                  <p className="text-body font-medium">{challenge.title}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className="text-right">
                  <div className="flex items-center gap-1">
                    <span className="text-sm text-warning">+{challenge.reward_tokens}</span>
                    <span className="text-xs text-muted">tokens</span>
                  </div>
                  {challenge.isCompleted && challenge.completionDetails && (
                    <p className="text-xs text-muted mt-1">
                      Found: {challenge.completionDetails.element_discovered}
                    </p>
                  )}
                </div>
                <button
                  onClick={() => hideChallenge(challenge.id)}
                  className="text-gray-400 hover:text-gray-300 transition-colors p-1"
                  title="Hide challenge"
                >
                  ✕
                </button>
              </div>
            </div>
          </div>
        ))}

        {/* Weekly Challenge */}
        {weeklyChallenges.map((challenge) => (
          <div
            key={challenge.id}
            className="challenge-item transition-all duration-300"
          >
            <div className="flex items-center justify-between p-3 rounded-lg bg-surface-secondary border border-warning/30">
              <div className="flex items-center gap-3 flex-1">
                <img src={getStaticOpenMoji('🏆')} alt="Trophy" className="w-8 h-8" />
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-muted uppercase tracking-wider">Weekly Challenge</span>
                    {challenge.game_mode && (
                      <span className={`text-xs px-2 py-0.5 rounded ${
                        challenge.game_mode === 'science' ? 'bg-blue-500/20 text-blue-300' :
                        challenge.game_mode === 'creative' ? 'bg-purple-500/20 text-purple-300' :
                        'bg-gray-500/20 text-gray-300'
                      }`}>
                        {challenge.game_mode === 'science' ? <><img src={getStaticOpenMoji('🔬')} alt="Science" className="inline w-3 h-3" /> Science</> :
                         challenge.game_mode === 'creative' ? <><img src={getStaticOpenMoji('🎨')} alt="Creative" className="inline w-3 h-3" /> Creative</> :
                         <><img src={getStaticOpenMoji('🌟')} alt="Star" className="inline w-3 h-3" /> Any Mode</>}
                      </span>
                    )}
                    {challenge.isCompleted && (
                      <span className="text-xs text-success">✓ Completed</span>
                    )}
                  </div>
                  <p className="text-body font-medium">{challenge.title}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className="text-right">
                  <div className="flex items-center gap-1">
                    <span className="text-sm text-warning">+{challenge.reward_tokens}</span>
                    <span className="text-xs text-muted">tokens</span>
                  </div>
                  {challenge.isCompleted && challenge.completionDetails && (
                    <p className="text-xs text-muted mt-1">
                      Mode: {challenge.completionDetails.game_mode}
                    </p>
                  )}
                </div>
                <button
                  onClick={() => hideChallenge(challenge.id)}
                  className="text-gray-400 hover:text-gray-300 transition-colors p-1"
                  title="Hide challenge"
                >
                  ✕
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
 
===== END: C:\AI\LLM-Alchemy\src\components\game\ChallengeBar.tsx ===== 
 

 
===== START: C:\AI\LLM-Alchemy\src\components\game\OpenMojiDisplay.tsx ===== 
import React, { memo, useState } from 'react';
import { unicodeToHexSequence } from '@/lib/openmoji-service';

interface OpenMojiDisplayProps {
  emoji: string;           // Unicode emoji
  hexcode?: string;        // Pre-resolved hexcode (for PUA emojis)
  name: string;           // Alt text
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

/**
 * Displays an OpenMoji SVG
 * Memoized to prevent unnecessary re-renders
 * UPDATED: Uses React state for fallback instead of insertAdjacentHTML
 */
export const OpenMojiDisplay = memo<OpenMojiDisplayProps>(({ 
  emoji, 
  hexcode,
  name,
  size = 'md',
  className = '' 
}) => {
  const [fallbackToUnicode, setFallbackToUnicode] = useState(false);
  
  const sizeClasses = {
    sm: 'w-6 h-6',     // 24px - for UI elements
    md: 'w-8 h-8',     // 32px - default game size
    lg: 'w-12 h-12'    // 48px - for showcases
  };
  
  // Use provided hexcode or convert from Unicode
  const finalHexcode = hexcode || unicodeToHexSequence(emoji);
  
  // If fallback is triggered, render Unicode emoji
  if (fallbackToUnicode) {
    return (
      <span className={`${sizeClasses[size]} flex items-center justify-center text-2xl ${className}`}>
        {emoji}
      </span>
    );
  }
  
  return (
    <img 
      src={`/openmoji/${finalHexcode}.svg`}
      alt={name}
      className={`${sizeClasses[size]} ${className} select-none`}
      loading="lazy"
      draggable={false}
      onError={() => {
        console.warn(`Failed to load OpenMoji SVG: ${finalHexcode}`);
        setFallbackToUnicode(true);
      }}
    />
  );
});

OpenMojiDisplay.displayName = 'OpenMojiDisplay';
 
===== END: C:\AI\LLM-Alchemy\src\components\game\OpenMojiDisplay.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyRefactored.tsx ===== 
'use client';

import React, { useState, useEffect, useRef, useMemo } from 'react';
import { Sparkles, GripHorizontal, User, ArrowLeft } from 'lucide-react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, saveGameState, loadGameState, addTokens, getLlmModelPreference } from '@/lib/supabase';
import { Achievement } from '@/types';
import { GAME_CONFIG } from '@/lib/game-config';
import { ChallengeBar } from '@/components/game/ChallengeBar';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';

// Import our new state management
import { useGameMode, useElements, useMixingArea, useCombinations, useAchievements, useGameUndo, useGameStats, useGamePersistence } from './contexts/GameStateProvider';
import { Element, MixingElement } from './hooks/useGameState';
import { useElementMixing } from './hooks/useElementMixing';
import { useGameAudio } from './hooks/useGameAudio';
import { useGameAnimations } from './hooks/useGameAnimations';
import { UnlockModal, AchievementsModal, ReasoningPopup, ElementListView, MixingAreaView } from './components';
import * as GameLogic from '@/lib/game-logic';

// UI-only interfaces (not moved to state management)
interface FloatingEmoji {
  id: number;
  emoji: string;
  x: number;
  y: number;
  directionX: number;
  directionY: number;
  speed: number;
  opacity: number;
  maxOpacity: number;
  lifespan: number;
  age: number;
}

interface ReasoningPopup {
  element: Element;
  x: number;
  y: number;
  fromHover: boolean;
}

interface ShowUnlockElement extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

// Type for window.webkitAudioContext
interface WindowWithWebkit extends Window {
  webkitAudioContext?: typeof AudioContext;
}

const LLMAlchemyRefactored = () => {
  const { user, dbUser, dailyCount, tokenBalance, refreshTokenBalance } = useSupabase();
  const router = useRouter();
  const searchParams = useSearchParams();
  
  // Get state and actions from context
  const { gameMode, setGameMode } = useGameMode();
  const { elements, endElements, setElements, setEndElements } = useElements();
  const { mixingArea, setMixingArea, addToMixingArea, updateMixingElement, clearMixingArea } = useMixingArea();
  const { combinations, failedCombinations, setCombinations, setFailedCombinations } = useCombinations();
  const { achievements } = useAchievements();
  const { lastCombination, undoAvailable, setLastCombination, setUndoAvailable } = useGameUndo();
  const { isStateRestored, setStateRestored } = useGameStats();
  const { loadSavedState, resetGameState } = useGamePersistence();
  
  // Initialize our custom hooks
  const { playSound } = useGameAudio();
  const { 
    shakeElement, 
    popElement, 
    isPlayingLoadAnimation, 
    animatedElements,
    triggerShake,
    triggerPop,
    animateRemoval,
    playElementLoadAnimation 
  } = useGameAnimations();

  // UI-only state (ephemeral - doesn't need to be in global state)
  const [sortMode, setSortMode] = useState<string>('unlock');
  const [showUnlock, setShowUnlock] = useState<ShowUnlockElement | null>(null);
  const [showAchievements, setShowAchievements] = useState<boolean>(false);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [unlockAnimationStartTime, setUnlockAnimationStartTime] = useState<number | null>(null);
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [hoveredElement, setHoveredElement] = useState<number | null>(null);
  const [isMixing] = useState<boolean>(false);
  const [touchDragging, setTouchDragging] = useState<MixingElement | null>(null);
  const [touchOffset, setTouchOffset] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [listHeight, setListHeight] = useState<number>(192);
  const [isDraggingDivider, setIsDraggingDivider] = useState<boolean>(false);
  const [touchStartTime, setTouchStartTime] = useState<number | null>(null);
  const [touchStartPos, setTouchStartPos] = useState<{ x: number; y: number } | null>(null);
  const [toast, setToast] = useState<string>('');
  const [dragStartY, setDragStartY] = useState<number>(0);
  const [dragStartHeight, setDragStartHeight] = useState<number>(0);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [floatingEmojis, setFloatingEmojis] = useState<FloatingEmoji[]>([]);
  const [reasoningPopup, setReasoningPopup] = useState<ReasoningPopup | null>(null);
  const [userApiKey, setUserApiKey] = useState<string>('');
  const [selectedModel, setSelectedModel] = useState<'flash' | 'pro'>('flash');
  const [dimmedElements, setDimmedElements] = useState<Set<string>>(new Set());
  const [isUndoing, setIsUndoing] = useState<boolean>(false);
  
  
  // Refs
  const draggedElement = useRef<MixingElement | null>(null);
  const dropZoneRef = useRef<HTMLDivElement | null>(null);
  const audioContext = useRef<AudioContext | null>(null);
  const floatingEmojiId = useRef<number>(0);
  const hoverTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Load API key from localStorage on mount
  useEffect(() => {
    const savedApiKey = localStorage.getItem('llm-alchemy-api-key');
    
    if (savedApiKey) {
      setUserApiKey(savedApiKey);
      const savedModel = localStorage.getItem('llm-alchemy-model') as 'flash' | 'pro';
      if (savedModel && (savedModel === 'flash' || savedModel === 'pro')) {
        setSelectedModel(savedModel);
      }
    }
  }, []);
  
  
  // Load model preference from Supabase for non-API-key users
  useEffect(() => {
    const loadModelPreference = async () => {
      if (user && !userApiKey) {
        const supabase = createClient();
        const modelPreference = await getLlmModelPreference(supabase, user.id);
        setSelectedModel(modelPreference);
      }
    };

    loadModelPreference();
  }, [user, userApiKey]);

  // Handle URL mode parameter and game state loading
  useEffect(() => {
    const mode = searchParams.get('mode');
    if (mode && (mode === 'science' || mode === 'creative')) {
      setGameMode(mode as 'science' | 'creative');
    }
  }, [searchParams, setGameMode]);

  // Load game state when user and game mode are available
  useEffect(() => {
    const loadSavedStateEffect = async () => {
      if (user && gameMode) {
        console.log(`[REFACTORED_GAME_STATE_DEBUG] 🔄 Loading saved state for user ${user.id} in ${gameMode} mode...`);
        setStateRestored(false);
        
        try {
          const supabase = createClient();
          const savedState = await loadGameState(supabase, user.id, gameMode);
          
          if (savedState) {
            console.log(`[REFACTORED_GAME_STATE_DEBUG] ✅ Found saved state - loading into context`);
            
            // Load into context state
            loadSavedState({
              elements: savedState.elements || [],
              endElements: savedState.end_elements || [],
              combinations: savedState.combinations || {},
              achievements: savedState.achievements || [],
              failedCombinations: savedState.failed_combinations || [],
            });
            
            // Trigger load animation if needed
            if (savedState.elements && savedState.elements.length > 5) {
              playElementLoadAnimation(savedState.elements);
            }
          } else {
            console.log(`[REFACTORED_GAME_STATE_DEBUG] 📭 No saved state found for ${gameMode} mode - starting fresh`);
          }
        } catch (error) {
          console.error('[REFACTORED_GAME_STATE_DEBUG] ❌ Error loading game state:', error);
        } finally {
          setStateRestored(true);
        }
      }
    };

    loadSavedStateEffect();
  }, [user, gameMode, loadSavedState, setStateRestored]);

  // Auto-save game state when state changes
  useEffect(() => {
    if (!isStateRestored) return;

    const saveState = async () => {
      if (user && gameMode && (elements.length > 5 || endElements.length > 0 || Object.keys(combinations).length > 0)) {
        console.log(`[REFACTORED_GAME_STATE_DEBUG] 💾 Auto-saving state...`);
        
        try {
          const supabase = createClient();
          await saveGameState(supabase, user.id, {
            game_mode: gameMode,
            elements: elements,
            end_elements: endElements,
            combinations: combinations,
            achievements: achievements,
            failed_combinations: failedCombinations
          });
          console.log(`[REFACTORED_GAME_STATE_DEBUG] ✅ Auto-save completed successfully`);
        } catch (error) {
          console.error('[REFACTORED_GAME_STATE_DEBUG] ❌ Auto-save failed:', error);
        }
      }
    };

    const timeoutId = setTimeout(saveState, 2000);
    return () => clearTimeout(timeoutId);
  }, [user, gameMode, elements, endElements, combinations, achievements, failedCombinations, isStateRestored]);

  // Initialize Web Audio API
  useEffect(() => {
    audioContext.current = new (window.AudioContext || (window as WindowWithWebkit).webkitAudioContext!)();
  }, []);

  // Mode switching logic - reset to base elements when switching modes
  useEffect(() => {
    const isCurrentlyCreative = gameMode === 'creative';
    const isCurrentlyScience = gameMode === 'science';
    
    // Only reset if we're actually switching modes (not on initial load with saved state)
    const isModeSwitching = (isCurrentlyCreative && elements.find(e => e.name === 'Energy')) ||
                           (isCurrentlyScience && elements.find(e => e.name === 'Life'));
    
    if (isModeSwitching) {
      resetGameState(gameMode);
      // Clear UI state
      setFloatingEmojis([]);
      setShowUnlock(null);
      setReasoningPopup(null);
      // Clear animations handled by useGameAnimations hook
    }
  }, [gameMode, elements, resetGameState]);

  // Global touch handlers
  useEffect(() => {
    const handleGlobalTouchMove = (e: TouchEvent) => {
      handleTouchMove(e);
      handleDividerTouchMove(e);
    };
    
    const handleGlobalTouchEnd = (e: TouchEvent) => {
      handleTouchEnd(e);
      handleDividerTouchEnd();
    };
    
    if (touchDragging || isDraggingDivider) {
      document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
      document.addEventListener('touchend', handleGlobalTouchEnd);
      
      return () => {
        document.removeEventListener('touchmove', handleGlobalTouchMove);
        document.removeEventListener('touchend', handleGlobalTouchEnd);
      };
    }
  }, [touchDragging, isDraggingDivider, mixingArea]);

  // Cleanup effects
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Divider dragging
  useEffect(() => {
    if (isDraggingDivider) {
      const handleDividerDrag = (e: MouseEvent) => {
        const deltaY = e.clientY - dragStartY;
        const newHeight = dragStartHeight + deltaY;
        setListHeight(Math.max(100, Math.min(400, newHeight)));
      };

      const handleDividerMouseUp = () => {
        setIsDraggingDivider(false);
      };

      document.addEventListener('mousemove', handleDividerDrag);
      document.addEventListener('mouseup', handleDividerMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleDividerDrag);
        document.removeEventListener('mouseup', handleDividerMouseUp);
      };
    }
  }, [isDraggingDivider, dragStartY, dragStartHeight]);

  // Floating emoji management
  useEffect(() => {
    if (elements.length < 5) return;

    const createFloatingEmoji = () => {
      const randomElement = elements[Math.floor(Math.random() * elements.length)];
      return {
        id: floatingEmojiId.current++,
        emoji: randomElement.emoji,
        x: Math.random() * 100,
        y: Math.random() * 100,
        directionX: (Math.random() - 0.5) * 2,
        directionY: (Math.random() - 0.5) * 2,
        speed: 0.3 + Math.random() * 0.4,
        opacity: 0,
        maxOpacity: 0.005 + Math.random() * 0.005,
        lifespan: 8000 + Math.random() * 6000,
        age: 0
      };
    };

    if (floatingEmojis.length === 0) {
      const initialCount = 1 + Math.floor(Math.random() * 3);
      setFloatingEmojis(Array.from({ length: initialCount }, createFloatingEmoji));
    }

    const animationLoop = setInterval(() => {
      setFloatingEmojis(prevEmojis => {
        let newEmojis = prevEmojis.map(emoji => {
          const newAge = emoji.age + 100;
          const lifeProgress = newAge / emoji.lifespan;
          
          let newOpacity;
          if (lifeProgress < 0.2) {
            newOpacity = (lifeProgress / 0.2) * emoji.maxOpacity;
          } else if (lifeProgress < 0.8) {
            newOpacity = emoji.maxOpacity;
          } else {
            newOpacity = emoji.maxOpacity * ((1 - lifeProgress) / 0.2);
          }

          return {
            ...emoji,
            x: emoji.x + emoji.directionX * emoji.speed,
            y: emoji.y + emoji.directionY * emoji.speed,
            opacity: Math.max(0, newOpacity),
            age: newAge
          };
        });

        newEmojis = newEmojis.filter(emoji => emoji.age < emoji.lifespan);
        
        while (newEmojis.length < 1 || (newEmojis.length < 3 && Math.random() < 0.3)) {
          newEmojis.push(createFloatingEmoji());
        }

        return newEmojis;
      });
    }, 100);

    return () => clearInterval(animationLoop);
  }, [elements.length]);

  // Handle reasoning popup dismissal
  useEffect(() => {
    const handleGlobalClick = (e: MouseEvent) => {
      if (reasoningPopup && !reasoningPopup.fromHover) {
        const popup = document.querySelector('.reasoning-popup');
        if (!popup || !popup.contains(e.target as Node)) {
          hideReasoningPopup();
        }
      }
    };

    const handleEscapeKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && reasoningPopup) {
        hideReasoningPopup();
      }
    };

    if (reasoningPopup) {
      document.addEventListener('click', handleGlobalClick);
      document.addEventListener('keydown', handleEscapeKey);
      return () => {
        document.removeEventListener('click', handleGlobalClick);
        document.removeEventListener('keydown', handleEscapeKey);
      };
    }
  }, [reasoningPopup]);

  // Helper functions using game logic

  const showToast = (message: string) => {
    setToast(message);
    setTimeout(() => setToast(''), 3000);
  };

  // Initialize our custom hooks
  const { mixElements } = useElementMixing({
    userApiKey,
    selectedModel,
    onShowToast: showToast,
    onPlaySound: (type: string) => {
      // Map string types to our SoundType enum
      const soundMap: Record<string, Parameters<typeof playSound>[0]> = {
        'plop': 'plop',
        'pop': 'pop', 
        'reward': 'reward',
        'end-element': 'end-element',
        'press': 'press',
        'click': 'click',
        'reverse-pop': 'reverse-pop'
      };
      const soundType = soundMap[type] || 'pop';
      playSound(soundType);
    },
    onShowUnlock: (element: ShowUnlockElement | null) => setShowUnlock(element),
    onSetShakeElement: (elementId: string | null) => {
      if (elementId) triggerShake(elementId);
    },
    onSetPopElement: (elementId: string | null) => {
      if (elementId) triggerPop(elementId);
    },
    onSetUnlockAnimationStartTime: setUnlockAnimationStartTime,
    dropZoneRef
  });

  const showReasoningPopup = (element: Element, event: React.MouseEvent | React.TouchEvent) => {
    if (!element.reasoning) return;
    
    const rect = event.currentTarget.getBoundingClientRect();
    setReasoningPopup({
      element,
      x: rect.left + rect.width / 2,
      y: rect.top - 10,
      fromHover: event.type === 'mouseenter'
    });
  };

  const hideReasoningPopup = () => {
    setReasoningPopup(null);
  };


  const handleElementClick = (element: Element, event: React.MouseEvent) => {
    if (element.reasoning) {
      event.preventDefault();
      event.stopPropagation();
      showReasoningPopup(element, event);
    }
  };

  const handleElementMouseEnter = (element: Element, event: React.MouseEvent) => {
    if (!GameLogic.isTouchDevice() && element.reasoning) {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
      const rect = event.currentTarget.getBoundingClientRect();
      hoverTimeoutRef.current = setTimeout(() => {
        const syntheticEvent = {
          currentTarget: {
            getBoundingClientRect: () => rect
          },
          type: 'mouseenter'
        };
        showReasoningPopup(element, syntheticEvent as React.MouseEvent);
      }, 500);
    }
  };

  const handleElementMouseLeave = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }
    if (reasoningPopup && reasoningPopup.fromHover) {
      hideReasoningPopup();
    }
  };

  const handleBackToHome = () => {
    router.push('/');
  };

  const handleGameModeToggle = () => {
    if (!isMixing) {
      const newMode = gameMode === 'science' ? 'creative' : 'science';
      playSound('click');
      
      setMixingArea([]);
      
      const url = new URL(window.location.href);
      url.searchParams.set('mode', newMode);
      window.history.replaceState({}, '', url);
      
      setGameMode(newMode);
    }
  };

  // Optimized element sorting with search filtering
  const sortedElements = useMemo(() => {
    return GameLogic.sortElements(elements, sortMode as 'unlock' | 'alpha', searchTerm);
  }, [elements, sortMode, searchTerm]);

  const regularElementCount = elements.length;
  const endElementCount = endElements.length;

  // Touch handlers for dividers
  const handleDividerTouchStart = (e: React.TouchEvent) => {
    e.preventDefault();
    setIsDraggingDivider(true);
  };

  const handleDividerTouchMove = (e: TouchEvent) => {
    if (!isDraggingDivider) return;
    
    const touch = e.touches[0];
    const newHeight = touch.clientY - 100;
    setListHeight(Math.max(100, Math.min(400, newHeight)));
  };

  const handleDividerTouchEnd = () => {
    setIsDraggingDivider(false);
  };

  // Touch event handlers
  const handleTouchMove = (e: TouchEvent) => {
    if (!touchDragging) return;
    
    const touch = e.touches[0];
    const draggedEl = document.getElementById('touch-drag-element');
    if (draggedEl) {
      draggedEl.style.left = `${touch.clientX - touchOffset.x}px`;
      draggedEl.style.top = `${touch.clientY - touchOffset.y}px`;
    }
    
    // Check if hovering over a mixing area element
    const hoverTarget = document.elementFromPoint(touch.clientX, touch.clientY);
    if (hoverTarget) {
      const mixingEl = mixingArea.find(el => {
        const elNode = document.getElementById(`mixing-${el.id}-${el.index}`);
        return elNode && (elNode === hoverTarget || elNode.contains(hoverTarget));
      });
      
      if (mixingEl && mixingEl.index !== touchDragging.mixIndex) {
        setHoveredElement(mixingEl.index);
      } else {
        setHoveredElement(null);
      }
    }
    
    e.preventDefault();
  };

  const handleTouchEnd = async (e: TouchEvent | React.TouchEvent<HTMLDivElement>) => {
    if (!touchDragging) return;
    
    const touch = e.changedTouches[0];
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - (touchStartTime || 0);
    
    // Calculate movement distance
    const moveDistance = touchStartPos ? Math.sqrt(
      Math.pow(touch.clientX - touchStartPos!.x, 2) + 
      Math.pow(touch.clientY - touchStartPos!.y, 2)
    ) : 0;
    
    // If it was a quick tap with minimal movement, show reasoning popup
    if (touchDuration < 300 && moveDistance < 10 && touchDragging.reasoning) {
      const syntheticEvent = {
        currentTarget: {
          getBoundingClientRect: () => ({
            left: touchStartPos!.x - 32,
            top: touchStartPos!.y - 32,
            width: 64,
            height: 64
          })
        }
      };
      
      setTouchDragging(null);
      setTouchOffset({ x: 0, y: 0 });
      setTouchStartTime(null);
      setTouchStartPos(null);
      
      setTimeout(() => {
        showReasoningPopup(touchDragging, syntheticEvent as React.TouchEvent);
      }, 50);
      
      return;
    }
    
    // Handle as normal drag operation
    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (dropZoneRef.current && dropZoneRef.current.contains(dropTarget)) {
      const rect = dropZoneRef.current.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      // Check if dropped on another element
      const targetElement = mixingArea.find(el => {
        const elRect = document.getElementById(`mixing-${el.id}-${el.index}`)?.getBoundingClientRect();
        if (!elRect) return false;
        return touch.clientX >= elRect.left && touch.clientX <= elRect.right &&
               touch.clientY >= elRect.top && touch.clientY <= elRect.bottom;
      });
      
      if (targetElement && targetElement.index !== touchDragging.mixIndex) {
        // Mix the elements using our hook
        await mixElements(touchDragging, targetElement);
      } else if (!targetElement) {
        playSound('plop');
        if ('vibrate' in navigator) {
          navigator.vibrate(5);
        }
        const offset = GameLogic.getElementSize() / 2;
        if (touchDragging.fromMixingArea) {
          const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current, touchDragging.mixIndex);
          updateMixingElement(touchDragging.mixIndex!, { x: newPos.x, y: newPos.y });
        } else {
          const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current);
          const newElement = {
            ...touchDragging,
            x: newPos.x,
            y: newPos.y,
            index: Date.now(),
            energized: false
          };
          addToMixingArea(newElement);
        }
      }
    }
    
    setTouchDragging(null);
    setTouchOffset({ x: 0, y: 0 });
    setHoveredElement(null);
    setTouchStartTime(null);
    setTouchStartPos(null);
    setDimmedElements(new Set());
  };

  // Clear mixing area with animation
  const clearMixingAreaWithAnimation = () => {
    if (!isMixing && mixingArea.length > 0) {
      playSound('click');
      animateRemoval(mixingArea, () => clearMixingArea());
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col relative overflow-hidden select-none" style={{ touchAction: touchDragging || isDraggingDivider ? 'none' : 'auto' }}>
      <div className="absolute inset-0 bg-gradient-to-br from-purple-900/20 via-gray-900 to-blue-900/20"></div>
      
      {/* Floating Background Emojis */}
      {floatingEmojis.map(emoji => (
        <div
          key={emoji.id}
          className="absolute text-4xl pointer-events-none transition-opacity duration-200"
          style={{
            left: `${emoji.x}%`,
            top: `${emoji.y}%`,
            opacity: emoji.opacity,
            transform: 'translate(-50%, -50%)'
          }}
        >
          {emoji.emoji}
        </div>
      ))}
      
      {/* Header */}
      <div className="relative z-10 bg-gray-800/80 backdrop-blur-sm p-4 shadow-lg">
        <div className="flex justify-between items-start mb-3">
          <div className="flex items-center gap-3">
            <h1 className="text-2xl font-bold flex items-center gap-2">
              <Sparkles className="text-yellow-400 hidden sm:block" />
              LLM Alchemy
            </h1>
          </div>
          <div className="text-lg font-semibold flex flex-col items-end gap-1">
            <span>Elements: {regularElementCount}</span>
            {gameMode === 'science' && endElementCount > 0 && (
              <span className="text-gray-300 text-base">Ends: {endElementCount}</span>
            )}
          </div>
        </div>
        
        <div className="flex justify-between items-center mb-3">
          <button
            onClick={handleBackToHome}
            className="flex items-center gap-2 px-3 py-1 hover:bg-gray-700 rounded transition-colors text-gray-400 hover:text-white"
            title="Back to Menu"
          >
            <ArrowLeft size={16} />
            <span className="text-sm">Back</span>
          </button>
          
          <div className="text-sm text-gray-400 flex items-center gap-2">
            {/* Undo Button */}
            {undoAvailable && !isUndoing && (
              <button
                onClick={async () => {
                  if (lastCombination) {
                    setIsUndoing(true);
                    playSound('reverse-pop');
                    
                    // Remove the created element
                    if (lastCombination.createdElement.isEndElement) {
                      const newEndElements = endElements.filter(e => e.id !== lastCombination.createdElement.element.id);
                      setEndElements(newEndElements);
                    } else {
                      const newElements = elements.filter(e => e.id !== lastCombination.createdElement.element.id);
                      setElements(newElements);
                    }
                    
                    // Restore the mixing area
                    setMixingArea(lastCombination.mixingAreaState);
                    
                    // Remove from combinations
                    const newCombinations = { ...combinations };
                    delete newCombinations[lastCombination.combinationKey];
                    setCombinations(newCombinations);
                    
                    // Remove from failed combinations if it was there
                    const newFailedCombinations = failedCombinations.filter(key => key !== lastCombination.combinationKey);
                    setFailedCombinations(newFailedCombinations);
                    
                    // Clear undo state
                    setLastCombination(null);
                    setUndoAvailable(false);
                    
                    showToast('Undid last combination');
                    
                    setTimeout(() => {
                      setIsUndoing(false);
                    }, 300);
                  }
                }}
                className="px-2 py-1 bg-orange-600 hover:bg-orange-500 rounded text-white font-medium transition-colors text-xs"
                title="Undo last combination"
              >
                ↶ Undo
              </button>
            )}
            
            {userApiKey ? (
              <span className="text-green-400">Using your API key</span>
            ) : tokenBalance > 0 ? (
              <span className="text-yellow-400">Tokens: {tokenBalance}</span>
            ) : dailyCount >= GAME_CONFIG.DAILY_FREE_COMBINATIONS ? (
              <button
                onClick={async () => {
                  if (user) {
                    const supabase = createClient();
                    await addTokens(supabase, user.id, 10);
                    await refreshTokenBalance();
                    showToast('+10 tokens added!');
                  }
                }}
                className="px-3 py-1 bg-purple-600 hover:bg-purple-500 rounded text-white font-medium transition-colors"
              >
                Get more
              </button>
            ) : (
              <>
                <User size={14} />
                <span>{dailyCount}/{GAME_CONFIG.DAILY_FREE_COMBINATIONS} today</span>
              </>
            )}
          </div>
        </div>
        
        <div className="flex justify-between items-center gap-3">
          <div className="flex gap-2 text-sm items-center">
            <input
              type="text"
              placeholder="Filter..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-20 sm:w-20 px-2 py-1 text-sm bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400 focus:outline-none focus:border-purple-500"
            />
            <button
              onClick={() => setShowAchievements(true)}
              className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition-all flex items-center gap-1"
            >
              <span>🏆</span>
              <span className="hidden sm:inline text-sm">Achievements</span>
            </button>
            <select
              value={sortMode}
              onChange={(e) => setSortMode(e.target.value)}
              className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm focus:outline-none focus:border-purple-500"
            >
              <option value="unlock">By Discovery</option>
              <option value="alpha">Alphabetical</option>
            </select>
          </div>
          
          {/* Game Mode Toggle */}
          <button
            onClick={handleGameModeToggle}
            disabled={isMixing}
            className={`relative inline-flex h-8 w-32 cursor-pointer items-center rounded-full bg-gray-700 transition-colors hover:bg-gray-600 ${
              isMixing ? 'opacity-50 cursor-not-allowed' : ''
            }`}
          >
            <div className={`absolute left-1 h-6 w-14 rounded-full transition-transform ${
              gameMode === 'creative' ? 'bg-purple-600 translate-x-16' : 'bg-blue-500'
            }`}></div>
            <span className={`absolute left-3 text-xs font-medium z-10 ${
              gameMode === 'science' ? 'text-white' : 'text-gray-400'
            }`}>Science</span>
            <span className={`absolute right-3 text-xs font-medium z-10 ${
              gameMode === 'creative' ? 'text-white' : 'text-gray-400'
            }`}>Creative</span>
          </button>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col relative z-10 min-h-0">
        {/* Element List */}
        <div 
          className="bg-gray-800/30 backdrop-blur-sm"
          style={{ height: `${listHeight}px` }}
        >
          <ElementListView
            elements={sortedElements}
            searchTerm={searchTerm}
            sortMode={sortMode}
            shakeElement={shakeElement}
            popElement={popElement}
            hoveredElement={hoveredElement?.toString() || null}
            isDragging={isDragging}
            dimmedElements={dimmedElements}
            isPlayingLoadAnimation={isPlayingLoadAnimation}
            animatedElements={animatedElements}
            onElementDragStart={(e, element) => {
              draggedElement.current = {
                ...element,
                x: 0,
                y: 0,
                index: 0,
                energized: false
              };
              setIsDragging(true);
              e.dataTransfer.effectAllowed = 'copy';
              e.dataTransfer.setData('text/plain', element.name);
            }}
            onElementTouchStart={(e, element) => {
              const touch = e.touches[0];
              const rect = e.currentTarget.getBoundingClientRect();
              setTouchStartTime(Date.now());
              setTouchStartPos({ x: touch.clientX, y: touch.clientY });
              setTouchOffset({
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              });
              
              setTimeout(() => {
                if (touchStartTime && Date.now() - touchStartTime > 150) {
                  setTouchDragging({
                    ...element,
                    x: 0,
                    y: 0,
                    index: 0,
                    energized: false,
                    fromMixingArea: false,
                    mixIndex: undefined
                  });
                  
                  const otherElements = new Set(sortedElements.filter(el => el.id !== element.id).map(el => el.id));
                  setDimmedElements(otherElements);
                  
                  if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                  }
                }
              }, 150);
            }}
            onElementClick={handleElementClick}
            onElementMouseEnter={handleElementMouseEnter}
            onElementMouseLeave={handleElementMouseLeave}
          />
        </div>

        {/* Divider */}
        <div 
          className="h-1 bg-gray-600 cursor-row-resize hover:bg-gray-500 transition-colors flex items-center justify-center relative"
          onMouseDown={(e) => {
            setIsDraggingDivider(true);
            setDragStartY(e.clientY);
            setDragStartHeight(listHeight);
          }}
          onTouchStart={handleDividerTouchStart}
        >
          <GripHorizontal size={16} className="text-gray-400" />
        </div>

        {/* Mixing Area */}
        <div 
          ref={dropZoneRef}
          className={`flex-1 bg-gray-800/30 backdrop-blur-sm relative overflow-hidden transition-colors ${
            isDragging || touchDragging ? 'bg-blue-900/20 border-2 border-dashed border-blue-400' : ''
          }`}
          style={{ minHeight: '200px', touchAction: 'none' }}
          onDragOver={(e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
          }}
          onDrop={(e) => {
            e.preventDefault();
            if (!draggedElement.current) return;
            
            const rect = dropZoneRef.current!.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            playSound('plop');
            const offset = GameLogic.getElementSize() / 2;
            const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current!);
            
            const newElement: MixingElement = {
              ...draggedElement.current,
              x: newPos.x,
              y: newPos.y,
              index: Date.now(),
              energized: false
            };
            
            addToMixingArea(newElement);
            setIsDragging(false);
            draggedElement.current = null;
          }}
          onTouchEnd={handleTouchEnd}
        >
          <MixingAreaView
            mixingArea={mixingArea}
            isMixing={isMixing}
            mixingResult={null}
            canUndo={undoAvailable}
            onDrop={(e) => {
              e.preventDefault();
              if (!draggedElement.current) return;
              
              const rect = dropZoneRef.current!.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              
              playSound('plop');
              const offset = GameLogic.getElementSize() / 2;
              const newPos = GameLogic.resolveCollisions(x - offset, y - offset, mixingArea, dropZoneRef.current!);
              
              const newElement: MixingElement = {
                ...draggedElement.current,
                x: newPos.x,
                y: newPos.y,
                index: Date.now(),
                energized: false
              };
              
              addToMixingArea(newElement);
              setIsDragging(false);
              draggedElement.current = null;
            }}
            onDragOver={(e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'copy';
            }}
            onTouchEnd={handleTouchEnd}
            onMixingElementMouseDown={(e, element) => {
              // Find the full element from mixingArea to ensure all properties are included
              const fullElement = mixingArea.find(m => m.index === element.index);
              if (!fullElement) {
                console.error('Element not found in mixingArea:', element);
                return;
              }
              
              draggedElement.current = {
                ...fullElement,
                fromMixingArea: true,
                mixIndex: fullElement.index
              };
              setIsDragging(true);
              playSound('press');
            }}
            onMixingElementTouchStart={(e, element) => {
              // Find the full element from mixingArea to ensure all properties are included
              const fullElement = mixingArea.find(m => m.index === element.index);
              if (!fullElement) {
                console.error('Element not found in mixingArea:', element);
                return;
              }
              
              const touch = e.touches[0];
              const rect = e.currentTarget.getBoundingClientRect();
              setTouchStartTime(Date.now());
              setTouchStartPos({ x: touch.clientX, y: touch.clientY });
              setTouchOffset({
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              });
              
              setTimeout(() => {
                if (touchStartTime && Date.now() - touchStartTime > 100) {
                  setTouchDragging({
                    ...fullElement,
                    fromMixingArea: true,
                    mixIndex: fullElement.index
                  });
                  
                  const otherIndices = new Set(mixingArea.filter(el => el.index !== fullElement.index).map(el => el.index.toString()));
                  setDimmedElements(otherIndices);
                  
                  if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                  }
                }
              }, 100);
            }}
            onClearMixingArea={clearMixingAreaWithAnimation}
            onUndo={async () => {
              if (lastCombination) {
                setIsUndoing(true);
                playSound('reverse-pop');
                
                // Remove the created element
                if (lastCombination.createdElement.isEndElement) {
                  const newEndElements = endElements.filter(e => e.id !== lastCombination.createdElement.element.id);
                  setEndElements(newEndElements);
                } else {
                  const newElements = elements.filter(e => e.id !== lastCombination.createdElement.element.id);
                  setElements(newElements);
                }
                
                // Restore the mixing area
                setMixingArea(lastCombination.mixingAreaState);
                
                // Remove from combinations
                const newCombinations = { ...combinations };
                delete newCombinations[lastCombination.combinationKey];
                setCombinations(newCombinations);
                
                // Remove from failed combinations if it was there
                const newFailedCombinations = failedCombinations.filter(key => key !== lastCombination.combinationKey);
                setFailedCombinations(newFailedCombinations);
                
                // Clear undo state
                setLastCombination(null);
                setUndoAvailable(false);
                
                showToast('Undid last combination');
                
                setTimeout(() => {
                  setIsUndoing(false);
                }, 300);
              }
            }}
          />
        </div>

        {/* Touch Drag Element */}
        {touchDragging && (
          <div
            id="touch-drag-element"
            className="fixed pointer-events-none z-50 flex flex-col items-center justify-center text-center rounded-lg"
            style={{
              width: `${GameLogic.getElementSize()}px`,
              height: `${GameLogic.getElementSize()}px`,
              backgroundColor: touchDragging.color,
              color: GameLogic.getContrastColor(touchDragging.color),
              transform: 'scale(1.1)'
            }}
          >
            <OpenMojiDisplay 
              emoji={touchDragging.emoji} 
              hexcode={touchDragging.openmojiHex}
              name={touchDragging.name} 
              size="sm" 
            />
            <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight">
              {touchDragging.name}
            </div>
          </div>
        )}
      </div>

      {/* Challenge Bar */}
      <ChallengeBar isAnonymous={dbUser?.is_anonymous} currentGameMode={gameMode} />

      {/* Reasoning Popup */}
      <ReasoningPopup 
        reasoningPopup={reasoningPopup}
        onClose={hideReasoningPopup}
      />

      {/* Unlock Modal */}
      <UnlockModal 
        showUnlock={showUnlock}
        onClose={() => setShowUnlock(null)}
      />

      {/* Achievements Modal */}
      <AchievementsModal 
        isOpen={showAchievements}
        achievements={achievements}
        onClose={() => setShowAchievements(false)}
      />

      {/* Toast */}
      {toast && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 px-4 py-2 rounded-lg z-50">
          {toast}
        </div>
      )}
    </div>
  );
};

export default LLMAlchemyRefactored;
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyRefactored.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyWrapper.tsx ===== 
'use client';

import React from 'react';
import { GameStateProvider } from './contexts/GameStateProvider';
import LLMAlchemyRefactored from './LLMAlchemyRefactored';

interface LLMAlchemyWrapperProps {
  initialGameMode?: 'science' | 'creative';
}

const LLMAlchemyWrapper: React.FC<LLMAlchemyWrapperProps> = ({ 
  initialGameMode = 'science' 
}) => {
  console.log('[LLM_ALCHEMY_WRAPPER] 🔬 Using refactored version with new state management');
  
  return (
    <GameStateProvider initialGameMode={initialGameMode}>
      <LLMAlchemyRefactored />
    </GameStateProvider>
  );
};

export default LLMAlchemyWrapper;
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\LLMAlchemyWrapper.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\AchievementsModal.tsx ===== 
import React from 'react';
import { X } from 'lucide-react';
import { Achievement } from '@/types';

interface AchievementsModalProps {
  isOpen: boolean;
  achievements: Achievement[];
  onClose: () => void;
}

export const AchievementsModal: React.FC<AchievementsModalProps> = ({ 
  isOpen, 
  achievements, 
  onClose 
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-md mx-4 border border-gray-600 max-h-[80vh] flex flex-col">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-xl font-bold flex items-center gap-2">
            <span>🏆</span>
            Achievements
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white"
          >
            <X size={20} />
          </button>
        </div>
        <div className="overflow-y-auto flex-1">
          {achievements.length === 0 ? (
            <div className="text-center text-gray-400 py-8">
              <div className="text-4xl mb-2">🎯</div>
              <p>No achievements yet!</p>
              <p className="text-sm mt-1">Keep discovering elements to unlock achievements.</p>
            </div>
          ) : (
            <div className="space-y-3">
              {achievements.map((achievement) => (
                <div
                  key={achievement.id}
                  className="bg-gray-700/50 rounded-lg p-3 border border-gray-600"
                >
                  <div className="flex items-start gap-3">
                    <span className="text-2xl">{achievement.emoji}</span>
                    <div className="flex-1">
                      <h4 className="font-semibold text-yellow-400">{achievement.name}</h4>
                      <p className="text-sm text-gray-300 mt-1">{achievement.description}</p>
                      {achievement.unlocked && (
                        <p className="text-xs text-gray-500 mt-2">
                          Unlocked: {new Date(achievement.unlocked).toLocaleDateString()}
                        </p>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\AchievementsModal.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\ElementListView.tsx ===== 
'use client';

import React from 'react';
import { GameElement } from '@/types/game.types';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { getContrastColor, getRarityHoverColor, getElementSizeClasses, isTouchDevice } from '@/lib/ui-utils';

interface ElementListViewProps {
  elements: GameElement[];
  searchTerm: string;
  sortMode: string;
  shakeElement: string | null;
  popElement: string | null;
  hoveredElement: string | null;
  isDragging: boolean;
  dimmedElements: Set<string>;
  isPlayingLoadAnimation: boolean;
  animatedElements: Set<string>;
  onElementDragStart: (e: React.DragEvent<HTMLDivElement>, element: GameElement) => void;
  onElementTouchStart: (e: React.TouchEvent<HTMLDivElement>, element: GameElement) => void;
  onElementClick: (element: GameElement, event: React.MouseEvent) => void;
  onElementMouseEnter: (element: GameElement, event: React.MouseEvent) => void;
  onElementMouseLeave: () => void;
}

export const ElementListView: React.FC<ElementListViewProps> = ({
  elements,
  searchTerm,
  sortMode,
  shakeElement,
  popElement,
  hoveredElement,
  isDragging,
  dimmedElements,
  isPlayingLoadAnimation,
  animatedElements,
  onElementDragStart,
  onElementTouchStart,
  onElementClick,
  onElementMouseEnter,
  onElementMouseLeave
}) => {
  const isTouch = isTouchDevice();

  // Sort elements based on sortMode
  const sortedElements = React.useMemo(() => {
    const filtered = elements.filter(element =>
      element.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (sortMode === 'alpha') {
      return filtered.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      // Sort by discovery order (unlockOrder ascending)
      return filtered.sort((a, b) => (a.unlockOrder || 0) - (b.unlockOrder || 0));
    }
  }, [elements, searchTerm, sortMode]);

  return (
    <div className="flex-1 overflow-y-auto p-4 scrollbar-mobile">
      {/* Use flex-wrap layout for natural responsiveness */}
      <div className="flex flex-wrap gap-2">
        {sortedElements.map((element) => (
          <div
            key={element.id}
            draggable={!isTouch}
            onDragStart={(e) => onElementDragStart(e, element)}
            onTouchStart={(e) => onElementTouchStart(e, element)}
            onMouseEnter={(e) => onElementMouseEnter(element, e)}
            onMouseLeave={onElementMouseLeave}
            onClick={(e) => onElementClick(element, e)}
            onContextMenu={(e) => e.preventDefault()}
            className={`
              ${getElementSizeClasses()} flex flex-col items-center justify-center rounded-lg cursor-move 
              hover:scale-110 transition-transform select-none
              ${popElement === element.id ? 'animate-element-pop-in' : ''}
              ${shakeElement === element.id ? 'animate-element-shake' : ''}
              ${isPlayingLoadAnimation && animatedElements.has(element.id) ? 'animate-element-load-delayed' : ''}
              ${dimmedElements.has(element.name) ? 'element-dimmed' : ''}
            `}
            style={{ 
              backgroundColor: element.color,
              color: getContrastColor(element.color),
              boxShadow: !isDragging && hoveredElement === element.id ? `0 0 0 2px ${getRarityHoverColor(element.rarity)}` : '',
              touchAction: 'none',
              WebkitTouchCallout: 'none',
              WebkitUserSelect: 'none',
              animationDelay: isPlayingLoadAnimation && animatedElements.has(element.id) 
                ? `${(element.unlockOrder || 0) * 25}ms` 
                : undefined
            }}
          >
            {/* Question mark badge for elements with reasoning */}
            {element.reasoning && (
              <div className="absolute -top-1 -right-1 w-4 h-4 bg-yellow-400 rounded-full flex items-center justify-center text-xs font-bold text-black">
                ?
              </div>
            )}
            
            <OpenMojiDisplay 
              emoji={element.emoji} 
              hexcode={element.openmojiHex}
              name={element.name} 
              size="md" 
            />
            <div className="text-[8px] sm:text-[10px] font-medium px-1 text-center leading-tight">
              {element.name}
            </div>
          </div>
        ))}
      </div>

      {sortedElements.length === 0 && searchTerm && (
        <div className="text-center text-gray-400 py-8">
          <p>No elements found matching &quot;{searchTerm}&quot;</p>
          <p className="text-sm mt-2">Try a different search term</p>
        </div>
      )}

      {elements.length === 0 && (
        <div className="text-center text-gray-400 py-8">
          <p>No elements discovered yet!</p>
          <p className="text-sm mt-2">Start mixing to discover new elements</p>
        </div>
      )}
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\ElementListView.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\GameHeader.tsx ===== 
'use client';

import React from 'react';
import { Sparkles, ArrowLeft, User } from 'lucide-react';
import { GAME_CONFIG } from '@/lib/game-config';

interface GameHeaderProps {
  regularElementCount: number;
  endElementCount: number;
  gameMode: 'science' | 'creative';
  undoAvailable: boolean;
  isUndoing: boolean;
  userApiKey: string;
  tokenBalance: number;
  dailyCount: number;
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  sortMode: string;
  setSortMode: (mode: string) => void;
  isMixing: boolean;
  onBackToHome: () => void;
  onGameModeToggle: () => void;
  onShowAchievements: () => void;
  onUndo: () => Promise<void>;
  onGetMoreTokens: () => Promise<void>;
}

export const GameHeader: React.FC<GameHeaderProps> = ({
  regularElementCount,
  endElementCount,
  gameMode,
  undoAvailable,
  isUndoing,
  userApiKey,
  tokenBalance,
  dailyCount,
  searchTerm,
  setSearchTerm,
  sortMode,
  setSortMode,
  isMixing,
  onBackToHome,
  onGameModeToggle,
  onShowAchievements,
  onUndo,
  onGetMoreTokens
}) => {
  return (
    <div className="relative z-10 bg-gray-800/80 backdrop-blur-sm p-4 shadow-lg">
      <div className="flex justify-between items-start mb-3">
        <div className="flex items-center gap-3">
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Sparkles className="text-yellow-400 hidden sm:block" />
            LLM Alchemy
          </h1>
        </div>
        <div className="text-lg font-semibold flex flex-col items-end gap-1">
          <span>Elements: {regularElementCount}</span>
          {gameMode === 'science' && endElementCount > 0 && (
            <span className="text-gray-300 text-base">Ends: {endElementCount}</span>
          )}
        </div>
      </div>
      
      <div className="flex justify-between items-center mb-3">
        <button
          onClick={onBackToHome}
          className="flex items-center gap-2 px-3 py-1 hover:bg-gray-700 rounded transition-colors text-gray-400 hover:text-white"
          title="Back to Menu"
        >
          <ArrowLeft size={16} />
          <span className="text-sm">Back</span>
        </button>
        
        <div className="text-sm text-gray-400 flex items-center gap-2">
          {/* Undo Button */}
          {undoAvailable && !isUndoing && (
            <button
              onClick={onUndo}
              className="px-2 py-1 bg-orange-600 hover:bg-orange-500 rounded text-white font-medium transition-colors text-xs"
              title="Undo last combination"
            >
              ↶ Undo
            </button>
          )}
          
          {userApiKey ? (
            <span className="text-green-400">Using your API key</span>
          ) : tokenBalance > 0 ? (
            <span className="text-yellow-400">Tokens: {tokenBalance}</span>
          ) : dailyCount >= GAME_CONFIG.DAILY_FREE_COMBINATIONS ? (
            <button
              onClick={onGetMoreTokens}
              className="px-3 py-1 bg-purple-600 hover:bg-purple-500 rounded text-white font-medium transition-colors"
            >
              Get more
            </button>
          ) : (
            <>
              <User size={14} />
              <span>{dailyCount}/{GAME_CONFIG.DAILY_FREE_COMBINATIONS} today</span>
            </>
          )}
        </div>
      </div>
      
      <div className="flex justify-between items-center gap-3">
        <div className="flex gap-2 text-sm items-center">
          <input
            type="text"
            placeholder="Filter..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-20 sm:w-20 px-2 py-1 text-sm bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400 focus:outline-none focus:border-purple-500"
          />
          <button
            onClick={onShowAchievements}
            className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition-all flex items-center gap-1"
          >
            <span>🏆</span>
            <span className="hidden sm:inline text-sm">Achievements</span>
          </button>
          <select
            value={sortMode}
            onChange={(e) => setSortMode(e.target.value)}
            className="px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm focus:outline-none focus:border-purple-500"
          >
            <option value="unlock">By Discovery</option>
            <option value="alpha">Alphabetical</option>
          </select>
        </div>
        
        {/* Game Mode Toggle */}
        <button
          onClick={onGameModeToggle}
          disabled={isMixing}
          className={`relative inline-flex h-8 w-32 cursor-pointer items-center rounded-full bg-gray-700 transition-colors hover:bg-gray-600 ${
            isMixing ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          <div className={`absolute left-1 h-6 w-14 rounded-full transition-transform ${
            gameMode === 'creative' ? 'bg-purple-600 translate-x-16' : 'bg-blue-500'
          }`}></div>
          <span className={`absolute left-3 text-xs font-medium z-10 ${
            gameMode === 'science' ? 'text-white' : 'text-gray-400'
          }`}>Science</span>
          <span className={`absolute right-3 text-xs font-medium z-10 ${
            gameMode === 'creative' ? 'text-white' : 'text-gray-400'
          }`}>Creative</span>
        </button>
      </div>
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\GameHeader.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\index.ts ===== 
export { UnlockModal } from './UnlockModal';
export { AchievementsModal } from './AchievementsModal';
export { ReasoningPopup } from './ReasoningPopup';
export { GameHeader } from './GameHeader';
export { ElementListView } from './ElementListView';
export { MixingAreaView } from './MixingAreaView';
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\index.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\MixingAreaView.tsx ===== 
'use client';

import React from 'react';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { MixingElement } from '../hooks/useGameState';

interface MixingAreaViewProps {
  mixingArea: MixingElement[];
  isMixing: boolean;
  mixingResult: string | null;
  canUndo: boolean;
  onDrop: (e: React.DragEvent<HTMLDivElement>) => void;
  onDragOver: (e: React.DragEvent<HTMLDivElement>) => void;
  onTouchEnd: (e: React.TouchEvent<HTMLDivElement>) => void;
  onMixingElementMouseDown: (e: React.MouseEvent<HTMLDivElement>, element: MixingElement) => void;
  onMixingElementTouchStart: (e: React.TouchEvent<HTMLDivElement>, element: MixingElement) => void;
  onClearMixingArea: () => void;
  onUndo: () => void;
}

export const MixingAreaView: React.FC<MixingAreaViewProps> = ({
  mixingArea,
  isMixing,
  mixingResult,
  canUndo,
  onDrop,
  onDragOver,
  onTouchEnd,
  onMixingElementMouseDown,
  onMixingElementTouchStart,
  onClearMixingArea,
  onUndo
}) => {
  return (
    <div className="flex-1 relative overflow-hidden">
      {/* Mixing Area */}
      <div
        className={`
          absolute inset-4 border-2 border-dashed rounded-lg transition-all duration-500
          ${mixingArea.length > 0 
            ? 'border-purple-400 bg-purple-900/20' 
            : 'border-gray-600 bg-gray-800/50'
          }
          ${isMixing ? 'border-yellow-400 bg-yellow-900/20 animate-mixing-blur' : ''}
        `}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onTouchEnd={onTouchEnd}
      >
        {/* UNDO Button - Top Left */}
        <button
          onClick={onUndo}
          disabled={!canUndo}
          className="absolute top-4 left-4 px-3 py-1 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed rounded text-white text-sm font-medium transition-colors z-10"
          title="Undo last action"
        >
          ↶ Undo
        </button>

        {/* CLEAR Button - Top Right */}
        {mixingArea.length > 0 && !isMixing && (
          <button
            onClick={onClearMixingArea}
            className="absolute top-4 right-4 px-3 py-1 bg-red-600 hover:bg-red-500 rounded text-white text-sm font-medium transition-colors z-10"
            title="Clear mixing area"
          >
            Clear
          </button>
        )}
        {/* Drop Zone Instructions */}
        {mixingArea.length === 0 && !isMixing && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-gray-400">
              <div className="text-4xl mb-2">🧪</div>
              <p className="text-lg font-medium">Drop elements here to mix</p>
              <p className="text-sm mt-1">Drag & drop or touch elements to combine them</p>
            </div>
          </div>
        )}

        {/* Mixing Status with Blur Backdrop */}
        {isMixing && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/30 backdrop-blur-sm rounded-lg animate-fade-in">
            <div className="text-center text-yellow-400 bg-black/50 rounded-xl p-6 border border-yellow-400/30">
              <div className="text-4xl mb-2 animate-spin">⚗️</div>
              <p className="text-lg font-medium">Mixing Elements...</p>
              <p className="text-sm mt-1">Please wait while the LLM creates magic</p>
            </div>
          </div>
        )}

        {/* Result Display */}
        {mixingResult && !isMixing && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-green-400">
              <div className="text-6xl mb-4 animate-bounce">✨</div>
              <p className="text-xl font-bold mb-2">Success!</p>
              <p className="text-lg">{mixingResult}</p>
            </div>
          </div>
        )}

        {/* Mixing Area Elements */}
        {mixingArea.map((element) => (
          <div
            key={element.id}
            className="absolute transform -translate-x-1/2 -translate-y-1/2 p-3 bg-gray-700 rounded-lg cursor-move hover:bg-gray-600 transition-colors select-none touch-manipulation animate-element-drop-in"
            style={{
              left: `${element.x}px`,
              top: `${element.y}px`,
            }}
            onMouseDown={(e) => onMixingElementMouseDown(e, element)}
            onTouchStart={(e) => onMixingElementTouchStart(e, element)}
          >
            <div className="flex flex-col items-center gap-1">
              <OpenMojiDisplay
                emoji={element.emoji}
                name={element.name}
                size="md"
                className="text-2xl"
              />
              <span className="text-xs text-white font-medium leading-tight max-w-16 text-center">
                {element.name}
              </span>
            </div>
          </div>
        ))}

        {/* Mixing Area Info */}
        {mixingArea.length > 0 && !isMixing && !mixingResult && (
          <div className="absolute bottom-4 left-4 text-sm text-gray-300">
            <p>{mixingArea.length} element{mixingArea.length !== 1 ? 's' : ''} ready to mix</p>
            {mixingArea.length >= 2 && (
              <p className="text-xs text-purple-400 mt-1">
                Move elements closer together to combine them
              </p>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\MixingAreaView.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\ReasoningPopup.tsx ===== 
import React from 'react';
import { X, Zap } from 'lucide-react';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { Element } from '../hooks/useGameState';

interface ReasoningPopup {
  element: Element;
  x: number;
  y: number;
  fromHover: boolean;
}

interface ReasoningPopupProps {
  reasoningPopup: ReasoningPopup | null;
  onClose: () => void;
}

export const ReasoningPopup: React.FC<ReasoningPopupProps> = ({ 
  reasoningPopup, 
  onClose 
}) => {
  if (!reasoningPopup) return null;

  const { element } = reasoningPopup;
  const hasParents = element.parents && element.parents.length > 0;

  return (
    <div
      className="reasoning-popup fixed z-50 bg-gray-800 border border-gray-600 rounded-lg p-4 max-w-xs shadow-xl"
      style={{
        left: `${Math.min(reasoningPopup.x, window.innerWidth - 200)}px`,
        top: `${Math.max(reasoningPopup.y - 100, 10)}px`,
        transform: 'translateX(-50%)'
      }}
    >
      <div className="flex items-center gap-2 mb-2">
        <OpenMojiDisplay 
          emoji={element.emoji} 
          hexcode={element.openmojiHex}
          name={element.name} 
          size="sm" 
        />
        <h4 className="font-semibold">{element.name}</h4>
      </div>
      
      {/* Show parent elements if available */}
      {hasParents && (
        <div className="mb-3 p-2 bg-gray-700/50 rounded border-l-2 border-blue-400">
          <div className="text-xs text-gray-400 mb-1">Created from:</div>
          <div className="flex items-center gap-1 text-sm">
            {element.parents!.map((parent, index) => (
              <React.Fragment key={parent.name}>
                <span className="text-yellow-300">{parent.name}</span>
                {index < element.parents!.length - 1 && (
                  <span className="text-gray-400">+</span>
                )}
              </React.Fragment>
            ))}
            {element.energyEnhanced && (
              <>
                <span className="text-gray-400">+</span>
                <span className="text-purple-300 flex items-center gap-1">
                  <Zap size={12} />
                  Energy
                </span>
              </>
            )}
          </div>
        </div>
      )}
      
      {/* Show reasoning */}
      {element.reasoning && (
        <p className="text-sm text-gray-300">{element.reasoning}</p>
      )}
      
      <button
        onClick={onClose}
        className="absolute top-2 right-2 text-gray-400 hover:text-white"
      >
        <X size={16} />
      </button>
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\ReasoningPopup.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\UnlockModal.tsx ===== 
import React, { useEffect } from 'react';
import { Achievement } from '@/types';
import { OpenMojiDisplay } from '@/components/game/OpenMojiDisplay';
import { Element } from '../hooks/useGameState';

interface ShowUnlock extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

interface UnlockModalProps {
  showUnlock: ShowUnlock | null;
  onClose: () => void;
}

export const UnlockModal: React.FC<UnlockModalProps> = ({ showUnlock, onClose }) => {
  // Auto-close after 3 seconds for new discoveries, 2 seconds for already discovered
  useEffect(() => {
    if (!showUnlock) return;
    
    const timeout = setTimeout(() => {
      onClose();
    }, showUnlock.isNew ? 3000 : 2000);

    return () => clearTimeout(timeout);
  }, [showUnlock, onClose]);

  if (!showUnlock) return null;

  // Get rarity-based styling
  const getRarityStyle = (rarity: string = 'common') => {
    switch (rarity) {
      case 'uncommon':
        return {
          borderColor: '#10B981', // Green
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          glowColor: '0 0 20px rgba(16, 185, 129, 0.3)'
        };
      case 'rare':
        return {
          borderColor: '#8B5CF6', // Purple
          backgroundColor: 'rgba(139, 92, 246, 0.1)',
          glowColor: '0 0 20px rgba(139, 92, 246, 0.3)'
        };
      case 'epic':
        return {
          borderColor: '#F59E0B', // Orange/Gold
          backgroundColor: 'rgba(245, 158, 11, 0.1)',
          glowColor: '0 0 20px rgba(245, 158, 11, 0.3)'
        };
      case 'legendary':
        return {
          borderColor: '#EF4444', // Red
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          glowColor: '0 0 20px rgba(239, 68, 68, 0.3)'
        };
      default:
        return {
          borderColor: '#6B7280', // Gray
          backgroundColor: 'rgba(107, 114, 128, 0.1)',
          glowColor: '0 0 20px rgba(107, 114, 128, 0.2)'
        };
    }
  };

  const rarityStyle = getRarityStyle(showUnlock.rarity);

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-fade-in" onClick={onClose}>
      <div 
        className="bg-gray-800 rounded-lg p-6 max-w-sm mx-4 border-2 animate-element-unlock-bounce cursor-pointer"
        style={{
          borderColor: rarityStyle.borderColor,
          backgroundColor: `${rarityStyle.backgroundColor}`,
          boxShadow: rarityStyle.glowColor
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="text-center">
          <div className="text-6xl mb-4">
            <OpenMojiDisplay 
              emoji={showUnlock.emoji} 
              hexcode={showUnlock.openmojiHex}
              name={showUnlock.name} 
              size="lg" 
            />
          </div>
          <h3 className="text-xl font-bold mb-2">
            {showUnlock.isNew ? 'New Discovery!' : 'Already Discovered'}
          </h3>
          <h4 className="text-lg text-yellow-400 mb-2">{showUnlock.name}</h4>
          {showUnlock.reasoning && (
            <p className="text-sm text-gray-300 mb-4">{showUnlock.reasoning}</p>
          )}
          {showUnlock.achievement && (
            <div className="bg-yellow-500/20 border border-yellow-500/50 rounded-lg p-3 mb-4">
              <div className="flex items-center gap-2 justify-center">
                <span className="text-2xl">🏆</span>
                <div>
                  <h5 className="font-semibold text-yellow-400">{showUnlock.achievement.name}</h5>
                  <p className="text-xs text-gray-300">{showUnlock.achievement.description}</p>
                </div>
              </div>
            </div>
          )}
          {showUnlock.isEndElement && (
            <div className="bg-purple-500/20 border border-purple-500/50 rounded-lg p-2 mb-4">
              <span className="text-sm text-purple-300">🏁 End Element</span>
            </div>
          )}
          
          {/* Rarity indicator */}
          {showUnlock.rarity && showUnlock.rarity !== 'common' && (
            <div className="mt-4">
              <span 
                className="px-2 py-1 rounded-full text-xs font-bold uppercase tracking-wide"
                style={{ 
                  color: rarityStyle.borderColor,
                  backgroundColor: rarityStyle.backgroundColor,
                  border: `1px solid ${rarityStyle.borderColor}`
                }}
              >
                {showUnlock.rarity}
              </span>
            </div>
          )}
          
          {/* Auto-close indicator */}
          <div className="mt-4 text-xs text-gray-400">
            Click anywhere to close • Auto-closes in {showUnlock.isNew ? '3' : '2'}s
          </div>
        </div>
      </div>
    </div>
  );
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\components\UnlockModal.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\contexts\GameStateProvider.tsx ===== 
'use client';

import React, { createContext, useContext, ReactNode } from 'react';
import { useGameState, GameState, GameAction, Element, MixingElement, LastCombination } from '../hooks/useGameState';
import { Achievement } from '@/types/game.types';

// Context type definition
interface GameStateContextType {
  state: GameState;
  dispatch: React.Dispatch<GameAction>;
  actions: {
    setGameMode: (mode: 'science' | 'creative') => void;
    setElements: (elements: Element[]) => void;
    addElement: (element: Element) => void;
    setEndElements: (endElements: Element[]) => void;
    addEndElement: (element: Element) => void;
    setCombinations: (combinations: Record<string, string | null>) => void;
    addCombination: (key: string, result: string | null) => void;
    setMixingArea: (mixingArea: MixingElement[]) => void;
    addToMixingArea: (element: MixingElement) => void;
    removeFromMixingArea: (indices: number[]) => void;
    updateMixingElement: (index: number, updates: Partial<MixingElement>) => void;
    clearMixingArea: () => void;
    setAchievements: (achievements: Achievement[]) => void;
    addAchievements: (achievements: Achievement[]) => void;
    setFailedCombinations: (failedCombinations: string[]) => void;
    addFailedCombination: (combination: string) => void;
    setDimmedElements: (dimmedElements: Set<string>) => void;
    addDimmedElement: (elementName: string) => void;
    removeDimmedElement: (elementName: string) => void;
    clearDimmedElements: () => void;
    setAnimatingElements: (animatingElements: Set<string>) => void;
    addAnimatingElement: (elementName: string) => void;
    removeAnimatingElement: (elementName: string) => void;
    clearAnimatingElements: () => void;
    setIsUndoing: (isUndoing: boolean) => void;
    setLastCombination: (combination: LastCombination | null) => void;
    setUndoAvailable: (available: boolean) => void;
    incrementTotalCombinations: () => void;
    setStateRestored: (restored: boolean) => void;
    loadSavedState: (savedState: Partial<GameState>) => void;
    resetGameState: (gameMode: 'science' | 'creative') => void;
  };
}

// Create the context
const GameStateContext = createContext<GameStateContextType | undefined>(undefined);

// Provider component props
interface GameStateProviderProps {
  children: ReactNode;
  initialGameMode?: 'science' | 'creative';
}

// Provider component
export function GameStateProvider({ children, initialGameMode = 'science' }: GameStateProviderProps) {
  const gameState = useGameState(initialGameMode);

  return (
    <GameStateContext.Provider value={gameState}>
      {children}
    </GameStateContext.Provider>
  );
}

// Custom hook to use the game state context
export function useGameStateContext(): GameStateContextType {
  const context = useContext(GameStateContext);
  
  if (context === undefined) {
    throw new Error('useGameStateContext must be used within a GameStateProvider');
  }
  
  return context;
}

// Convenience hooks for specific parts of the state
export function useGameMode() {
  const { state, actions } = useGameStateContext();
  return {
    gameMode: state.gameMode,
    setGameMode: actions.setGameMode,
  };
}

export function useElements() {
  const { state, actions } = useGameStateContext();
  return {
    elements: state.elements,
    endElements: state.endElements,
    setElements: actions.setElements,
    addElement: actions.addElement,
    setEndElements: actions.setEndElements,
    addEndElement: actions.addEndElement,
  };
}

export function useMixingArea() {
  const { state, actions } = useGameStateContext();
  return {
    mixingArea: state.mixingArea,
    setMixingArea: actions.setMixingArea,
    addToMixingArea: actions.addToMixingArea,
    removeFromMixingArea: actions.removeFromMixingArea,
    updateMixingElement: actions.updateMixingElement,
    clearMixingArea: actions.clearMixingArea,
  };
}

export function useCombinations() {
  const { state, actions } = useGameStateContext();
  return {
    combinations: state.combinations,
    failedCombinations: state.failedCombinations,
    setCombinations: actions.setCombinations,
    addCombination: actions.addCombination,
    setFailedCombinations: actions.setFailedCombinations,
    addFailedCombination: actions.addFailedCombination,
  };
}

export function useAchievements() {
  const { state, actions } = useGameStateContext();
  return {
    achievements: state.achievements,
    setAchievements: actions.setAchievements,
    addAchievements: actions.addAchievements,
  };
}

export function useGameUndo() {
  const { state, actions } = useGameStateContext();
  return {
    lastCombination: state.lastCombination,
    undoAvailable: state.undoAvailable,
    setLastCombination: actions.setLastCombination,
    setUndoAvailable: actions.setUndoAvailable,
  };
}

export function useGameStats() {
  const { state, actions } = useGameStateContext();
  return {
    totalCombinationsMade: state.totalCombinationsMade,
    isStateRestored: state.isStateRestored,
    incrementTotalCombinations: actions.incrementTotalCombinations,
    setStateRestored: actions.setStateRestored,
  };
}

export function useGamePersistence() {
  const { actions } = useGameStateContext();
  return {
    loadSavedState: actions.loadSavedState,
    resetGameState: actions.resetGameState,
  };
}

export function useElementInteractionState() {
  const { state, actions } = useGameStateContext();
  return {
    dimmedElements: state.dimmedElements,
    animatingElements: state.animatingElements,
    isUndoing: state.isUndoing,
    setDimmedElements: actions.setDimmedElements,
    addDimmedElement: actions.addDimmedElement,
    removeDimmedElement: actions.removeDimmedElement,
    clearDimmedElements: actions.clearDimmedElements,
    setAnimatingElements: actions.setAnimatingElements,
    addAnimatingElement: actions.addAnimatingElement,
    removeAnimatingElement: actions.removeAnimatingElement,
    clearAnimatingElements: actions.clearAnimatingElements,
    setIsUndoing: actions.setIsUndoing,
  };
}
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\contexts\GameStateProvider.tsx ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementInteraction.ts ===== 
import { useCallback, useRef } from 'react';
import { useMixingArea } from '../contexts/GameStateProvider';
import { Element, MixingElement } from './useGameState';
import * as GameLogic from '@/lib/game-logic';

interface UseElementInteractionProps {
  onMixElements: (elem1: MixingElement, elem2: MixingElement) => Promise<void>;
  onShowToast: (message: string) => void;
  onPlaySound: (type: string) => void;
  dropZoneRef: React.RefObject<HTMLDivElement | null>;
}

export function useElementInteraction({
  onMixElements,
  onShowToast,
  onPlaySound,
  dropZoneRef
}: UseElementInteractionProps) {
  const { mixingArea, addToMixingArea, updateMixingElement } = useMixingArea();
  const draggedElementRef = useRef<MixingElement | null>(null);
  const isDraggingRef = useRef(false);

  // Handle drag start for elements in mixing area
  const handleDragStart = useCallback((element: MixingElement, event: React.DragEvent | React.PointerEvent) => {
    draggedElementRef.current = element;
    isDraggingRef.current = true;
    onPlaySound('pick');
    
    // Haptic feedback for touch devices
    if ('vibrate' in navigator) {
      navigator.vibrate(50);
    }
    
    if ('dataTransfer' in event) {
      // Desktop drag and drop
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', element.id);
    }
  }, [onPlaySound]);

  // Handle drag over for mixing area
  const handleDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  // Handle drop in mixing area
  const handleDrop = useCallback((event: React.DragEvent | React.TouchEvent) => {
    event.preventDefault();
    
    if (!draggedElementRef.current || !dropZoneRef.current) return;
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    let clientX: number, clientY: number;
    
    if ('clientX' in event) {
      // Mouse/drag event
      clientX = event.clientX;
      clientY = event.clientY;
    } else if ('touches' in event) {
      // Touch event
      const touch = event.touches?.[0] || event.changedTouches?.[0];
      if (!touch) return;
      clientX = touch.clientX;
      clientY = touch.clientY;
    } else {
      return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Resolve collisions with other elements
    const newPosition = GameLogic.resolveCollisions(
      x, 
      y, 
      mixingArea, 
      dropZoneRef.current, 
      draggedElementRef.current.index
    );
    
    // Update element position
    updateMixingElement(draggedElementRef.current.index, {
      x: newPosition.x,
      y: newPosition.y
    });
    
    // Check for collisions with other elements after drop
    checkForMixing(draggedElementRef.current.index, newPosition.x, newPosition.y);
    
    draggedElementRef.current = null;
    isDraggingRef.current = false;
  }, [mixingArea, updateMixingElement, dropZoneRef]);

  // Check for element mixing after position update
  const checkForMixing = useCallback((movedIndex: number, x: number, y: number) => {
    const movedElement = mixingArea.find(el => el.index === movedIndex);
    if (!movedElement) return;
    
    // Check collision with other elements
    for (const otherElement of mixingArea) {
      if (otherElement.index === movedIndex) continue;
      
      if (GameLogic.checkCollision(x, y, otherElement.x, otherElement.y)) {
        // Found a collision - trigger mixing
        onMixElements(movedElement, otherElement);
        return;
      }
    }
  }, [mixingArea, onMixElements]);

  // Handle element drag from element panel to mixing area
  const handleElementDrop = useCallback((element: Element, clientX: number, clientY: number) => {
    if (!dropZoneRef.current) return;
    
    // Prevent dropping end elements
    if (element.isEndElement) {
      onShowToast('End elements cannot be mixed');
      return;
    }
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    const x = clientX - rect.left - GameLogic.getElementSize() / 2;
    const y = clientY - rect.top - GameLogic.getElementSize() / 2;
    
    // Resolve position to avoid collisions
    const newPosition = GameLogic.resolveCollisions(x, y, mixingArea, dropZoneRef.current);
    
    // Create mixing element
    const mixingElement: MixingElement = {
      ...element,
      x: newPosition.x,
      y: newPosition.y,
      index: Date.now() + Math.random(), // Unique index
      energized: false
    };
    
    addToMixingArea(mixingElement);
    onPlaySound('drop');
    
    // Check for immediate mixing
    setTimeout(() => {
      checkForMixing(mixingElement.index, newPosition.x, newPosition.y);
    }, 100);
  }, [mixingArea, addToMixingArea, onPlaySound, onShowToast, dropZoneRef, checkForMixing]);

  // Handle double click for quick mixing
  const handleElementDoubleClick = useCallback((element: Element) => {
    if (element.isEndElement) {
      onShowToast('End elements cannot be mixed');
      return;
    }
    
    // Find the center of the mixing area
    if (!dropZoneRef.current) return;
    
    const rect = dropZoneRef.current.getBoundingClientRect();
    const centerX = rect.width / 2 - GameLogic.getElementSize() / 2;
    const centerY = rect.height / 2 - GameLogic.getElementSize() / 2;
    
    // Resolve position
    const newPosition = GameLogic.resolveCollisions(centerX, centerY, mixingArea, dropZoneRef.current);
    
    // Create mixing element
    const mixingElement: MixingElement = {
      ...element,
      x: newPosition.x,
      y: newPosition.y,
      index: Date.now() + Math.random(),
      energized: false
    };
    
    addToMixingArea(mixingElement);
    onPlaySound('drop');
  }, [mixingArea, addToMixingArea, onPlaySound, onShowToast, dropZoneRef]);

  // Touch handling for mobile devices
  const handleTouchStart = useCallback((element: MixingElement, event: React.TouchEvent) => {
    event.preventDefault();
    handleDragStart(element, event as unknown as React.PointerEvent);
  }, [handleDragStart]);

  const handleTouchMove = useCallback((event: React.TouchEvent) => {
    event.preventDefault();
    if (!isDraggingRef.current || !draggedElementRef.current || !dropZoneRef.current) return;
    
    const touch = event.touches[0];
    const rect = dropZoneRef.current.getBoundingClientRect();
    const x = touch.clientX - rect.left - GameLogic.getElementSize() / 2;
    const y = touch.clientY - rect.top - GameLogic.getElementSize() / 2;
    
    // Update position during drag
    updateMixingElement(draggedElementRef.current.index, { x, y });
  }, [updateMixingElement, dropZoneRef]);

  const handleTouchEnd = useCallback((event: React.TouchEvent) => {
    event.preventDefault();
    if (!isDraggingRef.current || !draggedElementRef.current) return;
    
    handleDrop(event);
  }, [handleDrop]);

  // Keyboard accessibility
  const handleKeyDown = useCallback((element: Element, event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleElementDoubleClick(element);
    }
  }, [handleElementDoubleClick]);

  // Clear dragging state (useful for cleanup)
  const clearDragState = useCallback(() => {
    draggedElementRef.current = null;
    isDraggingRef.current = false;
  }, []);

  // Get drag state
  const isDragging = useCallback(() => isDraggingRef.current, []);
  const getDraggedElement = useCallback(() => draggedElementRef.current, []);

  return {
    // Drag and drop handlers
    handleDragStart,
    handleDragOver,
    handleDrop,
    handleElementDrop,
    
    // Touch handlers
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    
    // Interaction handlers
    handleElementDoubleClick,
    handleKeyDown,
    
    // State management
    clearDragState,
    isDragging,
    getDraggedElement,
    
    // Mixing check
    checkForMixing
  };
}
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementInteraction.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementMixing.ts ===== 
import { useCallback } from 'react';
import { useSupabase } from '@/components/auth/SupabaseProvider';
import { createClient, incrementDailyCount, saveGameState, consumeToken } from '@/lib/supabase';
import { buildSharedSections, buildSciencePrompt, buildCreativePrompt } from '@/lib/llm-prompts';
import { checkAchievements } from '@/lib/achievements';
import { elementMatchesCategory } from '@/lib/challenge-elements';
import { resolveEmoji } from '@/lib/openmoji-service';
import { GAME_CONFIG } from '@/lib/game-config';
import { Achievement } from '@/types';
import { 
  useGameMode, 
  useElements, 
  useMixingArea, 
  useCombinations, 
  useAchievements, 
  useGameUndo, 
  useGameStats 
} from '../contexts/GameStateProvider';
import { Element, MixingElement, LastCombination } from './useGameState';
import * as GameLogic from '@/lib/game-logic';

interface ShowUnlockElement extends Element {
  isNew: boolean;
  achievement?: Achievement | null;
}

interface UseElementMixingProps {
  userApiKey: string;
  selectedModel: 'flash' | 'pro';
  onShowToast: (message: string) => void;
  onPlaySound: (type: string) => void;
  onShowUnlock: (element: ShowUnlockElement | null) => void;
  onSetShakeElement: (id: string | null) => void;
  onSetPopElement: (id: string | null) => void;
  onSetUnlockAnimationStartTime: (time: number | null) => void;
  dropZoneRef: React.RefObject<HTMLDivElement | null>;
}

export function useElementMixing({
  userApiKey,
  selectedModel,
  onShowToast,
  onPlaySound,
  onShowUnlock,
  onSetShakeElement,
  onSetPopElement,
  onSetUnlockAnimationStartTime,
  dropZoneRef
}: UseElementMixingProps) {
  const { user, dailyCount, tokenBalance, refreshDailyCount, refreshTokenBalance } = useSupabase();
  const { gameMode } = useGameMode();
  const { elements, endElements, addElement, addEndElement } = useElements();
  const { mixingArea, setMixingArea, updateMixingElement, removeFromMixingArea, addToMixingArea } = useMixingArea();
  const { combinations, failedCombinations, addCombination, addFailedCombination } = useCombinations();
  const { achievements, addAchievements } = useAchievements();
  const { setLastCombination, setUndoAvailable } = useGameUndo();
  const { incrementTotalCombinations } = useGameStats();

  // Generate combination using API
  const generateCombination = useCallback(async (
    elem1: Element, 
    elem2: Element, 
    elem3: Element | null = null
  ): Promise<GameLogic.CombinationResult> => {
    // Check daily limit first
    const limitCheck = GameLogic.shouldAllowMixing(
      userApiKey, 
      tokenBalance, 
      dailyCount, 
      GAME_CONFIG.DAILY_FREE_COMBINATIONS
    );
    
    if (!limitCheck.allowed) {
      onShowToast(limitCheck.reason!);
      return { result: null, error: true, limitReached: true };
    }

    // Determine model selection
    const modelSelection = GameLogic.determineModelSelection(userApiKey, tokenBalance, selectedModel);
    console.log(`[LLM-Alchemy Frontend] User Type: ${modelSelection.userType} | Model: ${modelSelection.model} | Reason: ${modelSelection.reason}`);

    // Build combination key for caching
    const sortedNames = [elem1.name, elem2.name, elem3?.name].filter(Boolean).sort().join('+');
    const mixKey = elem3 ? `${sortedNames}+Energy` : sortedNames;

    // Check cache first
    const cachedResult = GameLogic.getCachedCombination(mixKey, combinations, elements, endElements);
    if (cachedResult) return cachedResult;

    // Check hardcoded combinations
    const hardcodedResult = GameLogic.getHardcodedCombination(sortedNames, gameMode);
    if (hardcodedResult) {
      // Add 1-second delay to simulate LLM processing
      await new Promise(resolve => setTimeout(resolve, 1000));
      return hardcodedResult;
    }

    // Build context for LLM
    const { recentText, failedText } = GameLogic.buildCombinationContext(combinations, failedCombinations);
    const rarityTarget = GameLogic.calculateRarityTarget();

    // Build shared sections and prompt
    const sharedSections = buildSharedSections(rarityTarget, gameMode);
    const mixingElements = [elem1, elem2, elem3].filter((e): e is Element => e !== null);
    
    const prompt = gameMode === 'science' 
      ? buildSciencePrompt(elements, mixingElements, sharedSections, recentText, failedText)
      : buildCreativePrompt(elements, mixingElements, sharedSections, recentText, failedText);

    // Make API request with retry logic
    const makeRequest = async (): Promise<{
      error?: string;
      outcomes?: Array<{
        result: string;
        emoji: string;
        color: string;
        rarity: string;
        reasoning: string;
        achievementTags: string[];
        emojiTags: string[];
        tags: string[];
        isEndElement: boolean;
      }> | null;
      reasoning?: string;
    }> => {
      const abortController = new AbortController();
      const timeoutId = setTimeout(() => abortController.abort(), 8000);
      
      try {
        const requestBody = { 
          prompt, 
          gameMode,
          apiKey: userApiKey,
          useProModel: modelSelection.useProModel
        };
        
        const response = await fetch('/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
          signal: abortController.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`[LLM-Alchemy Debug] API request failed:`, response.status, errorText);
          throw new Error(`API request failed: ${response.status}`);
        }

        const rawResponse = await response.text();
        return JSON.parse(rawResponse);
        
      } catch (error) {
        clearTimeout(timeoutId);
        
        if (error instanceof Error && error.name === 'AbortError') {
          throw new Error('Request timed out');
        }
        
        throw error;
      }
    };

    try {
      let parsedResult;
      
      try {
        parsedResult = await makeRequest();
      } catch (firstError) {
        const errorMessage = firstError instanceof Error ? firstError.message : 'Unknown error';
        
        if (errorMessage === 'Request timed out') {
          onShowToast('Connection slow, retrying...');
          
          try {
            parsedResult = await makeRequest();
          } catch (retryError) {
            const retryErrorMessage = retryError instanceof Error ? retryError.message : 'Unknown error';
            
            if (retryErrorMessage === 'Request timed out') {
              onShowToast('LLM timeout - try mixing again');
            } else {
              onShowToast('Network error - check connection');
            }
            
            return { result: null, error: true, timeout: true };
          }
        } else {
          throw firstError;
        }
      }
      
      // Handle API response
      if (parsedResult.error) {
        onShowToast('API Error: ' + parsedResult.error);
        return { result: null, error: true };
      }
      
      if (parsedResult.outcomes === null) {
        // No valid combination - track as failed
        const failedKey = `${elem1.name}+${elem2.name}${elem3 ? '+Energy' : ''}`;
        addFailedCombination(failedKey);
        
        // Increment counter for failed attempts too
        await incrementUsageCounter();
        return { result: null, reasoning: parsedResult.reasoning };
      }
      
      // Handle successful outcomes
      if (Array.isArray(parsedResult.outcomes) && parsedResult.outcomes.length > 0) {
        let selectedOutcome;
        
        if (parsedResult.outcomes.length === 1) {
          selectedOutcome = parsedResult.outcomes[0];
        } else {
          // Multiple outcomes - select based on rarity probabilities
          const roll = Math.random() * 100;
          
          const commonOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'common');
          const uncommonOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'uncommon');
          const rareOutcomes = parsedResult.outcomes.filter(o => o.rarity === 'rare');
          
          if (roll < 60 && commonOutcomes.length > 0) {
            selectedOutcome = commonOutcomes[Math.floor(Math.random() * commonOutcomes.length)];
          } else if (roll < 90 && uncommonOutcomes.length > 0) {
            selectedOutcome = uncommonOutcomes[Math.floor(Math.random() * uncommonOutcomes.length)];
          } else if (rareOutcomes.length > 0) {
            selectedOutcome = rareOutcomes[Math.floor(Math.random() * rareOutcomes.length)];
          } else {
            selectedOutcome = parsedResult.outcomes[Math.floor(Math.random() * parsedResult.outcomes.length)];
          }
        }
        
        // Increment usage counter for successful API calls
        await incrementUsageCounter();
        
        return {
          result: selectedOutcome.result || null,
          emoji: selectedOutcome.emoji || '✨',
          color: selectedOutcome.color || '#808080',
          rarity: selectedOutcome.rarity || 'common',
          reasoning: selectedOutcome.reasoning || '',
          achievementTags: selectedOutcome.achievementTags || [],
          emojiTags: selectedOutcome.emojiTags || [],
          tags: selectedOutcome.tags || [],
          isEndElement: selectedOutcome.isEndElement || false
        };
      }
      
      await incrementUsageCounter();
      return { result: null };
      
    } catch (error) {
      console.error('Error generating combination:', error);
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        onShowToast('Network Error: Check connection and try again');
      } else if (error instanceof SyntaxError) {
        onShowToast('API Error: Invalid response format');
      } else {
        onShowToast('LLM Error: Try mixing different elements');
      }
      
      return { result: null, error: true };
    }
  }, [userApiKey, selectedModel, gameMode, elements, endElements, combinations, failedCombinations, tokenBalance, dailyCount]);

  // Helper to increment usage counter
  const incrementUsageCounter = useCallback(async () => {
    try {
      if (user && !userApiKey) {
        const supabase = createClient();
        
        if (tokenBalance > 0) {
          await consumeToken(supabase, user.id);
          await refreshTokenBalance();
        } else {
          await incrementDailyCount(supabase, user.id);
          await refreshDailyCount();
        }
      }
      return true;
    } catch (error) {
      console.error('Error updating usage counter:', error);
      return true;
    }
  }, [user, userApiKey, tokenBalance, refreshTokenBalance, refreshDailyCount]);

  // Check challenge completion
  const checkChallengeCompletion = useCallback(async (element: Element) => {
    if (!user) return;
    
    try {
      const response = await fetch('/api/challenges/current');
      if (!response.ok) return;
      
      const data = await response.json();
      const currentChallenges = data.challenges || [];
      
      for (const challenge of currentChallenges) {
        if (challenge.isCompleted) continue;
        
        let isCompleted = false;
        
        if (challenge.target_element) {
          isCompleted = element.name.toLowerCase() === challenge.target_element.toLowerCase();
        } else if (challenge.target_category) {
          const elementTags = element.achievementTags || element.tags || [];
          isCompleted = elementMatchesCategory(elementTags, challenge.target_category);
        }
        
        if (isCompleted) {
          const response = await fetch('/api/challenges/complete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              challengeId: challenge.id,
              elementDiscovered: element.name,
              elementTags: element.tags || [],
              gameMode
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            
            if (result.tokensAwarded > 0) {
              onShowToast(`🎉 Challenge completed! +${result.tokensAwarded} tokens`);
              await refreshTokenBalance();
            } else {
              onShowToast(`🎉 Challenge completed!`);
            }
            
            onPlaySound('reward');
          }
        }
      }
    } catch (error) {
      console.error('Error checking challenge completion:', error);
    }
  }, [user, gameMode, refreshTokenBalance, onShowToast, onPlaySound]);

  // Main mixing function
  const mixElements = useCallback(async (elem1: MixingElement, elem2: MixingElement) => {
    if (!GameLogic.validateMixing(elem1, elem2)) return;
    
    onPlaySound('pop');
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate([10, 10, 10]);
    }
    
    const mixingType = GameLogic.getMixingType(elem1, elem2);
    
    if (mixingType === 'energize') {
      // Energize the non-energy element
      const targetEl = elem2.name === 'Energy' ? elem1 : elem2;
      updateMixingElement(targetEl.index, { energized: true });
      
      // Remove energy element
      const energyIndex = elem1.name === 'Energy' ? elem1.index : elem2.index;
      removeFromMixingArea([energyIndex]);
      
    } else if (mixingType === 'energy-mix') {
      // Mix with energy
      const baseElem1 = elem1.energized ? { ...elem1, energized: false } as Element : elem1;
      const baseElem2 = elem2.energized ? { ...elem2, energized: false } as Element : elem2;
      
      await performMix([baseElem1, baseElem2], true, elem1.index, elem2.index);
      
    } else {
      // Normal mixing
      await performMix([elem1, elem2], false, elem1.index, elem2.index);
    }
  }, [onPlaySound, updateMixingElement, setMixingArea]);

  // Perform the actual mixing logic
  const performMix = useCallback(async (
    elementsToMix: Element[], 
    hasEnergy: boolean = false, 
    ...indicesToRemove: number[]
  ) => {
    // Remove elements from mixing area immediately
    removeFromMixingArea(indicesToRemove);
    
    const mixKey = GameLogic.generateCombinationKey(elementsToMix, hasEnergy);
    
    // Check if combination already exists
    const cachedResult = GameLogic.getCachedCombination(mixKey, combinations, elements, endElements);
    if (cachedResult) {
      if (cachedResult.result) {
        const existingElement = elements.find(e => e.name === cachedResult.result) || 
                                endElements.find(e => e.name === cachedResult.result);
        if (existingElement) {
          onShowUnlock({ ...existingElement, isNew: false });
          if (!existingElement.isEndElement) {
            onSetShakeElement(existingElement.id);
            setTimeout(() => {
              onShowUnlock(null);
              onSetShakeElement(null);
            }, 1500);
          } else {
            setTimeout(() => onShowUnlock(null), 1500);
          }
        }
      } else {
        onShowToast('No reaction');
      }
      return;
    }

    // Generate new combination
    const result = await generateCombination(
      elementsToMix[0], 
      elementsToMix[1], 
      hasEnergy ? { name: 'Energy' } as Element : null
    );
    
    if (result.error) return;
    
    if (result.result) {
      // Check if element already exists
      const existing = elements.find(e => e.name.toLowerCase() === result.result!.toLowerCase()) ||
                      endElements.find(e => e.name.toLowerCase() === result.result!.toLowerCase());
      
      if (existing) {
        onShowUnlock({ ...existing, isNew: false });
        if (!existing.isEndElement) {
          onSetShakeElement(existing.id);
          setTimeout(() => {
            onShowUnlock(null);
            onSetShakeElement(null);
          }, 1500);
        } else {
          setTimeout(() => onShowUnlock(null), 1500);
        }
      } else {
        // Create new element
        const isEndElement = result.isEndElement || false;
        
        // Resolve OpenMoji for the new element
        const emojiTags = result.emojiTags || result.achievementTags || result.tags || [];
        const openmojiData = resolveEmoji({
          unicodeEmoji: result.emoji || '✨',
          name: result.result,
          tags: emojiTags
        });
        
        const newElement: Element = {
          id: result.result.toLowerCase().replace(/\s+/g, '-'),
          name: result.result,
          emoji: result.emoji || '✨',
          color: result.color || '#808080',
          unlockOrder: elements.length + endElements.length,
          rarity: result.rarity || 'common',
          reasoning: result.reasoning || '',
          achievementTags: result.achievementTags || [],
          emojiTags: result.emojiTags || [],
          tags: result.tags || [],
          isEndElement,
          parents: elementsToMix,
          energyEnhanced: hasEnergy && elementsToMix.length === 2,
          ...(openmojiData.isExtra && {
            openmojiHex: openmojiData.hexcode,
            isOpenmojiExtra: true
          })
        };
        
        // Add to appropriate collection
        if (isEndElement) {
          onPlaySound('end-element');
          addEndElement(newElement);
        } else {
          onPlaySound('reward');
          addElement(newElement);
          onSetPopElement(newElement.id);
        }
        
        // Check achievements
        let allAchievements: Achievement[] = [];
        let contextualAchievement = null;
        try {
          const updatedElements = isEndElement ? elements : [...elements, newElement];
          const updatedEndElements = isEndElement ? [...endElements, newElement] : endElements;
          
          allAchievements = checkAchievements(newElement, updatedElements, updatedEndElements, achievements, gameMode);
          contextualAchievement = allAchievements.find(a => a.id.startsWith('first-'));
          
          if (allAchievements.length > 0) {
            addAchievements(allAchievements);
          }
        } catch (error) {
          console.error('Achievement check failed:', error);
        }

        // Set up undo functionality
        const lastCombination: LastCombination = {
          createdElement: {
            element: newElement,
            isEndElement: isEndElement
          },
          combinationKey: mixKey,
          mixingAreaState: mixingArea, // Capture current mixing area state
          achievementsGained: allAchievements,
          endElementsGained: isEndElement ? [newElement] : [],
          timestamp: Date.now()
        };
        
        setLastCombination(lastCombination);
        setUndoAvailable(true);
        incrementTotalCombinations();

        // Save state immediately
        if (user && gameMode) {
          try {
            const supabase = createClient();
            const updatedElements = isEndElement ? elements : [...elements, newElement];
            const updatedEndElements = isEndElement ? [...endElements, newElement] : endElements;
            
            await saveGameState(supabase, user.id, {
              game_mode: gameMode,
              elements: updatedElements,
              end_elements: updatedEndElements,
              combinations: { ...combinations, [mixKey]: result.result },
              achievements: [...achievements, ...allAchievements],
              failed_combinations: failedCombinations
            });
          } catch (error) {
            console.error('Immediate save failed:', error);
          }
        }
        
        // Check challenge completion
        await checkChallengeCompletion(newElement);
        
        // Show unlock modal
        onShowUnlock({ 
          ...newElement, 
          isNew: true,
          achievement: contextualAchievement || null
        });
        onSetUnlockAnimationStartTime(Date.now());
        
        if (!isEndElement) {
          // Add new element to mixing area center
          const rect = dropZoneRef.current?.getBoundingClientRect();
          if (rect) {
            const offset = GameLogic.getElementSize() / 2;
            const centerX = rect.width / 2 - offset;
            const centerY = rect.height / 2 - offset;
            const newPos = GameLogic.resolveCollisions(centerX, centerY, mixingArea, dropZoneRef.current);
            
            const centerElement: MixingElement = {
              ...newElement,
              x: newPos.x,
              y: newPos.y,
              index: Date.now() + 1000,
              energized: false
            };
            
            addToMixingArea(centerElement);
          }
          
          setTimeout(() => {
            onShowUnlock(null);
            onSetPopElement(null);
            onSetUnlockAnimationStartTime(null);
          }, 3000);
        } else {
          setTimeout(() => {
            onShowUnlock(null);
            onSetUnlockAnimationStartTime(null);
          }, 3000);
        }
      }
      
      // Cache the result
      addCombination(mixKey, result.result);
    } else {
      // No reaction
      const reasoningText = result.reasoning || 'No reaction';
      onShowToast(reasoningText);
      addCombination(mixKey, null);
    }
  }, [
    setMixingArea, combinations, elements, endElements, generateCombination, onShowUnlock, 
    onSetShakeElement, onPlaySound, onSetPopElement, addEndElement, addElement, achievements, 
    addAchievements, setLastCombination, setUndoAvailable, incrementTotalCombinations, 
    user, gameMode, failedCombinations, checkChallengeCompletion, onSetUnlockAnimationStartTime,
    dropZoneRef, mixingArea, addCombination, onShowToast
  ]);

  return {
    mixElements,
    performMix
  };
}
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useElementMixing.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAnimations.ts ===== 
'use client';

import { useState, useCallback, useRef } from 'react';
import { Element, MixingElement } from './useGameState';

/**
 * Hook for managing game animations and visual feedback
 * Handles shake, pop, removal, and load animations
 */
export const useGameAnimations = () => {
  // Animation state
  const [shakeElement, setShakeElement] = useState<string | null>(null);
  const [popElement, setPopElement] = useState<string | null>(null);
  const [animatingElements, setAnimatingElements] = useState<Set<string>>(new Set());
  const [isPlayingLoadAnimation, setIsPlayingLoadAnimation] = useState<boolean>(false);
  const [animatedElements, setAnimatedElements] = useState<Set<string>>(new Set());
  
  // Timeout tracking for cleanup
  const animationTimeouts = useRef<Map<string, NodeJS.Timeout>>(new Map());

  // Clear existing timeout helper
  const clearExistingTimeout = useCallback((key: string) => {
    const existing = animationTimeouts.current.get(key);
    if (existing) {
      clearTimeout(existing);
      animationTimeouts.current.delete(key);
    }
  }, []);

  // Trigger shake animation on an element
  const triggerShake = useCallback((elementId: string) => {
    setShakeElement(elementId);
    
    // Clear any existing shake timeout for this element
    clearExistingTimeout(`shake-${elementId}`);
    
    // Set new timeout to clear shake
    const timeout = setTimeout(() => {
      setShakeElement(null);
    }, 500);
    
    animationTimeouts.current.set(`shake-${elementId}`, timeout);
  }, [clearExistingTimeout]);

  // Trigger pop animation on an element
  const triggerPop = useCallback((elementId: string) => {
    setPopElement(elementId);
    
    // Clear any existing pop timeout for this element
    clearExistingTimeout(`pop-${elementId}`);
    
    // Set new timeout to clear pop
    const timeout = setTimeout(() => {
      setPopElement(null);
    }, 300);
    
    animationTimeouts.current.set(`pop-${elementId}`, timeout);
  }, [clearExistingTimeout]);

  // Animate removal of elements from mixing area
  const animateRemoval = useCallback((elements: MixingElement[], onComplete: () => void) => {
    if (elements.length === 0) {
      onComplete();
      return;
    }
    
    // Stagger the removal animation for each element
    elements.forEach((el, index) => {
      const timeout = setTimeout(() => {
        setAnimatingElements(prev => new Set(prev).add(`${el.id}-${el.index}`));
      }, index * 50);
      
      animationTimeouts.current.set(`removal-${el.id}-${el.index}`, timeout);
    });
    
    // Complete the animation and call onComplete
    const totalDuration = elements.length * 50 + 300;
    const completeTimeout = setTimeout(() => {
      onComplete();
      setAnimatingElements(new Set());
    }, totalDuration);
    
    animationTimeouts.current.set('removal-complete', completeTimeout);
  }, []);

  // Play element load animation (for loading saved game state)
  const playElementLoadAnimation = useCallback((elementsToAnimate: Element[]) => {
    const elementsToAnimate_filtered = elementsToAnimate.filter(e => e.unlockOrder > 4);
    if (elementsToAnimate_filtered.length === 0 || isPlayingLoadAnimation) return;
    
    console.log('[LOAD_ANIMATION] Starting element load animation for', elementsToAnimate_filtered.length, 'elements');
    setIsPlayingLoadAnimation(true);
    
    // Sort elements by unlock order for proper animation sequence
    const sortedElements = [...elementsToAnimate_filtered].sort((a, b) => a.unlockOrder - b.unlockOrder);
    setAnimatedElements(new Set(sortedElements.map(e => e.id)));
    
    // Calculate total animation duration
    const totalDuration = (sortedElements.length * 25) + 300 + 200;
    
    // Clear existing load animation timeout
    clearExistingTimeout('load-animation');
    
    // Set timeout to complete load animation
    const timeout = setTimeout(() => {
      setIsPlayingLoadAnimation(false);
      setAnimatedElements(new Set());
    }, totalDuration);
    
    animationTimeouts.current.set('load-animation', timeout);
  }, [isPlayingLoadAnimation, clearExistingTimeout]);

  // Clear all animations (useful for cleanup or mode switching)
  const clearAllAnimations = useCallback(() => {
    setShakeElement(null);
    setPopElement(null);
    setAnimatingElements(new Set());
    setIsPlayingLoadAnimation(false);
    setAnimatedElements(new Set());
    
    // Clear all timeouts
    animationTimeouts.current.forEach(timeout => clearTimeout(timeout));
    animationTimeouts.current.clear();
  }, []);

  // Check if an element is currently being animated
  const isElementAnimated = useCallback((elementId: string) => {
    return animatedElements.has(elementId);
  }, [animatedElements]);

  // Check if an element is in removal animation
  const isElementRemoving = useCallback((elementId: string, elementIndex?: number) => {
    const key = elementIndex !== undefined ? `${elementId}-${elementIndex}` : elementId;
    return animatingElements.has(key);
  }, [animatingElements]);

  return {
    // State
    shakeElement,
    popElement,
    animatingElements,
    isPlayingLoadAnimation,
    animatedElements,
    
    // Actions
    triggerShake,
    triggerPop,
    animateRemoval,
    playElementLoadAnimation,
    clearAllAnimations,
    
    // Helpers
    isElementAnimated,
    isElementRemoving
  };
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAnimations.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAudio.ts ===== 
'use client';

import { useRef, useEffect, useCallback } from 'react';

// Type for window.webkitAudioContext
interface WindowWithWebkit extends Window {
  webkitAudioContext?: typeof AudioContext;
}

export type SoundType = 'plop' | 'pop' | 'reward' | 'end-element' | 'press' | 'click' | 'reverse-pop';

/**
 * Hook for managing Web Audio API sound effects
 * Uses oscillator-based sounds for game interactions
 */
export const useGameAudio = () => {
  const audioContext = useRef<AudioContext | null>(null);

  // Initialize Web Audio API
  useEffect(() => {
    audioContext.current = new (window.AudioContext || (window as WindowWithWebkit).webkitAudioContext!)();
  }, []);

  const playSound = useCallback((type: SoundType) => {
    if (!audioContext.current) return;
    
    const osc = audioContext.current.createOscillator();
    const gainNode = audioContext.current.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioContext.current.destination);
    
    const now = audioContext.current.currentTime;
    
    switch(type) {
      case 'plop':
        // Element dropped into mixing area
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
        
      case 'pop':
        // Element interaction or mixing success
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
        gainNode.gain.setValueAtTime(0.4, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
        
      case 'reward':
        // Achievement or milestone reached
        osc.frequency.setValueAtTime(523.25, now);
        osc.frequency.setValueAtTime(659.25, now + 0.1);
        osc.frequency.setValueAtTime(783.99, now + 0.2);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
        break;
        
      case 'end-element':
        // Discovery of an end element (science mode)
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554.37, now + 0.15);
        osc.frequency.setValueAtTime(659.25, now + 0.3);
        gainNode.gain.setValueAtTime(0.35, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
        break;
        
      case 'press':
        // Element pressed down (drag start)
        osc.frequency.setValueAtTime(200, now);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
        
      case 'click':
        // Button clicks and UI interactions
        osc.frequency.setValueAtTime(1000, now);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
        osc.start(now);
        osc.stop(now + 0.03);
        break;
        
      case 'reverse-pop':
        // Undo operation
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);
        gainNode.gain.setValueAtTime(0.4, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
    }
  }, []);

  return {
    playSound
  };
};
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameAudio.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.test.ts ===== 
import { describe, it, expect } from 'vitest';
import { GameState, GameAction, Element, MixingElement } from './useGameState';

// Initial state factory (copied from the main file)
const createInitialState = (gameMode: 'science' | 'creative' = 'science'): GameState => {
  const baseElements = gameMode === 'creative' 
    ? [
        { id: 'life', name: 'Life', emoji: '🧬', color: '#32CD32', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: '🌍', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: '💨', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: '🔥', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: '💧', color: '#4682B4', unlockOrder: 4 },
      ]
    : [
        { id: 'energy', name: 'Energy', emoji: '〰️', color: '#FFD700', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: '🌍', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: '💨', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: '🔥', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: '💧', color: '#4682B4', unlockOrder: 4 },
      ];

  return {
    elements: baseElements,
    endElements: [],
    combinations: {},
    gameMode,
    mixingArea: [],
    achievements: [],
    failedCombinations: [],
    dimmedElements: new Set<string>(),
    animatingElements: new Set<string>(),
    isUndoing: false,
    lastCombination: null,
    undoAvailable: false,
    totalCombinationsMade: 0,
    isStateRestored: false,
  };
};

// Import the reducer function directly for testing
function gameStateReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'SET_GAME_MODE':
      return createInitialState(action.payload);

    case 'SET_ELEMENTS':
      return { ...state, elements: action.payload };

    case 'ADD_ELEMENT':
      return { 
        ...state, 
        elements: [...state.elements, action.payload] 
      };

    case 'SET_COMBINATIONS':
      return { ...state, combinations: action.payload };

    case 'ADD_COMBINATION':
      return { 
        ...state, 
        combinations: { 
          ...state.combinations, 
          [action.payload.key]: action.payload.result 
        } 
      };

    case 'SET_MIXING_AREA':
      return { ...state, mixingArea: action.payload };

    case 'ADD_TO_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: [...state.mixingArea, action.payload] 
      };

    case 'REMOVE_FROM_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: state.mixingArea.filter((el: MixingElement) => !action.payload.includes(el.index)) 
      };

    case 'UPDATE_MIXING_ELEMENT':
      return {
        ...state,
        mixingArea: state.mixingArea.map((el: MixingElement) => 
          el.index === action.payload.index 
            ? { ...el, ...action.payload.updates }
            : el
        )
      };

    case 'CLEAR_MIXING_AREA':
      return { ...state, mixingArea: [] };

    case 'SET_ACHIEVEMENTS':
      return { ...state, achievements: action.payload };

    case 'ADD_ACHIEVEMENTS':
      return { 
        ...state, 
        achievements: [...state.achievements, ...action.payload] 
      };

    case 'SET_FAILED_COMBINATIONS':
      return { ...state, failedCombinations: action.payload };

    case 'ADD_FAILED_COMBINATION':
      return { 
        ...state, 
        failedCombinations: [...state.failedCombinations.slice(-4), action.payload] 
      };

    case 'SET_LAST_COMBINATION':
      return { ...state, lastCombination: action.payload };

    case 'SET_UNDO_AVAILABLE':
      return { ...state, undoAvailable: action.payload };

    case 'INCREMENT_TOTAL_COMBINATIONS':
      return { ...state, totalCombinationsMade: state.totalCombinationsMade + 1 };

    case 'SET_STATE_RESTORED':
      return { ...state, isStateRestored: action.payload };

    case 'LOAD_SAVED_STATE':
      return { ...state, ...action.payload };

    case 'RESET_GAME_STATE':
      return createInitialState(action.payload.gameMode);

    default:
      return state;
  }
}

// Test data
const testElement: Element = {
  id: 'steam',
  name: 'Steam',
  emoji: '💨',
  color: '#E0E0E0',
  unlockOrder: 5
};

const testMixingElement: MixingElement = {
  ...testElement,
  x: 100,
  y: 100,
  index: 12345,
  energized: false
};

describe('Game State Reducer', () => {
  describe('ADD_ELEMENT', () => {
    it('should add a new element to the elements array', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_ELEMENT',
        payload: testElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.elements).toHaveLength(6); // 5 base + 1 new
      expect(result.elements).toContain(testElement);
      expect(result.elements[5]).toEqual(testElement);
    });

    it('should not modify other state properties', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_ELEMENT',
        payload: testElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.mixingArea).toEqual(initialState.mixingArea);
      expect(result.combinations).toEqual(initialState.combinations);
      expect(result.gameMode).toEqual(initialState.gameMode);
    });
  });

  describe('SET_GAME_MODE', () => {
    it('should switch from science to creative mode with correct base elements', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'SET_GAME_MODE',
        payload: 'creative'
      };

      const result = gameStateReducer(initialState, action);

      expect(result.gameMode).toBe('creative');
      expect(result.elements).toHaveLength(5);
      expect(result.elements[0].name).toBe('Life'); // Creative mode starts with Life
      expect(result.elements.find((e: Element) => e.name === 'Energy')).toBeUndefined(); // No Energy in creative
    });

    it('should reset all state when switching modes', () => {
      const stateWithProgress = {
        ...createInitialState('science'),
        elements: [...createInitialState('science').elements, testElement],
        mixingArea: [testMixingElement],
        combinations: { 'fire+water': 'steam' }
      };

      const action: GameAction = {
        type: 'SET_GAME_MODE',
        payload: 'creative'
      };

      const result = gameStateReducer(stateWithProgress, action);

      expect(result.elements).toHaveLength(5); // Back to base elements
      expect(result.mixingArea).toHaveLength(0); // Cleared
      expect(result.combinations).toEqual({}); // Cleared
    });
  });

  describe('ADD_TO_MIXING_AREA', () => {
    it('should add element to mixing area', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_TO_MIXING_AREA',
        payload: testMixingElement
      };

      const result = gameStateReducer(initialState, action);

      expect(result.mixingArea).toHaveLength(1);
      expect(result.mixingArea[0]).toEqual(testMixingElement);
    });

    it('should allow multiple elements in mixing area', () => {
      const initialState = createInitialState('science');
      
      const firstAdd = gameStateReducer(initialState, {
        type: 'ADD_TO_MIXING_AREA',
        payload: testMixingElement
      });

      const secondElement = { ...testMixingElement, id: 'water', index: 54321 };
      const secondAdd = gameStateReducer(firstAdd, {
        type: 'ADD_TO_MIXING_AREA',
        payload: secondElement
      });

      expect(secondAdd.mixingArea).toHaveLength(2);
      expect(secondAdd.mixingArea[1]).toEqual(secondElement);
    });
  });

  describe('CLEAR_MIXING_AREA', () => {
    it('should remove all elements from mixing area', () => {
      const stateWithMixing = {
        ...createInitialState('science'),
        mixingArea: [testMixingElement, { ...testMixingElement, index: 99999 }]
      };

      const action: GameAction = { type: 'CLEAR_MIXING_AREA' };
      const result = gameStateReducer(stateWithMixing, action);

      expect(result.mixingArea).toHaveLength(0);
      expect(result.mixingArea).toEqual([]);
    });
  });

  describe('ADD_COMBINATION', () => {
    it('should add successful combination to combinations record', () => {
      const initialState = createInitialState('science');
      const action: GameAction = {
        type: 'ADD_COMBINATION',
        payload: { key: 'fire+water', result: 'steam' }
      };

      const result = gameStateReducer(initialState, action);

      expect(result.combinations['fire+water']).toBe('steam');
      expect(Object.keys(result.combinations)).toHaveLength(1);
    });

    it('should preserve existing combinations when adding new ones', () => {
      const stateWithCombinations = {
        ...createInitialState('science'),
        combinations: { 'earth+water': 'mud' }
      };

      const action: GameAction = {
        type: 'ADD_COMBINATION',
        payload: { key: 'fire+water', result: 'steam' }
      };

      const result = gameStateReducer(stateWithCombinations, action);

      expect(result.combinations['earth+water']).toBe('mud');
      expect(result.combinations['fire+water']).toBe('steam');
      expect(Object.keys(result.combinations)).toHaveLength(2);
    });
  });

  describe('LOAD_SAVED_STATE', () => {
    it('should merge saved state with existing state', () => {
      const initialState = createInitialState('science');
      const savedElements = [
        ...initialState.elements,
        testElement
      ];

      const action: GameAction = {
        type: 'LOAD_SAVED_STATE',
        payload: {
          elements: savedElements,
          combinations: { 'fire+water': 'steam' }
        }
      };

      const result = gameStateReducer(initialState, action);

      expect(result.elements).toEqual(savedElements);
      expect(result.combinations['fire+water']).toBe('steam');
      expect(result.gameMode).toBe('science'); // Should preserve existing game mode
    });
  });

  describe('INCREMENT_TOTAL_COMBINATIONS', () => {
    it('should increment the total combinations counter', () => {
      const initialState = createInitialState('science');
      const action: GameAction = { type: 'INCREMENT_TOTAL_COMBINATIONS' };

      const result = gameStateReducer(initialState, action);

      expect(result.totalCombinationsMade).toBe(1);
      expect(initialState.totalCombinationsMade).toBe(0); // Original unchanged
    });

    it('should increment from existing count', () => {
      const stateWithCount = {
        ...createInitialState('science'),
        totalCombinationsMade: 5
      };

      const action: GameAction = { type: 'INCREMENT_TOTAL_COMBINATIONS' };
      const result = gameStateReducer(stateWithCount, action);

      expect(result.totalCombinationsMade).toBe(6);
    });
  });
});
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.test.ts ===== 
 
 
===== START: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.ts ===== 
import { useReducer, useCallback } from 'react';
import { GameElement, Achievement } from '@/types/game.types';

// Types for the internal game state (mirrors LLMAlchemy component state)
export type Element = GameElement;

export interface MixingElement extends Element {
  x: number;
  y: number;
  index: number;
  energized: boolean;
  fromMixingArea?: boolean;
  mixIndex?: number | null;
}

export interface LastCombination {
  createdElement: {
    element: Element;
    isEndElement: boolean;
  };
  combinationKey: string;
  mixingAreaState: MixingElement[];
  achievementsGained: Achievement[];
  endElementsGained: Element[];
  timestamp: number;
}

// Core game state (domain/persistent data only)
export interface GameState {
  // Core game data
  elements: Element[];
  endElements: Element[];
  combinations: Record<string, string | null>;
  gameMode: 'science' | 'creative';
  
  // Game logic state
  mixingArea: MixingElement[];
  achievements: Achievement[];
  failedCombinations: string[];
  
  // Enhanced state for UI restoration
  dimmedElements: Set<string>;
  animatingElements: Set<string>;
  isUndoing: boolean;
  
  // Undo/redo functionality
  lastCombination: LastCombination | null;
  undoAvailable: boolean;
  totalCombinationsMade: number;
  
  // State restoration tracking
  isStateRestored: boolean;
}

// Action types for the reducer
export type GameAction =
  | { type: 'SET_GAME_MODE'; payload: 'science' | 'creative' }
  | { type: 'SET_ELEMENTS'; payload: Element[] }
  | { type: 'ADD_ELEMENT'; payload: Element }
  | { type: 'SET_END_ELEMENTS'; payload: Element[] }
  | { type: 'ADD_END_ELEMENT'; payload: Element }
  | { type: 'SET_COMBINATIONS'; payload: Record<string, string | null> }
  | { type: 'ADD_COMBINATION'; payload: { key: string; result: string | null } }
  | { type: 'SET_MIXING_AREA'; payload: MixingElement[] }
  | { type: 'ADD_TO_MIXING_AREA'; payload: MixingElement }
  | { type: 'REMOVE_FROM_MIXING_AREA'; payload: number[] }
  | { type: 'UPDATE_MIXING_ELEMENT'; payload: { index: number; updates: Partial<MixingElement> } }
  | { type: 'CLEAR_MIXING_AREA' }
  | { type: 'SET_ACHIEVEMENTS'; payload: Achievement[] }
  | { type: 'ADD_ACHIEVEMENTS'; payload: Achievement[] }
  | { type: 'SET_FAILED_COMBINATIONS'; payload: string[] }
  | { type: 'ADD_FAILED_COMBINATION'; payload: string }
  | { type: 'SET_DIMMED_ELEMENTS'; payload: Set<string> }
  | { type: 'ADD_DIMMED_ELEMENT'; payload: string }
  | { type: 'REMOVE_DIMMED_ELEMENT'; payload: string }
  | { type: 'CLEAR_DIMMED_ELEMENTS' }
  | { type: 'SET_ANIMATING_ELEMENTS'; payload: Set<string> }
  | { type: 'ADD_ANIMATING_ELEMENT'; payload: string }
  | { type: 'REMOVE_ANIMATING_ELEMENT'; payload: string }
  | { type: 'CLEAR_ANIMATING_ELEMENTS' }
  | { type: 'SET_IS_UNDOING'; payload: boolean }
  | { type: 'SET_LAST_COMBINATION'; payload: LastCombination | null }
  | { type: 'SET_UNDO_AVAILABLE'; payload: boolean }
  | { type: 'INCREMENT_TOTAL_COMBINATIONS' }
  | { type: 'SET_STATE_RESTORED'; payload: boolean }
  | { type: 'LOAD_SAVED_STATE'; payload: Partial<GameState> }
  | { type: 'RESET_GAME_STATE'; payload: { gameMode: 'science' | 'creative' } };

// Initial state factory
const createInitialState = (gameMode: 'science' | 'creative' = 'science'): GameState => {
  const baseElements = gameMode === 'creative' 
    ? [
        { id: 'life', name: 'Life', emoji: '🧬', color: '#32CD32', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: '🌍', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: '💨', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: '🔥', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: '💧', color: '#4682B4', unlockOrder: 4 },
      ]
    : [
        { id: 'energy', name: 'Energy', emoji: '〰️', color: '#FFD700', unlockOrder: 0 },
        { id: 'earth', name: 'Earth', emoji: '🌍', color: '#8B4513', unlockOrder: 1 },
        { id: 'air', name: 'Air', emoji: '💨', color: '#87CEEB', unlockOrder: 2 },
        { id: 'fire', name: 'Fire', emoji: '🔥', color: '#FF4500', unlockOrder: 3 },
        { id: 'water', name: 'Water', emoji: '💧', color: '#4682B4', unlockOrder: 4 },
      ];

  return {
    elements: baseElements,
    endElements: [],
    combinations: {},
    gameMode,
    mixingArea: [],
    achievements: [],
    failedCombinations: [],
    dimmedElements: new Set<string>(),
    animatingElements: new Set<string>(),
    isUndoing: false,
    lastCombination: null,
    undoAvailable: false,
    totalCombinationsMade: 0,
    isStateRestored: false,
  };
};

// Game state reducer
function gameStateReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'SET_GAME_MODE':
      // When mode changes, reset to base elements for that mode
      return createInitialState(action.payload);

    case 'SET_ELEMENTS':
      return { ...state, elements: action.payload };

    case 'ADD_ELEMENT':
      return { 
        ...state, 
        elements: [...state.elements, action.payload] 
      };

    case 'SET_END_ELEMENTS':
      return { ...state, endElements: action.payload };

    case 'ADD_END_ELEMENT':
      return { 
        ...state, 
        endElements: [...state.endElements, action.payload] 
      };

    case 'SET_COMBINATIONS':
      return { ...state, combinations: action.payload };

    case 'ADD_COMBINATION':
      return { 
        ...state, 
        combinations: { 
          ...state.combinations, 
          [action.payload.key]: action.payload.result 
        } 
      };

    case 'SET_MIXING_AREA':
      return { ...state, mixingArea: action.payload };

    case 'ADD_TO_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: [...state.mixingArea, action.payload] 
      };

    case 'REMOVE_FROM_MIXING_AREA':
      return { 
        ...state, 
        mixingArea: state.mixingArea.filter(el => !action.payload.includes(el.index)) 
      };

    case 'UPDATE_MIXING_ELEMENT':
      return {
        ...state,
        mixingArea: state.mixingArea.map(el => 
          el.index === action.payload.index 
            ? { ...el, ...action.payload.updates }
            : el
        )
      };

    case 'CLEAR_MIXING_AREA':
      return { ...state, mixingArea: [] };

    case 'SET_ACHIEVEMENTS':
      return { ...state, achievements: action.payload };

    case 'ADD_ACHIEVEMENTS':
      return { 
        ...state, 
        achievements: [...state.achievements, ...action.payload] 
      };

    case 'SET_FAILED_COMBINATIONS':
      return { ...state, failedCombinations: action.payload };

    case 'ADD_FAILED_COMBINATION':
      return { 
        ...state, 
        failedCombinations: [...state.failedCombinations.slice(-4), action.payload] 
      };

    case 'SET_DIMMED_ELEMENTS':
      return { ...state, dimmedElements: action.payload };

    case 'ADD_DIMMED_ELEMENT':
      return { 
        ...state, 
        dimmedElements: new Set([...state.dimmedElements, action.payload])
      };

    case 'REMOVE_DIMMED_ELEMENT':
      const newDimmedElements = new Set(state.dimmedElements);
      newDimmedElements.delete(action.payload);
      return { ...state, dimmedElements: newDimmedElements };

    case 'CLEAR_DIMMED_ELEMENTS':
      return { ...state, dimmedElements: new Set<string>() };

    case 'SET_ANIMATING_ELEMENTS':
      return { ...state, animatingElements: action.payload };

    case 'ADD_ANIMATING_ELEMENT':
      return { 
        ...state, 
        animatingElements: new Set([...state.animatingElements, action.payload])
      };

    case 'REMOVE_ANIMATING_ELEMENT':
      const newAnimatingElements = new Set(state.animatingElements);
      newAnimatingElements.delete(action.payload);
      return { ...state, animatingElements: newAnimatingElements };

    case 'CLEAR_ANIMATING_ELEMENTS':
      return { ...state, animatingElements: new Set<string>() };

    case 'SET_IS_UNDOING':
      return { ...state, isUndoing: action.payload };

    case 'SET_LAST_COMBINATION':
      return { ...state, lastCombination: action.payload };

    case 'SET_UNDO_AVAILABLE':
      return { ...state, undoAvailable: action.payload };

    case 'INCREMENT_TOTAL_COMBINATIONS':
      return { ...state, totalCombinationsMade: state.totalCombinationsMade + 1 };

    case 'SET_STATE_RESTORED':
      return { ...state, isStateRestored: action.payload };

    case 'LOAD_SAVED_STATE':
      return { ...state, ...action.payload };

    case 'RESET_GAME_STATE':
      return createInitialState(action.payload.gameMode);

    default:
      return state;
  }
}

// Custom hook for game state management
export function useGameState(initialGameMode: 'science' | 'creative' = 'science') {
  const [state, dispatch] = useReducer(
    gameStateReducer,
    createInitialState(initialGameMode)
  );

  // Action creators for easier dispatch calls
  const actions = {
    setGameMode: useCallback((mode: 'science' | 'creative') => {
      dispatch({ type: 'SET_GAME_MODE', payload: mode });
    }, []),

    setElements: useCallback((elements: Element[]) => {
      dispatch({ type: 'SET_ELEMENTS', payload: elements });
    }, []),

    addElement: useCallback((element: Element) => {
      dispatch({ type: 'ADD_ELEMENT', payload: element });
    }, []),

    setEndElements: useCallback((endElements: Element[]) => {
      dispatch({ type: 'SET_END_ELEMENTS', payload: endElements });
    }, []),

    addEndElement: useCallback((element: Element) => {
      dispatch({ type: 'ADD_END_ELEMENT', payload: element });
    }, []),

    setCombinations: useCallback((combinations: Record<string, string | null>) => {
      dispatch({ type: 'SET_COMBINATIONS', payload: combinations });
    }, []),

    addCombination: useCallback((key: string, result: string | null) => {
      dispatch({ type: 'ADD_COMBINATION', payload: { key, result } });
    }, []),

    setMixingArea: useCallback((mixingArea: MixingElement[]) => {
      dispatch({ type: 'SET_MIXING_AREA', payload: mixingArea });
    }, []),

    addToMixingArea: useCallback((element: MixingElement) => {
      dispatch({ type: 'ADD_TO_MIXING_AREA', payload: element });
    }, []),

    removeFromMixingArea: useCallback((indices: number[]) => {
      dispatch({ type: 'REMOVE_FROM_MIXING_AREA', payload: indices });
    }, []),

    updateMixingElement: useCallback((index: number, updates: Partial<MixingElement>) => {
      dispatch({ type: 'UPDATE_MIXING_ELEMENT', payload: { index, updates } });
    }, []),

    clearMixingArea: useCallback(() => {
      dispatch({ type: 'CLEAR_MIXING_AREA' });
    }, []),

    setAchievements: useCallback((achievements: Achievement[]) => {
      dispatch({ type: 'SET_ACHIEVEMENTS', payload: achievements });
    }, []),

    addAchievements: useCallback((achievements: Achievement[]) => {
      dispatch({ type: 'ADD_ACHIEVEMENTS', payload: achievements });
    }, []),

    setFailedCombinations: useCallback((failedCombinations: string[]) => {
      dispatch({ type: 'SET_FAILED_COMBINATIONS', payload: failedCombinations });
    }, []),

    addFailedCombination: useCallback((combination: string) => {
      dispatch({ type: 'ADD_FAILED_COMBINATION', payload: combination });
    }, []),

    setDimmedElements: useCallback((dimmedElements: Set<string>) => {
      dispatch({ type: 'SET_DIMMED_ELEMENTS', payload: dimmedElements });
    }, []),

    addDimmedElement: useCallback((elementName: string) => {
      dispatch({ type: 'ADD_DIMMED_ELEMENT', payload: elementName });
    }, []),

    removeDimmedElement: useCallback((elementName: string) => {
      dispatch({ type: 'REMOVE_DIMMED_ELEMENT', payload: elementName });
    }, []),

    clearDimmedElements: useCallback(() => {
      dispatch({ type: 'CLEAR_DIMMED_ELEMENTS' });
    }, []),

    setAnimatingElements: useCallback((animatingElements: Set<string>) => {
      dispatch({ type: 'SET_ANIMATING_ELEMENTS', payload: animatingElements });
    }, []),

    addAnimatingElement: useCallback((elementName: string) => {
      dispatch({ type: 'ADD_ANIMATING_ELEMENT', payload: elementName });
    }, []),

    removeAnimatingElement: useCallback((elementName: string) => {
      dispatch({ type: 'REMOVE_ANIMATING_ELEMENT', payload: elementName });
    }, []),

    clearAnimatingElements: useCallback(() => {
      dispatch({ type: 'CLEAR_ANIMATING_ELEMENTS' });
    }, []),

    setIsUndoing: useCallback((isUndoing: boolean) => {
      dispatch({ type: 'SET_IS_UNDOING', payload: isUndoing });
    }, []),

    setLastCombination: useCallback((combination: LastCombination | null) => {
      dispatch({ type: 'SET_LAST_COMBINATION', payload: combination });
    }, []),

    setUndoAvailable: useCallback((available: boolean) => {
      dispatch({ type: 'SET_UNDO_AVAILABLE', payload: available });
    }, []),

    incrementTotalCombinations: useCallback(() => {
      dispatch({ type: 'INCREMENT_TOTAL_COMBINATIONS' });
    }, []),

    setStateRestored: useCallback((restored: boolean) => {
      dispatch({ type: 'SET_STATE_RESTORED', payload: restored });
    }, []),

    loadSavedState: useCallback((savedState: Partial<GameState>) => {
      dispatch({ type: 'LOAD_SAVED_STATE', payload: savedState });
    }, []),

    resetGameState: useCallback((gameMode: 'science' | 'creative') => {
      dispatch({ type: 'RESET_GAME_STATE', payload: { gameMode } });
    }, []),
  };

  return {
    state,
    dispatch,
    actions,
  };
}
 
===== END: C:\AI\LLM-Alchemy\src\components\game\LLMAlchemy\hooks\useGameState.ts ===== 
 
 
