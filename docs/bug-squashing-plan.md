# LLM Alchemy - Bug Squashing & Refinement Plan (v6)

## 0. Getting Started for New Developers

### What is LLM Alchemy?
LLM Alchemy is a web-based alchemy game where players combine elements to discover new ones. Combinations are dynamically generated by an LLM (Google Gemini via OpenRouter), creating unique gameplay experiences.

**Live Game**: https://llm-alchemy-beta2.vercel.app  
**GitHub**: https://github.com/Farsinuce/LLM-Alchemy

### Tech Stack
- **Frontend**: Next.js 15, React, TypeScript, Tailwind CSS v4
- **Backend**: Next.js API Routes on Vercel Edge Functions
- **Database**: Supabase (PostgreSQL)
- **Deployment**: Vercel (auto-deploys from GitHub)
- **Testing**: Vitest (unit) + GitHub Actions (E2E)

### Development Workflow
- **Commit and push**: `git add . && git commit -m "Fix: [bug description]" && git push`
- **Test on live site**: Vercel auto-deploys within ~1 minute to https://llm-alchemy-beta2.vercel.app
- **Usually don't Run tests locally**: `npm run test` (optional, as GitHub Actions will also run them)

**Important**: We do NOT build locally. All testing happens on the live Vercel deployment.

### Key Files for Bug Fixes
- **Main game component**: `src/components/game/LLMAlchemy/LLMAlchemyRefactored.tsx`
- **State management**: `src/components/game/LLMAlchemy/contexts/GameStateProvider.tsx`
- **Animation logic**: `src/components/game/LLMAlchemy/hooks/useGameAnimations.ts`
- **Animation styles**: `src/styles/animations.css`

---

## 1. Overview

This document outlines a refined, developer-centric plan to address three critical user-facing bugs. It incorporates a deep analysis of the codebase to identify the true root causes and proposes robust, long-term solutions.

---

## 2. Active Bug Fixes

### 2.1. Bug A: Save/Load State Fails

-   **Status**: **CRITICAL** 
-   **Priority**: **Highest**
-   **The Problem**: Games cannot save or load state. Browser console shows `Could not find the 'state_version' column of 'game_states' in the schema cache` error and HTTP 400 responses when trying to save.
-   **The Root Cause**: Commit 86c5b19 introduced a `state_version` field for future compatibility, but this column doesn't exist in the database schema. The database rejects upsert operations containing unknown fields.
-   **The Solution**: Remove the `state_version` field from save operations. Any future database versioning needs to be done via proper database migrations, not by adding fields in application code.
-   **Recent Action**: Rolled back the problematic versioning logic while keeping the `game_mode` validation.

### 2.2. Bug 2: Desktop Repositioning Fails

-   **Status**: **CRITICAL**
-   **Priority**: **High**
-   **The Problem**: On desktop, once an element is placed in the mixing area, it cannot be dragged again. The `onDrop` event that should handle repositioning never works correctly because the reference to the dragged element is cleared prematurely.
-   **The Root Cause**: A race condition exists between two event handlers in `LLMAlchemyRefactored.tsx`. The `onDragEnd` event on the draggable element fires *before* the `onDrop` event on the mixing area. This `onDragEnd` handler immediately sets `draggedElement.current = null`, so by the time `onDrop` executes, it has no element to work with and aborts. This explains why it fails on desktop (which uses HTML5 drag-and-drop) but works on mobile (which uses a separate `onTouch...` event system).
-   **The Solution**: Centralize all drag state cleanup within the `onDrop` handler of the mixing area. The `onDragEnd` handler on the individual elements will be removed to prevent it from clearing the state too early. This ensures that the `onDrop` handler always has the necessary information to correctly identify the element and its origin, allowing it to reliably reposition it.

### 2.3. Bug X: "Clear" Animation is Incorrect

-   **Status**: **BUGGED**
-   **Priority**: **Medium**
-   **The Problem**: When the "Clear" button is pressed, elements in the mixing area fade out incorrectly (opacity goes from 0% to 100% instead of 100% to 0%) and do not perform the required zoom animation (`100% -> 110% -> 0%`).
-   **The Root Cause**: This is a two-part issue:
    1.  **Incorrect CSS**: The `@keyframes clear-zoom-fade` in `src/styles/animations.css` has the wrong values. It animates opacity to `0.5` midway through instead of holding it at `1` before fading out.
    2.  **Conflicting Inline Styles**: The mixing area elements in `LLMAlchemyRefactored.tsx` have an inline style of `transition: 'none'`. This CSS rule has higher specificity and overrides the `animate-clear-zoom-fade` class, preventing the keyframe animation from executing.
-   **The Solution**:
    1.  First, I will correct the `@keyframes` in `animations.css` to match the specified animation curve: `transform: scale(1) -> scale(1.1) -> scale(0)` and `opacity: 1 -> 1 -> 0`.
    2.  Second, I will update the `animateRemoval` function in `useGameAnimations.ts`. This function will be modified to temporarily remove the conflicting `transition: 'none'` style from the elements during the animation, allowing the corrected keyframes to apply properly.

## 3. Recently Fixed Bugs

### 3.1. Bug D: Floating Emoji Background ✅ FIXED

-   **Status**: **FIXED** (as of recent commits)
-   **The Problem**: The background animation was inefficient, causing performance issues ("lagging blobs"). It also failed to meet the visual requirements: large, semi-transparent emojis that drift across the screen.
-   **The Solution Applied**: Complete rewrite using dedicated `FloatingEmojiBackground.tsx` component with pure CSS animations. The new implementation uses hardware-accelerated CSS `@keyframe` animations and efficient spawning logic with `onAnimationEnd` events.

---

## 4. 🐛 Openmoji emoji selection bug:

**"Coal" → Openmoji "Collaboration" Bug**
- **Problem**: Element "Coal" matched to "collaboration" emoji (completely wrong)
- **Cause**: Fuzzy search matching too broadly on partial strings ("co" prefix)
- **Impact**: Nonsensical emoji assignments that break immersion
- **Example**: User creates "Coal", expects ⚫ or 🪨, gets 🤝 collaboration emoji

**Proposed Solution**:
Solution A:
- Add minimum quality threshold to fuzzy search (e.g., reject if score > 0.5)
- When fuzzy match is too poor, use LLM's Unicode emoji in OpenMoji style
- Preserves visual consistency while avoiding absurd matches

Solution B (my favourite):
- Utilise the LLM better! Make the LLM output a confidence score to how well it thinks its assigned unicode LLM matches the discovered element title.
- Good score: If the discovered element is an apple, and the LLM suggest "🍎" (an apple), that's a high confidence score (maybe 1.0)
- Poor score: If the discovered element is a "Narwhal", but the LLM only can suggest "🐋" (it KNOWS it's a whale, and not quite accurate), then the LLM might output a low 0.5 confidence score.
- Good score: If the discovered element is "glass" (not as in "a drinking glass", mind you, but as in the material), the LLM might be clever and suggest "🪟" (window emoji), which is actually a BETTER choice than a "(drinking) glass" emoji, so its confidence score would be high. In these cases, we don't want our fuse search to overrule. We just want the openmoji version of the window emoji.

### L. OpenMoji "Coal" Fuzzy Search Bug

- **Problem**: Fuzzy search produces poor matches (Coal → Collaboration).
- **Technical Plan** (LLM Confidence Score approach):
    1. Update `llm-prompts.ts` to include `"emojiConfidence": 0.0-1.0` in the response schema.
    2. Update `/api/generate/route.ts` to parse this field.
    3. In `openmoji-service.ts`:
        - Accept `confidenceScore` parameter.
        - If score > 0.8, bypass fuzzy search and use LLM's Unicode directly.
        - If score ≤ 0.8, use existing fuzzy search for better match.
