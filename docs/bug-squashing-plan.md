# LLM Alchemy - Bug Squashing & Refinement Plan (v6)

## 0. Getting Started for New Developers

### What is LLM Alchemy?
LLM Alchemy is a web-based alchemy game where players combine elements to discover new ones. Combinations are dynamically generated by an LLM (Google Gemini via OpenRouter), creating unique gameplay experiences.

**Live Game**: https://llm-alchemy-beta2.vercel.app  
**GitHub**: https://github.com/Farsinuce/LLM-Alchemy

### Tech Stack
- **Frontend**: Next.js 15, React, TypeScript, Tailwind CSS v4
- **Backend**: Next.js API Routes on Vercel Edge Functions
- **Database**: Supabase (PostgreSQL)
- **Deployment**: Vercel (auto-deploys from GitHub)
- **Testing**: Vitest (unit) + GitHub Actions (E2E)

### Development Workflow
- **Commit and push**: `git add . && git commit -m "Fix: [bug description]" && git push`
- **Test on live site**: Vercel auto-deploys within ~1 minute to https://llm-alchemy-beta2.vercel.app
- **Usually don't Run tests locally**: `npm run test` (optional, as GitHub Actions will also run them)

**Important**: We do NOT build locally. All testing happens on the live Vercel deployment.

### Key Files for Bug Fixes
- **Main game component**: `src/components/game/LLMAlchemy/LLMAlchemyRefactored.tsx`
- **State management**: `src/components/game/LLMAlchemy/contexts/GameStateProvider.tsx`
- **Animation logic**: `src/components/game/LLMAlchemy/hooks/useGameAnimations.ts`
- **Animation styles**: `src/styles/animations.css`

---

## 1. Overview

This document outlines a refined, developer-centric plan to address three critical user-facing bugs. It incorporates a deep analysis of the codebase to identify the true root causes and proposes robust, long-term solutions.

---

## 2. Priority Bug Fixes

### 2.1. Bug 2: Desktop Repositioning Fails

-   **Status**: **CRITICAL**
-   **Priority**: **Highest**
-   **The Problem**: On desktop, once an element is placed in the mixing area, it cannot be dragged again. The `onDrop` event that should handle repositioning never works correctly because the reference to the dragged element is cleared prematurely.
-   **The Root Cause**: A race condition exists between two event handlers in `LLMAlchemyRefactored.tsx`. The `onDragEnd` event on the draggable element fires *before* the `onDrop` event on the mixing area. This `onDragEnd` handler immediately sets `draggedElement.current = null`, so by the time `onDrop` executes, it has no element to work with and aborts. This explains why it fails on desktop (which uses HTML5 drag-and-drop) but works on mobile (which uses a separate `onTouch...` event system).
-   **The Solution**: Centralize all drag state cleanup within the `onDrop` handler of the mixing area. The `onDragEnd` handler on the individual elements will be removed to prevent it from clearing the state too early. This ensures that the `onDrop` handler always has the necessary information to correctly identify the element and its origin, allowing it to reliably reposition it.

### 2.2. Bug X: "Clear" Animation is Incorrect

-   **Status**: **BUGGED**
-   **Priority**: **Medium**
-   **The Problem**: When the "Clear" button is pressed, elements in the mixing area fade out incorrectly (opacity goes from 0% to 100% instead of 100% to 0%) and do not perform the required zoom animation (`100% -> 110% -> 0%`).
-   **The Root Cause**: This is a two-part issue:
    1.  **Incorrect CSS**: The `@keyframes clear-zoom-fade` in `src/styles/animations.css` has the wrong values. It animates opacity to `0.5` midway through instead of holding it at `1` before fading out.
    2.  **Conflicting Inline Styles**: The mixing area elements in `LLMAlchemyRefactored.tsx` have an inline style of `transition: 'none'`. This CSS rule has higher specificity and overrides the `animate-clear-zoom-fade` class, preventing the keyframe animation from executing.
-   **The Solution**:
    1.  First, I will correct the `@keyframes` in `animations.css` to match the specified animation curve: `transform: scale(1) -> scale(1.1) -> scale(0)` and `opacity: 1 -> 1 -> 0`.
    2.  Second, I will update the `animateRemoval` function in `useGameAnimations.ts`. This function will be modified to temporarily remove the conflicting `transition: 'none'` style from the elements during the animation, allowing the corrected keyframes to apply properly.

### 2.3. Bug D: Floating Emoji Background is Laggy and Incorrect

-   **Status**: **BUGGED**
-   **Priority**: **Medium**
-   **The Problem**: The current background animation is inefficient, causing performance issues ("lagging blobs"). It also fails to meet the visual requirements: large, semi-transparent emojis that drift across the screen.
-   **The Root Cause**: The implementation in `LLMAlchemyRefactored.tsx` uses a JavaScript `setInterval` to manually update the position and opacity of standard-sized emojis every 100ms. This is highly inefficient, causing constant re-renders of the main game component and leading to poor performance.
-   **The Solution**: A complete rewrite using a dedicated component and CSS animations.
    1.  **Create `FloatingEmojiBackground.tsx`**: I will create a new, self-contained component to handle the entire background animation logic. This isolates its re-renders from the main game state.
    2.  **Use Pure CSS Animations**: The component will generate elements that use a hardware-accelerated CSS `@keyframe` animation for the entire lifecycle (fade-in, drift, fade-out). This is far more performant than JavaScript-driven animation.
    3.  **Efficient Spawning Logic**: The component will use a combination of a low-frequency `setInterval` (e.g., every 2 seconds) to decide *if* a new emoji should spawn, and the `onAnimationEnd` browser event to know *when* an emoji has finished its animation and can be removed from the DOM. This guarantees a maximum of 3 emojis on screen without constant checks.
    4.  **Correct Visuals**: The emojis will be rendered at `transform: scale(10)` and `opacity: 0.1` to achieve the large, subtle background effect, and will correctly source from the list of discovered elements.

---

## 3. üêõ Openmoji emoji selection bug:

**"Coal" ‚Üí Openmoji "Collaboration" Bug**
- **Problem**: Element "Coal" matched to "collaboration" emoji (completely wrong)
- **Cause**: Fuzzy search matching too broadly on partial strings ("co" prefix)
- **Impact**: Nonsensical emoji assignments that break immersion
- **Example**: User creates "Coal", expects ‚ö´ or ü™®, gets ü§ù collaboration emoji

**Proposed Solution**:
Solution A:
- Add minimum quality threshold to fuzzy search (e.g., reject if score > 0.5)
- When fuzzy match is too poor, use LLM's Unicode emoji in OpenMoji style
- Preserves visual consistency while avoiding absurd matches

Solution B (my favourite):
- Utilise the LLM better! Make the LLM output a confidence score to how well it thinks its assigned unicode LLM matches the discovered element title.
- Good score: If the discovered element is an apple, and the LLM suggest "üçé" (an apple), that's a high confidence score (maybe 1.0)
- Poor score: If the discovered element is a "Narwhal", but the LLM only can suggest "üêã" (it KNOWS it's a whale, and not quite accurate), then the LLM might output a low 0.5 confidence score.
- Good score: If the discovered element is "glass" (not as in "a drinking glass", mind you, but as in the material), the LLM might be clever and suggest "ü™ü" (window emoji), which is actually a BETTER choice than a "(drinking) glass" emoji, so its confidence score would be high. In these cases, we don't want our fuse search to overrule. We just want the openmoji version of the window emoji.