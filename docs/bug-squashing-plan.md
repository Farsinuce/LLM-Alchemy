# LLM Alchemy - Bug Squashing & Refinement Plan (v6)

## 0. Getting Started for New Developers

### What is LLM Alchemy?
LLM Alchemy is a web-based alchemy game where players combine elements to discover new ones. Combinations are dynamically generated by an LLM (Google Gemini via OpenRouter), creating unique gameplay experiences.

**Live Game**: https://llm-alchemy-beta2.vercel.app  
**GitHub**: https://github.com/Farsinuce/LLM-Alchemy

### Tech Stack
- **Frontend**: Next.js 15, React, TypeScript, Tailwind CSS v4
- **Backend**: Next.js API Routes on Vercel Edge Functions
- **Database**: Supabase (PostgreSQL)
- **Deployment**: Vercel (auto-deploys from GitHub)
- **Testing**: Vitest (unit) + GitHub Actions (E2E)

### Development Workflow
- **Commit and push**: `git add . && git commit -m "Fix: [bug description]" && git push`
- **Test on live site**: Vercel auto-deploys within ~1 minute to https://llm-alchemy-beta2.vercel.app
- **Usually don't Run tests locally**: `npm run test` (optional, as GitHub Actions will also run them)

**Important**: We do NOT build locally. All testing happens on the live Vercel deployment.

### Key Files for Bug Fixes
- **Main game component**: `src/components/game/LLMAlchemy/LLMAlchemyRefactored.tsx`
- **State management**: `src/components/game/LLMAlchemy/contexts/GameStateProvider.tsx`
- **Animation logic**: `src/components/game/LLMAlchemy/hooks/useGameAnimations.ts`
- **Animation styles**: `src/styles/animations.css`

---

## 1. Overview

This document outlines a refined, developer-centric plan to address three critical user-facing bugs. It incorporates a deep analysis of the codebase to identify the true root causes and proposes robust, long-term solutions.

---

## 2. Active Bug Fixes

### 2.1. Bug A: Save/Load State Fails

-   **Status**: **CRITICAL** 
-   **Priority**: **Highest**
-   **The Problem**: Games cannot save or load state. Browser console shows `Could not find the 'state_version' column of 'game_states' in the schema cache` error and HTTP 400 responses when trying to save.
-   **The Root Cause**: Commit 86c5b19 introduced a `state_version` field for future compatibility, but this column doesn't exist in the database schema. The database rejects upsert operations containing unknown fields.
-   **The Solution**: Remove the `state_version` field from save operations. Any future database versioning needs to be done via proper database migrations, not by adding fields in application code.
-   **Recent Action**: Rolled back the problematic versioning logic while keeping the `game_mode` validation.

### 2.2. Bug 2: Desktop Repositioning Fails

-   **Status**: **CRITICAL**
-   **Priority**: **High**
-   **The Problem**: On desktop, once an element is placed in the mixing area, it cannot be dragged again. The `onDrop` event that should handle repositioning never works correctly because the reference to the dragged element is cleared prematurely.
-   **The Root Cause**: A race condition exists between two event handlers in `LLMAlchemyRefactored.tsx`. The `onDragEnd` event on the draggable element fires *before* the `onDrop` event on the mixing area. This `onDragEnd` handler immediately sets `draggedElement.current = null`, so by the time `onDrop` executes, it has no element to work with and aborts. This explains why it fails on desktop (which uses HTML5 drag-and-drop) but works on mobile (which uses a separate `onTouch...` event system).
-   **The Solution**: Centralize all drag state cleanup within the `onDrop` handler of the mixing area. The `onDragEnd` handler on the individual elements will be removed to prevent it from clearing the state too early. This ensures that the `onDrop` handler always has the necessary information to correctly identify the element and its origin, allowing it to reliably reposition it.

### 2.3. Bug X: "Clear" Animation is Incorrect

-   **Status**: **BUGGED**
-   **Priority**: **Medium**
-   **The Problem**: When the "Clear" button is pressed, elements in the mixing area fade out incorrectly (opacity goes from 0% to 100% instead of 100% to 0%) and do not perform the required zoom animation (`100% -> 110% -> 0%`).
-   **The Root Cause**: This is a two-part issue:
    1.  **Incorrect CSS**: The `@keyframes clear-zoom-fade` in `src/styles/animations.css` has the wrong values. It animates opacity to `0.5` midway through instead of holding it at `1` before fading out.
    2.  **Conflicting Inline Styles**: The mixing area elements in `LLMAlchemyRefactored.tsx` have an inline style of `transition: 'none'`. This CSS rule has higher specificity and overrides the `animate-clear-zoom-fade` class, preventing the keyframe animation from executing.
-   **The Solution**:
    1.  First, I will correct the `@keyframes` in `animations.css` to match the specified animation curve: `transform: scale(1) -> scale(1.1) -> scale(0)` and `opacity: 1 -> 1 -> 0`.
    2.  Second, I will update the `animateRemoval` function in `useGameAnimations.ts`. This function will be modified to temporarily remove the conflicting `transition: 'none'` style from the elements during the animation, allowing the corrected keyframes to apply properly.

## 3. Recently Fixed Bugs

### 3.1. Bug D: Floating Emoji Background âœ… FIXED

-   **Status**: **FIXED** (as of recent commits)
-   **The Problem**: The background animation was inefficient, causing performance issues ("lagging blobs"). It also failed to meet the visual requirements: large, semi-transparent emojis that drift across the screen.
-   **The Solution Applied**: Complete rewrite using dedicated `FloatingEmojiBackground.tsx` component with pure CSS animations. The new implementation uses hardware-accelerated CSS `@keyframe` animations and efficient spawning logic with `onAnimationEnd` events.

---

## 4. ðŸ› Openmoji emoji selection bug:

**"Coal" â†’ Openmoji "Collaboration" Bug**
- **Problem**: Element "Coal" matched to "collaboration" emoji (completely wrong)
- **Cause**: Fuzzy search matching too broadly on partial strings ("co" prefix)
- **Impact**: Nonsensical emoji assignments that break immersion
- **Example**: User creates "Coal", expects âš« or ðŸª¨, gets ðŸ¤ collaboration emoji

**Proposed Solution**:
Solution A:
- Add minimum quality threshold to fuzzy search (e.g., reject if score > 0.5)
- When fuzzy match is too poor, use LLM's Unicode emoji in OpenMoji style
- Preserves visual consistency while avoiding absurd matches

Solution B (my favourite):
- Utilise the LLM better! Make the LLM output a confidence score to how well it thinks its assigned unicode LLM matches the discovered element title.
- Good score: If the discovered element is an apple, and the LLM suggest "ðŸŽ" (an apple), that's a high confidence score (maybe 1.0)
- Poor score: If the discovered element is a "Narwhal", but the LLM only can suggest "ðŸ‹" (it KNOWS it's a whale, and not quite accurate), then the LLM might output a low 0.5 confidence score.
- Good score: If the discovered element is "glass" (not as in "a drinking glass", mind you, but as in the material), the LLM might be clever and suggest "ðŸªŸ" (window emoji), which is actually a BETTER choice than a "(drinking) glass" emoji, so its confidence score would be high. In these cases, we don't want our fuse search to overrule. We just want the openmoji version of the window emoji.

### L. OpenMoji "Coal" Fuzzy Search Bug

- **Problem**: Fuzzy search produces poor matches (Coal â†’ Collaboration).
- **Technical Plan** (LLM Confidence Score approach):
    1. Update `llm-prompts.ts` to include `"emojiConfidence": 0.0-1.0` in the response schema.
    2. Update `/api/generate/route.ts` to parse this field.
    3. In `openmoji-service.ts`:
        - Accept `confidenceScore` parameter.
        - If score > 0.8, bypass fuzzy search and use LLM's Unicode directly.
        - If score â‰¤ 0.8, use existing fuzzy search for better match.
