# LLM Alchemy - Bug Squashing & Refinement Plan (v6)

## 0. Getting Started for New Developers

### What is LLM Alchemy?
LLM Alchemy is a web-based alchemy game where players combine elements to discover new ones. Combinations are dynamically generated by an LLM (Google Gemini via OpenRouter), creating unique gameplay experiences.

**Live Game**: https://llm-alchemy-beta2.vercel.app  
**GitHub**: https://github.com/Farsinuce/LLM-Alchemy

### Tech Stack
- **Frontend**: Next.js 15, React, TypeScript, Tailwind CSS v4
- **Backend**: Next.js API Routes on Vercel Edge Functions
- **Database**: Supabase (PostgreSQL)
- **Deployment**: Vercel (auto-deploys from GitHub)
- **Testing**: Vitest (unit) + GitHub Actions (E2E)

### Development Workflow
- **Commit and push**: `git add . && git commit -m "Fix: [bug description]" && git push`
- **Test on live site**: Vercel auto-deploys within ~1 minute to https://llm-alchemy-beta2.vercel.app
- **Usually don't Run tests locally**: `npm run test` (optional, as GitHub Actions will also run them)

**Important**: We do NOT build locally. All testing happens on the live Vercel deployment.

### Key Files for Bug Fixes
- **Main game component**: `src/components/game/LLMAlchemy/LLMAlchemyRefactored.tsx`
- **State management**: `src/components/game/LLMAlchemy/contexts/GameStateProvider.tsx`
- **Animation logic**: `src/components/game/LLMAlchemy/hooks/useGameAnimations.ts`
- **Animation styles**: `src/styles/animations.css`

---

## 1. Overview

This document outlines a refined, developer-centric plan to address three critical user-facing bugs. It incorporates a deep analysis of the codebase to identify the true root causes and proposes robust, long-term solutions.

---

## 2. Active Bug Fixes

### 2.1. Bug 2: Desktop Repositioning Fails

-   **Status**: **CRITICAL**
-   **Priority**: **High**
-   **The Problem**: On desktop, once an element is placed in the mixing area, it cannot be dragged again. The `onDrop` event that should handle repositioning never works correctly because the reference to the dragged element is cleared prematurely.
-   **The Root Cause**: A race condition exists between two event handlers in `LLMAlchemyRefactored.tsx`. The `onDragEnd` event on the draggable element fires *before* the `onDrop` event on the mixing area. This `onDragEnd` handler immediately sets `draggedElement.current = null`, so by the time `onDrop` executes, it has no element to work with and aborts. This explains why it fails on desktop (which uses HTML5 drag-and-drop) but works on mobile (which uses a separate `onTouch...` event system).
-   **The Solution**: Centralize all drag state cleanup within the `onDrop` handler of the mixing area. The `onDragEnd` handler on the individual elements will be removed to prevent it from clearing the state too early. This ensures that the `onDrop` handler always has the necessary information to correctly identify the element and its origin, allowing it to reliably reposition it.

### 2.3. Bug X: "Clear" Animation is Incorrect

-   **Status**: **BUGGED**
-   **Priority**: **Medium**
-   **The Problem**: When the "Clear" button is pressed, elements in the mixing area fade out incorrectly (opacity goes from 0% to 100% instead of 100% to 0%) and do not perform the required zoom animation (`100% -> 110% -> 0%`).
-   **The Root Cause**: This is a two-part issue:
    1.  **Incorrect CSS**: The `@keyframes clear-zoom-fade` in `src/styles/animations.css` has the wrong values. It animates opacity to `0.5` midway through instead of holding it at `1` before fading out.
    2.  **Conflicting Inline Styles**: The mixing area elements in `LLMAlchemyRefactored.tsx` have an inline style of `transition: 'none'`. This CSS rule has higher specificity and overrides the `animate-clear-zoom-fade` class, preventing the keyframe animation from executing.
-   **The Solution**:
    1.  First, I will correct the `@keyframes` in `animations.css` to match the specified animation curve: `transform: scale(1) -> scale(1.1) -> scale(0)` and `opacity: 1 -> 1 -> 0`.
    2.  Second, I will update the `animateRemoval` function in `useGameAnimations.ts`. This function will be modified to temporarily remove the conflicting `transition: 'none'` style from the elements during the animation, allowing the corrected keyframes to apply properly.

## 3. Recently Fixed Bugs

### 3.1. Bug A: Save/Load State ‚úÖ FIXED

-   **Status**: **FIXED** (as of recent commits)
-   **The Problem**: Games could not save or load state. Browser console showed `Could not find the 'state_version' column of 'game_states' in the schema cache` error and HTTP 400 responses when trying to save.
-   **The Root Cause**: Commit 86c5b19 introduced a `state_version` field for future compatibility, but this column didn't exist in the database schema.
-   **The Solution Applied**: Removed the problematic `state_version` field from save operations while keeping the `game_mode` validation for proper conflict resolution.

### 3.2. Bug D: Floating Emoji Background ‚úÖ FIXED

-   **Status**: **FIXED** (as of recent commits)
-   **The Problem**: The background animation was inefficient, causing performance issues ("lagging blobs"). It also failed to meet the visual requirements: large, semi-transparent emojis that drift across the screen. Additionally, emojis would stop moving during their fade-out phase.
-   **The Solution Applied**: Complete rewrite using dedicated `FloatingEmojiBackground.tsx` component with pure CSS animations. Fixed fade-out animation to continue movement while fading (extending travel distance by 20% in final keyframe). The new implementation uses hardware-accelerated CSS `@keyframe` animations and efficient spawning logic with `onAnimationEnd` events.

---

## 4. üêõ OpenMoji Emoji Selection Bug (CRITICAL)

### 4.1. The Problem

**What happens**: Element "Coal" gets matched to "collaboration" emoji ü§ù instead of ‚ö´ or ü™®
**Why it's bad**: Completely nonsensical emoji assignments break game immersion
**Root cause**: Fuzzy search in `openmoji-service.ts` is too aggressive with partial string matching

### 4.2. Technical Root Cause Analysis

The current emoji resolution system has three issues:

1. **Prefix collisions**: Fuzzy search threshold of 0.32 allows "co*" to match "collaboration" for "coal"
2. **Wasted LLM data**: The LLM already outputs `emojiTags` (visual descriptors) but we ignore them completely
3. **Poor PUA prioritization**: OpenMoji's extra emoji catalogue (narwhal, oil-spill, etc.) gets overridden by weak fuzzy matches

**Current flow**:
```
LLM suggests: "coal" ‚Üí ü™® (with emojiTags: ["coal", "black", "rock"])
‚Üí openmoji-service.ts ignores emojiTags
‚Üí Fuzzy search matches "co*" prefix
‚Üí Returns ü§ù "collaboration" (score 0.25 < threshold 0.35)
```

### 4.3. The Solution: Multi-Stage Guard + LLM Confidence

**Why this approach**: Leverages existing data (emojiTags) + adds LLM intelligence (confidence) without over-engineering.

**Key insight**: The LLM already provides two valuable signals we're not using:
- `emojiTags`: Visual descriptors for better fuzzy matching
- `emojiConfidence`: How sure the LLM is about its Unicode choice

### 4.4. Implementation Plan

#### Step 1: Update LLM Prompts (`src/lib/llm-prompts.ts`)
Add `emojiConfidence` field to the response schema:

```typescript
// In both buildSciencePrompt and buildCreativePrompt, update the JSON schema:
{
  "outcomes": [
    {
      "result": "Element Name",
      "emoji": "one appropriate Unicode emoji",
      "emojiConfidence": {"type":"number","minimum":0,"maximum":1}, // ADD THIS
      "color": "hex color",
      // ... rest of fields
    }
  ]
}
```

**Why**: Allows LLM to express confidence in its emoji choice (0.0 = unsure, 1.0 = perfect match).

#### Step 2: Parse Confidence in API (`src/app/api/generate/route.ts`)
Update the generate endpoint to extract and pass the confidence score:

```typescript
// In the response parsing section, extract:
const emojiConfidence = outcome.emojiConfidence ?? 0.5; // Default if missing

// Pass to resolveEmoji:
resolveEmoji({
  unicodeEmoji: outcome.emoji,
  name: outcome.result,
  tags: outcome.emojiTags || [],
  confidence: emojiConfidence
});
```

**Why**: Forwards LLM's confidence assessment to the emoji resolver.

#### Step 3: Implement Multi-Stage Guard (`src/lib/openmoji-service.ts`)

Replace the current simple decision logic with a smart multi-stage guard:

```typescript
function choose(direct, best, llmScore, name, tags) {
  // 1. Always prefer exact PUA matches with token overlap
  if (best?.item.hexcode.startsWith('E') && tokenOverlap(name, best)) {
    return best; // Keep valuable narwhal, oil-spill emojis
  }
  
  // 2. Trust LLM when confidence is high AND Unicode exists in OpenMoji
  if (llmScore >= 0.85 && direct) {
    return direct; // Respect "glass" ‚Üí ü™ü window choice
  }
  
  // 3. Use fuzzy search only with meaningful word overlap
  if (!direct || (best && best.score < 0.15 && tokenOverlap(name, best))) {
    return best; // Prevents "coal" ‚Üí "collaboration"
  }
  
  // 4. Fallback to LLM's choice
  return direct ?? fallback;
}

function tokenOverlap(elementName, fuseResult) {
  const nameWords = elementName.toLowerCase().split(/\s+/);
  const annotationWords = fuseResult.item.annotation.toLowerCase().split(/\s+/);
  return nameWords.some(word => annotationWords.includes(word));
}
```

**Why each stage**:
- Stage 1: Preserves valuable PUA emojis (narwhal, oil-spill) when they truly match
- Stage 2: Respects LLM's intelligent choices (glass ‚Üí window) when it's confident
- Stage 3: Prevents prefix-only matches (coal ‚Üí collaboration) by requiring word overlap
- Stage 4: Safe fallback to LLM's Unicode choice

#### Step 4: Enhanced Fuzzy Search with Tags
Use `emojiTags` to improve fuzzy matching:

```typescript
// In fuzzy search, when no direct match found:
const queryWithTags = `${elementName} ${tags.join(' ')}`;
const results = fuse.search(queryWithTags);
```

**Why**: Tags like ["coffee", "grinder", "mill"] help find better matches than just "Coffee Grinder".

#### Step 5: Adjust Thresholds
```typescript
// Lower Fuse threshold: 0.32 ‚Üí 0.25 (more selective)
// Raise override threshold: 0.35 ‚Üí 0.15 (fewer bad overrides)
```

**Why**: Empirically reduces false positives while keeping good matches.

### 4.5. Expected Outcomes

| Element | Current Result | New Result | Why It's Better |
|---------|---------------|------------|-----------------|
| Coal | ü§ù collaboration | ‚ö´ coal | Prevents prefix collision |
| Glass (material) | ü•õ milk glass | ü™ü window | LLM's intelligent choice (high confidence) |
| Narwhal | üêã whale | ü¶Ñ narwhal (PUA) | Prioritizes exact PUA matches |
| Oil Spill | üõ¢Ô∏è oil drum | üåä oil-spill (PUA) | Uses specialized PUA emoji |

### 4.6. Why This Isn't Over-Engineered

1. **Uses existing data**: `emojiTags` already in prompts, just not used
2. **Minimal code**: ~30 lines across 3 files
3. **Simple logic**: Series of if-statements, not complex algorithms
4. **Addresses root cause**: Fixes fuzzy search issues systematically
5. **Preserves good cases**: Keeps valuable PUA emojis and LLM insights

### 4.7. Testing

Create test cases in `openmoji-service.test.ts`:

```typescript
describe('emoji resolution', () => {
  test('prevents prefix collisions', () => {
    expect(resolveEmoji({name: 'coal', confidence: 0.9})).toMatch(/coal|black/);
  });
  
  test('respects high-confidence LLM choices', () => {
    expect(resolveEmoji({name: 'glass', unicode: 'ü™ü', confidence: 0.95})).toBe('ü™ü');
  });
  
  test('prioritizes PUA matches', () => {
    expect(resolveEmoji({name: 'narwhal'})).toMatch(/narwhal/);
  });
});
```

### 4.8. Implementation Details

**Type Safety**:
- Add optional `confidence?: number` to `ResolveEmojiParams` interface
- Make `emojiConfidence` required in JSON schema with bounds: `{"type":"number","minimum":0,"maximum":1}`
- Fix test parameter name: use `unicodeEmoji` not `unicode`

**Cache Fix**:
- Update cache key to include confidence bucketing: `${name}|${tags.join(',')}|${Math.round((confidence ?? 0.5) * 10)}`
- Prevents serving wrong confidence results from cache

**Guard Implementation Fixes**:
- Use `wrap()` for fallback instead of undefined `fallback` variable
- Make tokenOverlap case-insensitive to handle "Oil Spill" vs "oil-spill"
- Add `unicodeMap.has()` check in stage 2 to prevent 404s for unknown Unicode
- Confidence clamping: `Math.min(Math.max(raw,0),1)` for parser robustness

**Thresholds**:
- Fuzzy search: 0.32 ‚Üí 0.25 (more selective)
- Override threshold: 0.35 ‚Üí 0.15 (fewer bad overrides)

### 4.9. Files to Modify

1. **`src/lib/llm-prompts.ts`**: Add required `emojiConfidence` to schema
2. **`src/app/api/generate/route.ts`**: Extract, clamp confidence & call resolveEmoji
3. **`src/lib/openmoji-service.ts`**: Implement multi-stage guard with fixes above

**Total estimated work**: 2-3 hours for an experienced developer.
